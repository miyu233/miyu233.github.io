[{"title":"UNITY练习笔记","url":"/2021/06/14/UNITY%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"实用的工具ZealZeal的官网\nZeal是一个离线API查看工具，支持205种文档（截止至2021/6/2），最大的好处是不需要联网，能随时查看（拯救断网大学生），查询速度也很快，对比很多服务器在国外的文档真的能节省很多时间。\n以我用它来查unity3d的api文档的体验来说，比官网好太多了。\n此外绝大部分语言的API都可以查询，你就不需要在网页上开那么窗口了，浏览器可以解放出来查询一些比较有价值的问题（当一个程序员解决了一个bug时.gif）。\n缺点也是有的，最大的缺点就是只有英文，需要一定的英语阅读能力，可能代码写着写着就一转背单词了，建议搭配查词软件一起使用，不要翻译一整句话，遇到不会的单词再翻译而后自己理解，既学到了单词又保证了效率。\n还有一个缺点就是丑，不过可以通过自己写css代码导入来美化。\n生命周期学习了unity中的代码周期，所有unity产生的c#脚本都会引用UnityEngine，所有的类都会继承自Monobehavior。c#中代码执行顺序并非像js一样自上而下，而有固定顺序，以下执行顺序为自顶向下：\n官方文档地址\n\nawake()\n\nOnEnable()\n\nStart()\n\nFixedUpdate()\n\nOnTrigger() 系列\n\nOnTriggerEnter()：触碰到trigger执行一次\nOnTriggerExit()：离开trigger执行一次\nOnTriggerStay()：触碰到trigger时每一帧执行一次\n\n\nOnCollision() 系列\n\nOnCollisionEnter()：触碰到Collision执行一次\nOnCollisionExit()：离开Collision执行一次\nOnCollisionStay()：触碰到Collision时每一帧执行一次\n\n\nOnMouseUp()\n\nOnMouseDown()\n\nUpdate()\n\nLateUpdate()（在这一帧刷新出来后执行）\n\nOnGUI()\n\nOnDestroy()\n\n\n序列化实现存储和加载游戏游戏存档和读档的原理就是将游戏进行的数据保存在一个文件中。当重新载入游戏时，会首先读取这个文件，然后根据文件的数据动态创建游戏内容，让玩家得以从上次结束的地方重新开始。这给人的感觉就像是机器记住了游戏内容，其实并不，机器只是记住了一个游戏内容清单而已。\n什么是序列化和反序列化游戏存档和读档的原理就是将游戏进行的数据保存在一个文件中。当重新载入游戏时，会首先读取这个文件，然后根据文件的数据动态创建游戏内容，让玩家得以从上次结束的地方重新开始。这给人的感觉就像是机器记住了游戏内容，其实并不，机器只是记住了一个游戏内容清单而已。\n使用序列化需要添加头文件：\nusing System.IO;using System.Runtime.Serialization.Formatters.Binary;   //储存2进制文件\n\n\n序列化：将对象转化成为字节流，如下图所示，对象可以是Unity中任意脚本或文件，事实上，当创建一个 MonoBehaviour 脚本时，Unity 会通过序列化/反序列化将文件转换成 C++ 代码，然后变成你在检查器窗口中看见的 c# 代码。 \n\n\n反序列化：序列化的反面，将一个字节流转换成对象。\n\nJSON：一种和语言无关的数据交换格式。 当进行 对象 to JSON 和 JSON to 对象 转换时，可以分别将这两种称作称作 JSON 序列化 和 JSON 反序列化。 \n\n\n1 游戏存档新建一个游戏存档类GameData，取消MonoBehaviour继承。这个类用于存放游戏载入时应该加载的东西，即为前言所述游戏内容清单。\n有一句非常重要的代码[System.Serializable]需要添加在类声明之上。这是一个属性，它标明了代码的一个元数据。它告诉 Unity 这个类可以被序列化，这意味着你可以将它转换成字节流并保存到磁盘文件中。 \n[System.Serializable]public class GameData&#123;    public Vector3 playerTransform;    //玩家位置    //public List&lt;Transform&gt; enemyTransfrom = new List&lt;Transform&gt;();   //敌人位置    public int lifePoint;   //玩家生命值    public string gameTime; //玩家游戏时间，形如 00h00m00s    public int gameSec;&#125;\n\n\n\n2 游戏保存新建一个GameSave类，这个类提供一个静态方法SaveGame()，静态保证可以在其他类中调用。\npublic class GameSave : MonoBehaviour&#123;    static public void SaveGame() &#123;        GameData gameData = new GameData();        string path = Application.persistentDataPath + &quot;/game_saveData&quot;;        //判断目录是否存在，不存在则创建        if (!Directory.Exists(path)) &#123;            Directory.CreateDirectory(path);        &#125;        BinaryFormatter bf = new BinaryFormatter();  //二进制化        FileStream file = File.Create(path + &quot;/gameData.txt&quot;);        //获取数据        PlayerController data = GameObject.Find(&quot;Knight&quot;).GetComponent&lt;PlayerController&gt;();        gameData.lifePoint = data.lifePoint;        float x = data.transform.position.x;        float y = data.transform.position.y;        float z = data.transform.position.z;        gameData.playerTransform = new Vector3(x, y, z);        gameData.gameTime = data.gameTime;        gameData.gameSec = data.gameSec;        //将二进制文件保存为JSON，使用二进制查看软件打开可看到具体数据        var json = JsonUtility.ToJson(gameData);        bf.Serialize(file, json);    //将二进制数据写入文件        file.Close();    &#125;&#125;\n\n\n\n3 游戏读取新建一个游戏读取类GameLoad，提供一个静态方法LoadGame()，返回值是GameData类型，如果无数据则返回null。\npublic class GameLoad : MonoBehaviour&#123;    static public GameData LoadGame() &#123;        GameData gameData = new GameData();        BinaryFormatter bf = new BinaryFormatter();        string path = Application.persistentDataPath + &quot;/game_saveData/gameData.txt&quot;;        if (File.Exists(path)) &#123;            FileStream file = File.Open(path, FileMode.Open);            JsonUtility.FromJsonOverwrite((string)bf.Deserialize(file), gameData);            file.Close();            return gameData;        &#125;        return null;    &#125;&#125;\n\n\n\n游戏时长最开始只在GameData中储存了一个string变量gameTIme，里面存放的是格式化后的游戏时间，形如 00h00m00s。\n出现的问题是，重新保存存档时，势必要知道上一次存档时的游戏时间，虽然可以用gameTime再转换回去，但是显然多存储一个总时间秒数更方便，于是又添加了一个int型变量gameSec。\n[System.Serializable]public class GameData&#123;    public Vector3 playerTransform;    //玩家位置    //public List&lt;Transform&gt; enemyTransfrom = new List&lt;Transform&gt;();   //敌人位置    public int lifePoint;   //玩家生命值    public string gameTime; //玩家游戏时间，形如 00h00m00s    public int gameSec;&#125;\n\n\n\n但是还没完。我用的是Time.time获取游戏时间，如果采用这种方法的话，加载存档之后，第一次保存是正确的，第二次及以后保存的时间累加了重复值，并不是真实游戏时间。\n解决方法是在PlayerController中维护一个变量preSaveTime（注意不是GameData）用于记录上一次保存时的Time.time，写入时的代码改成：\nvoid Save() &#123;    GameData gameData = GameLoad.LoadGame();    gameSec = (int)Time.time - preSaveTime + gameData.gameSec;    preSaveTime = (int)Time.time;    int hour = gameSec / 3600;    int min = (gameSec % 3600) / 60;    int sec = (gameSec % 3600) % 60;    gameTime = hour + &quot; h &quot; + min + &quot; m &quot; + sec + &quot; s &quot;;    GameSave.SaveGame();&#125;\n\n同时在Start中添加：\npublic void LoadGameData() &#123;    GameData gameData = GameLoad.LoadGame();    if (gameData != null) &#123;        transform.position = gameData.playerTransform;        lifePoint = gameData.lifePoint;        gameSec = gameData.gameSec;    &#125;&#125;\n\n\n\n对象池实现Dash残影效果简单介绍一下对象池（Object Pool）对象池是一种十分常见的游戏开发设计模式。\n该技术就是通过建立一个包含许多（待使用）对象的容器，提供对象的创建和销毁方法，按需取用，大大提升开发效率和资源占用。\n以一个形象的例子来比喻的话，打网球的人常常在口袋里揣两三个网球，这样就可以多打几轮而不用每次丢球都要去捡球。你可以把对象池想象成一个巨大的口袋，里面存放了很多网球，直到你口袋中所有球用完之前，你可以快乐很久。想象在宽阔的网球场捡球的疲惫样子，你大概就可以理解对象池给开发带来的便利。\n对象池的具体好处当游戏中需要创建和销毁大量相同的物品时，如果使用Instantiate和Destory的方式来完成该需求时，会占用大量的系统资源，有可能导致内存溢出，进程崩溃。这个时候需要使用对象池。\n对象池的实现该对象池的实现需要新建两个脚本：对象和池。\n\nShadowSprite（对象）：这个脚本用于控制Shadow对象的参数，例如不透明度，消失时间等等：\n[Header(&quot;时间控制参数&quot;)]public float activeTime;//显示时间public float activeStart; //开始显示的时间点[Header(&quot;不透明度控制&quot;)]public float alpha;public float alphaSet; //初始值public float alphaMultiplier;   //递减参数\n\n\n起始时要获取Player的Sprite，位置，大小和旋转角度（最后这个好像也无所谓，毕竟固定z轴）。\n\nprivate void OnEnable() &#123;    player = GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform;    thisSprite = GetComponent&lt;SpriteRenderer&gt;();    playerSprite = player.GetComponent&lt;SpriteRenderer&gt;();    alpha = alphaSet;    thisSprite.sprite = playerSprite.sprite;    //拿到player的sprite    transform.position = player.position;   //位置，省略this    transform.localScale = player.localScale;   //大小    transform.rotation = player.rotation;   //角度    activeStart = Time.time;&#125;\n\n\n在Update中检测时间，如果到达activeTime，则返回对象池\n\nif (Time.time &gt; activeStart + activeTime) &#123;    //返回对象池    ShadowPool.instance.ReturnPool(this.gameObject);&#125;\nShadowPool（对象池）：\n\n采用队列储存对象，因为残影的特点是先出现的先到达activeTime，所以它会先回到对象池中，下面是c#定义队列的代码：\n\nCount获取队列长度\nEnqueue()进入队列\nDequeue()弹出队列\n\nprivate Queue&lt;GameObject&gt; availableObjects = new Queue&lt;GameObject&gt;();\n对象池的核心是提供对象的调用和返回，区别于普通的对象创建和删除，这里的调用和返回是通过SetActive实现：\npublic void ReturnPool(GameObject obj) &#123;    obj.SetActive(false);    availableObjects.Enqueue(obj);&#125;public GameObject GetFromPool() &#123;    if (availableObjects.Count == 0) FillPool();    var outShadow = availableObjects.Dequeue();    outShadow.SetActive(true);    return outShadow;&#125;\n\nif (availableObjects.Count == 0) FillPool();\n如果对象池空了，那么就扩容。\n\n\n\n\n​    \nUnity游戏开发的合作模式准备工作准备阶段要做的工作很重要。\n需要一个主程将功能点清晰独立的分开，定义好global变量。如果正规，画好类图、流程图、计划好各功能模块之间的接口。\n搭建好场景，规定并且在Unity中配置好Layer和Tags，安装好要使用的Package。整理好项目文件，规定命名规则和使用规则。脚本，AudioMixer，动画机等等必须按照功能分文件存储。\n主程配置好项目后应该将项目文件分发给组员，组员在Unity Hub中导入该项目文件，在新电脑上Unity会自动完成上述配置。这种方式能确保没有遗漏。\n规定当完成一个GameObject的配置时，将其放入Prefabs文件夹中供其他人使用。\n如何导入 不同的程序员不要同时操作Unity的同一个Scene。项目合并可以通过Import Package和Export Package来完成。Import和Export会自动识别并合并项目中不同的文件，如果同名则新文件会覆盖旧文件。所以最好成员都在自己的Scene中工作。\n代码冲突需要借助其他冲突解决工具进行逐行Merge，不能使用上述功能。\n键盘按键轻重控制跳跃高低思路是取一个指标衡量按键轻重，通过这个值的变化来控制跳跃高低。\n这个指标可以是按键时间长短。这样需要注意的一个问题是：时长的统计不应该在按键松开时完成，而必须时刻判断当前距离按下跳跃键那个时刻过去了多久，如果Player的跳跃只有在松开时才进行那么会十分影响手感。\nif (Input.GetKeyDown(KeyCode.Space)) &#123;    jumpStartTime = Time.time;&#125;if (Input.GetKey(KeyCode.Space)) &#123;    jumpTimer = Time.time - jumpStartTime;    if (rb.gravityScale &gt; 1.5) &#123;        rb.gravityScale -= jumpTimer * 2;        if (rb.gravityScale &lt; 1.5) &#123;            rb.gravityScale = 1.5f;        &#125;    &#125;&#125;\n\n目前采取的是控制重力的方式来控制跳跃力度，确实能实现功能，但是效果并不理想，高低的区分度不大，同时也会延长下落的时间，距离空洞骑士那种平滑的跳跃和下落还差的远。\n控制加速度可能是个更好的选择。\n修改如下：\n//用于记录按下跳跃键长短，控制跳跃高度void MidAirJump() &#123;    if (Input.GetKeyDown(KeyCode.Space)) &#123;        jumpStartTime = Time.time;    &#125;    if (Input.GetKey(KeyCode.Space)) &#123;        jumpTimer = Time.time - jumpStartTime;        if (jumpTimer &lt; 0.1f &amp;&amp; jumpTimer &gt; 0.05f) &#123;            rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);        &#125;    &#125;&#125;\n\n将控制重力修改成了添加加速度，AddForce中填入一个二维的向量，分别表示在水平和竖直方向添加的加速度。ForceMode2D.Impulse是一种添加力的模式，这种模式的力就像是突然出现的一样。\njumpTimer &gt; 0.5f的原因是防止玩家不断地小按跳跃键，这样会导致Player可以不断获得一个向上的力，超越了二段跳。\n如何实现技能冷却的UI设置在Image中选择Filled的Image Type，其中有一个选项叫做Fill Amout，这个选项可以实现让一张Image按选定的方式加载。Fill Method中选定加载方式，以Radial 360为例子（扇形加载）实现Dash技能的CD图标。\n\n在UI中新建一张image，Source image中选择一张图片\n\n该image下新建一个子image，相同大小，相同位置，相同图标，颜色全黑，透明度调低\n\n对于该子image，image type选Filled，Method选Horizontal，Fill Origin选择Left， 初始的Fill Amout改为0，表示技能可用\n\n在脚本中新建一个Image对象，将父image拖拽，在Update中写上一句核心代码（记住就好）：\ncdImage.fillAmount -= 1.0f / dashCoolDown * Time.deltaTime;\ndashCoolDown表示冷却时间，该冷却条会在dashCoolDown时间内加载完成\n\n\n其他Sprite 和 UI Image 的区别​    详细戳我\n\n 在Hierarchy窗口,你可以把sprites随便放在哪。然而，UI Images不得不放在canvas下面。你可以通过transform移动其他obejcts那样移动sprites,但是images使用RectTransform来在界面系统中移动。 \n 性能上有十分大的差别，如下两张图所示，Sprite会生成更复杂的网格，所以Sprite开销更大。  \n\n            \n\n \n\n注意使用 Image 和 Text 需要添加 Using UnityEngine.UI。\nTrigger和Collider的区别Collider有碰撞的效果， 可以调用 OnCollisionEnter/ Stay / Exit 函数，分别是碰撞进入 / 逗留 / 离开。\nTrigger 只是触发器，没有碰撞效果， 可以调用 OnTriggerEnter/ Stay / Exit 函数。分别是触发进入/ 逗留 /离开。 \n不可以同时发生碰撞和触发。\n发生碰撞的必要条件\n两个物体都必须带有碰撞盒。\n至少有一个物体带有Rigidbody组件。\n两个物体要发生相对位移。\n\n动画系统中Trigger和Bool参数的区别Bool表示状态，当设置为true or false之后，不会自动回复原来的状态。\n而Trigger是一个触发器，当SetTrigger之后，会自动回复原来的状态。\nInput修改通过Edit - Project Setting 可以修改Input绑定的值\nSprite很糊\n 人物的 Sprite为什么看起来很模糊？\n\n可能并不是因为分辨率过低造成的，反而是过高而导致的显示问题，不用管。\n\n如何在同一帧内设置两张图片。例如人物挥刀时的挥刀动画和刀光的动画不能耦合在一起，如何让两种动画按指定方式显示？\n\n可以在角色下建立不同的Game Object，在指定动画中选择Add Property-Is Active。该Object默认为关闭，当进行到关键帧时设置Active为true。\nHas Exit Time\nInspector窗口中的Has Exit Time是指切换动画时是否要将当前动画播放完再切换，Exit Time的参数是指当前动画播放长度，0为不播放，1为完整播放\n\n下方Transition Duration是指过渡动画所需要的时间，在该时间内，动画A和动画B同时开始计时（如果设置了Exit Time，则过了Exit Time之后B才开始计时），在该时间内，会先播放动画A，大概过了一半左右的时间，切换到动画B\n\nany state是一个始终存在特殊状态，如其字面意思，可以通过它让任意一个状态切换到某个状态。其中有一个Can Transition To Self的选项，意思为是否允许重置自身状态\n\n\nCan Transition to Self当使用Any state切换到Jump动画时出现了Jump动画只播放第一帧的情况，当将any state的Can Transition To Self选项取消后解决，推测原因是每一帧都进行了Jump to Jump的切换。Can Transition To Self 的意思是允许自己切换到自己。\nUpdate和FixUpdate问题描述：发现有时二段跳手感有问题：\n\n当快速按下两次跳跃键时有很大概率无法触发二段跳\n下落时有时无法触发二段跳\n\n修改方法：\n\n将Movement()和CheckOnGround()函数放在FixUpdate中而不是Update中\n\n原因分析：\n\n一个老生常谈的问题，Update函数每一帧执行一次，FixUpdate函数每一秒执行50次。FixUpdate的诞生是为了解决Update在不同电脑上运行次数不同的缺陷。这种缺陷会导致GameObject的物理效果展现不自然，所以所有有关Rigidbody的代码都应该放在FixUpdate中\n\n控制子动画播放将要被叠加的动画所在的gameobject称作A，想要叠加上的动画所在的gameobject称为B，先将B设置为A的子gameobject。\n在A的Animation窗口中对于待叠加的动画选择Add Property，该选项可以控制子物体。\n确定具体的帧，控制B的is active，就可以控制其在某一帧的播放与否。\n\n修复了主角在空中攻击时二段跳无法切换二段跳动画的bug\n修复了在空中可能出现WalkStart的动画的bug\n\n","categories":["Unity"],"tags":["Zeal","序列化与反序列化","对象池"]},{"title":"卷积神经网络基础","url":"/2022/02/20/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","content":"1 二维卷积1.1 二维互相关虽然卷积层得名于卷积（convolutional neural network）运算，但是我们通常在卷积层中使用更加直观的互相关（cross-correlation）运算。二维卷积层中，一个二维输入数组和一个二维核（kernel）数组进行互相关运算输出一个二维数组。\n如下图所示，输入数组形状为（3,3），核在卷积运算中又被称为卷积核或过滤器（filter）。输入数组和过滤器对应数字相乘相加得到输出数组对应答案，然后通过滑动窗口补齐输出数组。\n\n下面实现上述过程：\nimport torchfrom torch import nndef corr2d(X, K): # X是输入，K是卷积核，K是二维    h, w = K.shape    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))    for i in range(Y.shape[0]):        for j in range(Y.shape[1]):            Y[i, j] = (X[i: i + h, j: j + w] * K).sum()  # 对应数字相乘相加    return Y\n\n在真实的卷积层中，除了互相关运算之外，往往还需要添加上一个标量偏差。卷积层的模型参数里包含了卷积核和标量偏差。在训练模型时，通常我们首先对卷积核随机初始化，然后不断迭代卷积核和偏差。\nclass Conv2D(nn.Module):    def __init__(self, kernel_size):        super(Conv2D, self).__init__()        self.weight = nn.Parameter(torch.randn(kernel_size))        self.bias = nn.Parameter(torch.randn(1))            def forward(self, X):        return corr2d(X, self.weight) + self.bias\n\np * q 卷积或 p * q 卷积核说明卷积核的高和宽分别为 p 和 q。\n1.2 图像边缘检测我们来看卷积层的一个简单应用：图像边缘检测，即找到像素变化的位置。首先我们构造一张 6 * 8 大小的图像。中间四列为黑（0），两边为白（1）。\nX = torch.ones(6, 8)X[:, 2:6] = 0X\n\ntensor([[1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.]])\n\n然后构造一个卷积核 K，高和宽分别为 1 和 2，输出为 0 说明横向相邻元素相同。让其与 X 作互相关运算。可以看出来，从白到黑的边缘和从黑到白的边缘分别检测成了 1 和 -1。其余输出都是 0。\nK = torch.tensor([[1, -1]])Y = corr2d(X, K)Y\n\ntensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])\n\n最后来做一个梯度下降求我们构造的卷积核的例子。首先随机初始化一个卷积层，在每一次迭代中，使用平方误差来比较真实值和学习值的输出，然后更新权重。\n# 构造一个核数组形状是（1,2）的二维卷积层conv2d = Conv2D((1, 2))step = 20lr = 0.01for i in range(step):    Y_hat = conv2d(X)    l = ((Y_hat - Y) ** 2).sum()    l.backward() # 反向传播求梯度        # 梯度下降    conv2d.weight.data -= lr * conv2d.weight.grad    conv2d.bias.data -= lr * conv2d.bias.grad        # 梯度清0    conv2d.weight.grad.fill_(0)    conv2d.bias.grad.fill_(0)        if (i + 1) % 5 == 0:        print(&quot;Step %d, loss %.3f&quot; % (i + 1, l.item()))\n\nStep 5, loss 0.748Step 10, loss 0.091Step 15, loss 0.012Step 20, loss 0.002\n\n\n\n1.3 特征图和感受野二维卷积层输出的二维数组可以看做是输入在空间维度（宽和高）上某一级的表征，也叫特征图（features map）。影响元素 x 的前向计算的所有可能输入区域叫做 x 的感受野（receptive field）。以下图为例，输出就是整个输入的特征图，输入中阴影部分的四个元素是输出中阴影部分元素的感受野。\n\n2 填充和步幅根据输入数组的形状和卷积核形状我们是否能得到输出形状？答案是可以的。假设输入形状是$n_h \\times n_w$，卷积核窗口形状为$k_h \\times k_w$，那么输出形状会是：$$(n_h - k_h + 1) \\times (n_w - k_w + 1)$$实际上，除了输入形状和卷积核形状之外，还会有两个因素影响输出形状，那就是接下来要介绍的两个超参数，填充（padding）和步幅（stride）。\n2.1 填充填充（padding）是指在输入高和宽的两侧填充元素（通常是 0 元素）。如下图我们在原来的高和宽的两侧分别添加了一层 0 元素，使得高和宽从 3 变成了 5，并导致输出高和宽由 2 增加到 4。\n\n一般来说，如果在高的两侧一共填充$p_h$行，在宽的两侧一共填充$p_w$列，那么输出形状将会是$$(n_h - k_h + p_h + 1) \\times (n_w - k_w + p_w + 1)$$也就是说，输出的宽和高会分别增加$p_h$和$p_w$。\n很多情况下，我们会设置$p_h = k_h - 1$和$p_w = k_w - 1$来使输入和输出具有相同的高和宽。这样会方便在构造网络时推测每个层的输出形状。假设这里$k_h$是奇数，那么我们会在高德两侧分别填充$p_h / 2$行。一般卷积神经网络都采用奇数高宽的卷积核。\n2.2 步幅步幅（stride）就是指滑动窗口在输入数组每次滑行的行数和列数。默认为（1, 1），即一次同时滑动一行和一列。\n还是使用上述例子，我们将宽步幅调整为 2，高步幅调整为 3。如图所示，卷积窗口在输入上再向右移动两列时无法填满窗口，所以无结果输出，最后输出大小为（2,2）。\n\n一般来说，当高步幅为$s_h$，宽步幅为$s_w$时，输出形状为：$$\\lfloor (n_h - k_h + p_h + s_h) / s_h \\rfloor \\times \\lfloor (n_w - k_w + p_w + s_w) / s_w \\rfloor$$\n3 多通道上述例子都采用的是二维数组，但是真实数据维度往往更高。例如，彩色图像除了高和宽之外还有 RGB 三个颜色通道，假设彩色图像的高和宽为 h * w，那么我们就可以把它表示成一个 3 * h * w 的多维数组。\n3.1 多输入通道假设卷积核形状为$k_h \\times k_w$，当通道数大于 1 时，我们会为每一个通道分配一个同样的形状为$k_h \\times k_w$的卷积核，这样就如同卷积核也有了多通道，让对应卷积核和每个通道的输入进行互相关运算，然后按通道相加，最后得到一个二维数组，这个二维数组就是输出。\n\n接下来我们来实现含多个输入通道的互相关运算。我们只需要对每个通道做互相关运算，然后通过add_n函数来累加即可。\nimport torchfrom torch import nnimport syssys.path.append(&quot;..&quot;)import d2lzh_pytorch as d2ldef corr2d_multi_in(X, K):    # 沿着X和K的第0维分别计算再相加    res = d2l.corr2d(X[0, :, :], K[0, :, :])    for i in range(1, X.shape[0]):        res += d2l.corr2d(X[i, :, :], K[i, :, :])    return res\n\nX = torch.tensor([[[0, 1, 2], [3, 4, 5], [6, 7, 8]],                  [[1, 2, 3], [4, 5, 6], [7, 8, 9]]])K = torch.tensor([[[0, 1], [2, 3]], [[1, 2], [3, 4]]])corr2d_multi_in(X, K)\n\ntensor([[ 56.,  72.],        [104., 120.]])\n\n\n\n3.2 多输出通道假设输入通道数和输出通道数分别为$c_i,c_o$，如果我们希望得到含多个通道的输出，我们可以为每个输出通道分别创建形状为 $c_i \\times k_h \\times k_w$的核数组。将它们在输出通道维度上连接，卷积核形状为$c_o \\times c_i \\times k_h \\times k_w$。\n我们将 K，K + 1 和 K + 2 构造一个输出通道数为 3 的卷积核 K。\ndef corr2d_multi_in_out(X, K):    return torch.stack([corr2d_multi_in(X, K) for k in K])K = torch.stack([K, K + 1, K + 2])K.shape # torch.size([3, 2, 2, 2])corr2d_multi_in_out(X, K)\n\n输出结果如下，可以看到第一个通道的结果与之前输入数组 X 的结果一致。\ntensor([[[ 56.,  72.],         [104., 120.]],        [[ 76., 100.],         [148., 172.]],        [[ 96., 128.],         [192., 224.]]])\n\n\n\n3.3 1 * 1 卷积层最后讨论卷积窗口形状为 1 * 1 的多通道卷积层，通常称之为 1 * 1 卷积层。因为使用了最小窗口，所以无法识别相邻元素的模式构成。其主要计算发生在通道维度上。如图所示，输出元素来自输入在高和宽上相同位置的元素在不同通道之间的按权重累加。假设我们将通道维当做特征维，将高和宽维度上的元素当成数据样本，那么 1 * 1 卷积层的作用和全连接层等价。\n\n下面我们使用全连接层中的矩阵乘法来实现 1 * 1 卷积。这里需要在矩阵乘法运算前后对数据形状做一些调整。\ndef corr2d_multi_in_out_1x1(X, K):\tc_i, h, w = X.shape    c_o = K.shape[0]    X = X.view(c_i, h * w)    K = K.view(c_o, c_i)    Y = torch.mm(K, X) # 全连接层的矩阵乘法    return Y.view(c_o, h, w)\n\n1 * 1 卷积层通常用来调整网络层之间的通道数，并控制模型复杂度。\n4 池化层池化层的出现是为了缓解卷积层对位置的过度敏感性。\n4.1 二维最大池化层和平均池化层我们将池化窗口形状为 p * q 的池化层称之为 p * q 池化层。二维最大池化层就是在找出池化窗口在输入窗口的最大值输出，如下图所示。\n\n二维平均池化工作原理与最大池化类似，但是将最大运算符替换成为平均运算符。\n为什么池化可以降低卷积层对位置的敏感性？假设我们将卷积层的输出作为 2 * 2 最大池化的输入。设该卷积层输入为 X，输出为 Y。无论是X[i, j]和X[i, j + 1]值不同，还是X[i, j + 1]还是X[i, j + 2]不同，池化层输出均有Y[i, j] = 1。也就是说，使用 2 * 2最大池化层，是要卷积层识别的模式在高和宽上移动不超过一个元素，我们依然可以将它检测出来。\n下面来实现池化：\nimport torchfrom torch import nndef pool2d(X, pool_size, mode=&quot;max&quot;):    X = X.float()    p_h, p_w = pool_size    Y = torch.zeros(X.shape[0] - p_h + 1, X.shape[1] - p_w + 1)    for i in range(Y.shape[0]):        for j in range(Y.shape[1]):            if mode == &quot;max&quot;:                Y[i, j] = X[i : i + p_h, j: j + p_w].max()            elif mode == &quot;avg&quot;:                Y[i, j] = X[i : i + p_h, j: j + p_w].mean()    return Y\n\nX = torch.tensor([[0, 1, 2], [3, 4, 5], [6, 7, 8]])pool2d(X, (2, 2))\n\ntensor([[4., 5.],        [7., 8.]])\n\n再来测试一下平均池化层：\npool2d(X, (2, 2), &quot;avg&quot;)\n\ntensor([[2., 3.],        [5., 6.]])\n\n\n\n4.2 填充和步幅池化层也可以在在输入的高和宽的两侧填充并调整窗口的移动步幅来改变输出形状。池化层填充和步幅与卷积层工作机制一致。我们可以使用 nn 模块里的MaxPool2d来实现池化层的填充和步幅。首先构造一个形状为（1,1,4,4）的输入，前两个维度飞奔是批量和通道。\nX = torch.arange(16, dtype=torch.float).view((1,1,4,4))X\n\ntensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]]]])\n\n默认情况下，MaxPool2d实例里的步幅和池化窗口形状相同，下面使用形状为（3,3）的池化窗口，默认获得形状为（3,3）的步幅。记住当窗口不够时不会输出。\npool2d = nn.MaxPool2d(3)pool2d(X)\n\ntensor([[[[10.]]]])\n\n也可以制定非正方形池化窗口，分别制定高和宽上的填充和步幅。\npool2d = nn.MaxPool2d((2, 4), padding=(1, 2), stride=(2, 3))pool2d(X)\n\ntensor([[[[ 1.,  3.],          [ 9., 11.],          [13., 15.]]]])\n\n\n\n4.3 多通道处理多通道输入数据时，池化层对每个输入通道分别池化，而不是像卷积层那样将各个通道的输入按通道相加。这意味着池化层的输出通道和输入通道数相同。输入通道数为 2。\nX = torch.cat((X, X + 1), dim=1)X\n\ntensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]],         [[ 1.,  2.,  3.,  4.],          [ 5.,  6.,  7.,  8.],          [ 9., 10., 11., 12.],          [13., 14., 15., 16.]]]])\n\n可以发现，输出通道数也为 2。\npool2d = nn.MaxPool2d(3, padding=1, stride=2)pool2d(X)\n\ntensor([[[[ 5.,  7.],          [13., 15.]],         [[ 6.,  8.],          [14., 16.]]]])\n\n\n\n5 卷积神经网络模型5.1 LeNet这是一个早期用来识别手写数字图像的卷积神经网络。LeNet 网络结果如下图所示：\n\n它的结构分为卷积层块和全连接层块。\n卷积层块中的基本单位是卷积层后接最大池化层。卷积层采用（5，5）的窗口，并在输出上选择 sigmoid 激活函数。第一个卷积层输出通道数为 6，第二个增加到 16。这是因为第二个卷积层比第一个卷积层输入的高和宽要小，所以增加输出通道使得两个卷积层的参数尺寸类似。最大池化层窗口形状为（2,2），步幅为2。\n卷积层块的输出形状为（批量大小，通道，高，宽），卷积层块输出即为全连接层输入。传入时，全连接层块会将小批量中的每个样本变平（flatten）。\n下面使用Sequential来实现 LeNet 模型。\nimport timeimport torchfrom torch import nn, optimimport syssys.path.append(&quot;..&quot;)import d2lzh_pytorch as d2ldevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)class LeNet(nn.Module):    def __init__(self):        super(LeNet, self).__init__()        self.conv = nn.Sequential(            nn.Conv2d(1, 6, 5), # in_channels, out_channels, kernel_size            nn.Sigmoid(),            nn.MaxPool2d(2, 2),            nn.Conv2d(6, 16, 5),            nn.Sigmoid(),            nn.MaxPool2d(2, 2)        )                self.fc = nn.Sequential(            nn.Linear(16*4*4, 120),            nn.Sigmoid(),            nn.Linear(120, 84),            nn.Sigmoid(),            nn.Linear(84, 10)        )            def forward(self, img):        feature = self.conv(img)        output = self.fc(feature.view(img.shape[0], -1))        return output\n\n我们来查看一下网络结构\nnet = LeNet()print(net)\n\nLeNet(  (conv): Sequential(    (0): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))    (1): Sigmoid()    (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)    (3): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))    (4): Sigmoid()    (5): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)  )  (fc): Sequential(    (0): Linear(in_features=256, out_features=120, bias=True)    (1): Sigmoid()    (2): Linear(in_features=120, out_features=84, bias=True)    (3): Sigmoid()    (4): Linear(in_features=84, out_features=10, bias=True)  ))\n\n\n\n5.2 AlexNet这是一个计算机视觉史上划时代的模型，它首次证明了学习到的特征可以超越手工设计的特征，从而一举打破计算机视觉研究的前状。\n\nAlexNet 与 LeNet 设计理念十分相似，但也有显著的区别。例如，AlexNet 将 sigmoid 激活函数更换成了 ReLU 函数，其计算更简单，而且在不同的参数初始化方法下使模型更容易训练。AlexNet 添加了丢弃法来控制全连接层模型的复杂度，并引入了大量的图像增广，如翻转、裁剪等等手段扩大数据集来缓解过拟合的现象。\n来看看其网络结构吧：\nclass AlexNet(nn.Module):    def __init__(self):        super(AlexNet, self).__init__()        self.conv = nn.Sequential(            nn.Conv2d(1, 96, 11, 4), # in, out, kernel_size, stride, padding            nn.ReLU(),            nn.MaxPool2d(3, 2), # kernel_size, stride            # 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数            nn.Conv2d(96, 256, 5, 1, 2),            nn.ReLU(),            nn.MaxPool2d(3, 2),            # 连续3个卷积层，且使用更小的卷积窗口。除了最后的卷积层外，进一步增大了输出通道数            # 前两个卷积层不适用池化来减小输入的宽和高            nn.Conv2d(256, 384, 3, 1, 1),            nn.ReLU(),            nn.Conv2d(384, 384, 3, 1, 1),            nn.ReLU(),            nn.Conv2d(384, 256, 3, 1, 1),            nn.ReLU(),            nn.MaxPool2d(3, 2)        )                self.fc = nn.Sequential(            nn.Linear(256*5*5, 4096),            nn.ReLU(),            nn.Dropout(0.5),            nn.Linear(4096, 4096),            nn.ReLU(),            nn.Dropout(0.5),            # 输出层。如果这里用的是ImageNet，那么类别数就是1000。            nn.Linear(4096, 1000)        )            def forward(self, img):        feature = self.conv(img)        output = self.fc(feature.view(img.shape[0], -1))        return output\n\nnet = AlexNet()print(net)\n\nAlexNet(  (conv): Sequential(    (0): Conv2d(1, 96, kernel_size=(11, 11), stride=(4, 4))    (1): ReLU()    (2): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)    (3): Conv2d(96, 256, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))    (4): ReLU()    (5): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)    (6): Conv2d(256, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))    (7): ReLU()    (8): Conv2d(384, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))    (9): ReLU()    (10): Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))    (11): ReLU()    (12): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)  )  (fc): Sequential(    (0): Linear(in_features=6400, out_features=4096, bias=True)    (1): ReLU()    (2): Dropout(p=0.5, inplace=False)    (3): Linear(in_features=4096, out_features=4096, bias=True)    (4): ReLU()    (5): Dropout(p=0.5, inplace=False)    (6): Linear(in_features=4096, out_features=1000, bias=True)  ))\n\nAlexNet 虽然与 LeNet 结构类似，但是使用了更多的卷积层和更大的参数空间来拟合大规模数据集 ImageNet。它是浅层神经网络和深度神经网络的分界线。\n5.3 ResNet5.3.1 批量归一化来介绍批量归一化（batch normalization）层，它能让较深的神经网络训练起来更加容易。批量归一化并不是模型，因为后面的一些模型需要用上此概念，所以先介绍一下。\n有时我们会对输入数据做标准化处理：处理后的任意一个特征在数据集中所有样本的均值为 0，标准差为 1。标准化处理输入数据使得各个特征分布相近：这往往更容易训练出有效的模型。\n但是标准化处理不太能应付深度神经网络，训练中的模型参数的更新依然很容易让靠近输出层的输出剧烈变化。批量归一化就是为了应对这一挑战而诞生的，在模型训练时，批量归一化利用小批量上的均值和标准差，不断调整神经网络的输出，从而使得整个神经网络在各层的中间输出的数值更加稳定。\n批量归一化的过程在全连接层和卷积层有所不同。\n首先介绍在全连接层的步骤：通常，我们将批量归一化层置于全连接层中的仿射变换和激活函数之间。设全连接层的输入为 u，权重和偏差分别为 W 和 b，激活函数为 R。设批量归一化的运算符为 BN。那么，使用批量归一化的全连接输出为：$$R(BN(x))$$其中$x = Wu + b$。\n考虑一个由 m 个小样本组成的批量，仿射变换的输出得到一个新的小批量 B，这正是批量归一化层的输入。我们首先对这个小批量 B 求均值$\\mu$和方差$\\sigma$：$$\\mu = \\frac{1}{m}\\sum_{i=1}^m x^i ,\\ \\sigma = \\frac{1}{m}\\sum_{i=1}^m(x^i - \\mu)^2$$再对 x 进行标准化处理，其中$\\epsilon &gt; 0$是一个非常小的数，保证分母大于 0。$$\\hat x^i = \\frac{x^i - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}}$$在上面标准化的基础上，批量归⼀化层引入了两个可以学习的模型参数，拉伸（scale）参数$\\gamma$和偏移（shift）参数$\\beta$ 。这两个参数和形状相同。它们与分别做按元素乘法（对应元素点乘）和加法计算即可得到结果：$$y^i = \\gamma \\odot \\hat x^i + \\beta$$对卷积层来说，批量归⼀化发⽣在卷积计算之后、应⽤激活函数之前。如果卷积计算输出多个通道，我们需要对这些通道的输出分别做批量归⼀化，且每个通道都拥有独立的拉伸和偏移参数，并均为标量。\n下面来实现批量归一化层\nimport timeimport torchfrom torch import nn, optimimport syssys.path.append(&quot;..&quot;)import d2lzh_pytorch as d2ldevice = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else&#x27;cpu&#x27;)def batch_norm(is_training, X, gamma, beta, moving_mean,               moving_var, eps, momentum):    # 判断当前模式是训练模式还是预测模式    if not is_training:        # 如果是预测模式，直接使用传入的移动平均所得的均值和方差        X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps)    else:        assert len(X.shape) in (2, 4)        if len(X.shape) == 2:            # 使用全连接层的情况，计算特征维上的均值和方差            mean = X.mean(dim=0)            var = ((X - mean) ** 2).mean(dim=0)        else:            # 使用二维卷积的情况，计算通道维上（axis=1）的均值和方差            # 这里需要保持X的形状以便后面可以做广播运算            mean = X.mean(dim=0, keepdim=True).mean(                dim=2, keepdim=True).mean(dim=3, keepdim=True)            var = ((X - mean) ** 2).mean(dim=0,                keepdim=True).mean(dim=2, keepdim=True).mean(dim=3, keepdim=True)        # 训练模式下⽤当前的均值和⽅差做标准化        X_hat = (X - mean) / torch.sqrt(var + eps)        # 更新移动平均的均值和⽅差        moving_mean = momentum * moving_mean + (1.0 - momentum) * mean        moving_var = momentum * moving_var + (1.0 - momentum) * var    Y = gamma * X_hat + beta # 拉伸和偏移    return Y, moving_mean, moving_var\n\n接下来，我们⾃定义⼀个 BatchNorm 层。它保存参与求梯度和迭代的拉伸参数 gama 和偏移参 数 beta ，同时也维护移动平均得到的均值和⽅差，以便能够在模型预测时被使⽤。 BatchNorm 实例 所需指定的 num_features 参数对于全连接层来说应为输出个数，对于卷积层来说则为输出通道数。该 实例所需指定的 num_dims 参数对于全连接层和卷积层来说分别为 2 和 4。\nclass BatchNorm(nn.Module):    def __init__(self, num_features, num_dims):        super(BatchNorm, self).__init__()        if num_dims == 2:            shape = (1, num_features)        else:            shape = (1, num_features, 1, 1)        # 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0        self.gamma = nn.Parameter(torch.ones(shape))        self.beta = nn.Parameter(torch.zeros(shape))        # 不参与求梯度和迭代的变量，全在内存上初始化为0        self.moving_mean = torch.zeros(shape)        self.moving_var = torch.zeros(shape)            def forward(self, X):        # 如果X不在内存上，将moving_mean和moving_var复制到显存上        if self.moving_mean.device != X.device:            self.moving_mean = self.moving_mean.to(X.device)            self.moving_var = self.moving_var.to(X.device)        # 保存更新过的moving_mean和moving_var，Module实例的training属性默认为True        # 调用.eval()后设为false        Y, self.moving_mean, self.moving_var = batch_norm(self.training, X, self.gamma, self.beta,                                                          self.moving_mean, self.moving_var,                                                          eps=1e-5, momentum=0.9)        return Y\n\n\n\n5.3.2  残差块是否存在一种方法，让我们加深网络层后可以只降低训练误差而不影响其他？\n是存在的，我们需要新添加的网络层能够实现恒等映射$f(x) = x$，即$f(x) - x = 0$。如何实现呢？让我们聚焦于神经网络局部，设输入为 x，恒等映射为 f(x)。右图虚线框中的部分用以拟合**恒等映射的残差映射$f(x) - x$**，残差映射往往更容易优化，我们只需要将右图虚线框内上方的加权运算（如仿射）的权重和偏差参数学成 0，那么 f(x) 即为恒等映射。实际上，当我们求得的 f(x) 及其接近恒等映射时，残差映射也易于捕捉恒等映射的细微波动。\n右图就是 ResNet 的基础块，也叫残差块。在残差块中，输入可通过跨层的数据线路更快地向前方传播。\n\n残差块中首先有 2 个相同输出通道数的 3 * 3 卷积层，每个卷积层后接一个批量归一化层和 ReLU 激活函数。然后我们将输入跳过这两个卷积运算后直接加在最后的 ReLU 激活函数钱。这样的设计要求两个卷积层的输入和输出形状一致，从而可以相加。\nimport timeimport torchfrom torch import nn, optimimport torch.nn.functional as Fimport syssys.path.append(&quot;..&quot;)import d2lzh_pytorch as d2ldevice = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else&#x27;cpu&#x27;)class Residual(nn.Module):    def __init__(self, in_ch, out_ch, use_lx1conv=False, stride=1):        super(Residual, self).__init__()        self.conv1 = nn.Conv2d(in_ch, out_ch, kernel_size=3,                             padding=1, stride=stride)        self.conv2 = nn.Conv2d(out_ch, out_ch, kernel_size=3,                             padding=1)        if use_1x1conv:            self.conv3 = nn.Conv2d(in_ch, out_ch, kernel_size=1,                             padding=1, stride=stride)        else:            self.conv3= None        self.bn1 = nn.BatchNorm2d(out_ch)        self.bn2 = nn.BatchNorm2d(out_ch)            def forward(self, X):        Y = F.relu(self.bn1(self.conv1(X)))        Y = self.bn2(self.conv2(Y))        if self.conv3:            X = self.conv3(X)        return F.relu(Y + X)\n\n\n\n5.4 UNet接下来介绍一种十分适用于医学影像分割的网络，UNet。\n首先来说明一下医学影像的特点，为什么UNet比较适合医学影像分割：\n\n医学影像语义比较简单，结构固定。但是也因此，无论是其低级特征还是高级语义特征都十分重要，所以U型结构的 skip connection 结构（特征拼接）更好派上用场。\n医学影像数量比较少，获取难度大，大型网络比较容易过拟合。UNet 这样比较小的网络会比较合适。事实上，有人发现在小数量级中，分割的SOTA模型与轻量级的 UNet 相比并没有什么优势。\n医学影像往往是多模态的。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的Unet可以有更大的操作空间。（有很多变种网络）\n\n接下来讲解一下 UNet 网络结构特点。网如其名，它是一种 U 型的网络，可以获取上下文的信息和位置信息。\n\n\n这个网络大致分为两部分，左边是特征提取网络，右边是特征融合网络。\n将经过高分辨率—编码—低分辨率—解码—高分辨率的过程。\n在特征提取网络中，由两个 3 x 3 的卷积层（ReLU）再加上一个 2 x 2 的 max pooling 层组成一个下采样的模块，一共经过4次这样的操作。而在后面的特征融合网络中，由一层反卷积 + 特征拼接 concat + 两个 3 x 3 的卷积层（ReLU）反复构成，一共经过4次这样的操作，与特征提取网络刚好相对应，最后接一层 1 * 1 卷积，降维处理，即将通道数降低至特定的数量，得到目标图。\nUNet的好处：通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的找回。\n代码实现：\nimport torch.nn as nnimport torch# 构造左边特征提取基础模块class conv_block(nn.Module):    def __init__(self, in_ch, out_ch):        super(conv_block, self).__init__()                self.conv = nn.Sequential(            nn.Conv2d(in_ch, out_ch, kernel_size=3,                      stride=1, padding=1, bias=True),            # 卷积神经网络的卷积层之后总会添加批量归一化操作，            # 防止数据在ReLU之前不会因为过大而导致网络性能不稳定            nn.BatchNorm2d(out_ch),            nn.ReLU(inplace=True),            nn.Conv2d(out_ch, out_ch, kernel_size=3,                      stride=1, padding=1, bias=True),            nn.BatchNorm2d(out_ch),            nn.ReLU(inplace=True)        )            def forward(self, x):        x = self.conv(x)        return x    # 构造右边特征融合基础模块class up_conv(nn.Module):    def __init__(self, in_ch, out_ch):        super(up_conv, self).__init__()        self.up = nn.Sequential(            nn.Upsample(scale_factor=2),            nn.Conv2d(in_ch, out_ch, kernel_size=3,                      stride=1, padding=1, bias=True),            nn.BatchNorm2d(out_ch),            nn.ReLU(inplace=True)        )            def forward(self, x):        x = self.up(x)        return x    # 构造UNet主框架class UNet(nn.Module):    def __init__(self, in_ch=3, out_ch=2):        super(UNet, self).__init__()                # 卷积参数设置        n1 = 64        filters = [n1, n1 * 2, n1 * 4, n1 * 8, n1 * 16]                # 最大池化层        self.Maxpool1 = nn.MaxPool2d(kernel_size=2, stride=2)        self.Maxpool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.Maxpool3 = nn.MaxPool2d(kernel_size=2, stride=2)        self.Maxpool4 = nn.MaxPool2d(kernel_size=2, stride=2)                # 左边特征提取卷积层        self.Conv1 = conv_block(in_ch, filters[0])        self.Conv2 = conv_block(filters[0], filters[1])        self.Conv3 = conv_block(filters[1], filters[2])        self.Conv4 = conv_block(filters[2], filters[3])        self.Conv5 = conv_block(filters[3], filters[4])                # 右边特征融合反卷积层        self.Up5 = up_conv(filters[4], filters[3])        self.Up_conv5 = conv_block(filters[4], filters[3])        self.Up4 = up_conv(filters[3], filters[2])        self.Up_conv4 = conv_block(filters[3], filters[2])        self.Up3 = up_conv(filters[2], filters[1])        self.Up_conv3 = conv_block(filters[2], filters[1])        self.Up2 = up_conv(filters[1], filters[0])        self.Up_conv2 = conv_block(filters[1], filters[0])        self.Conv = nn.Conv2d(filters[0], out_ch, kernel_size=1,                              stride=1, padding=0)        # 前向计算，输出一张与原图相同尺寸的图片矩阵    def forward(self, x):        e1 = self.Conv1(x)                e2 = self.Maxpool1(e1)        e2 = self.Conv2(e2)                e3 - self.Maxpool2(e2)        e3 = self.Conv3(e3)                e4 = self.Maxpool3(e3)        e4 = self.Conv4(e4)                e5 = self.Maxpool4(e4)        e5 = self.Conv5(e5)                # 过第一个上采样时降低了通道数        d5 = self.Up5(e5)                # 将e4特征图和d5特征图横向拼接        d5 = torch.cat((e4, d5), dim=1)                d5 = self.Up_conv5(d5)                d4 = self.Up4(d5)        d4 = torch.cat((e3, d4), dim=1)        d4 = self.Up_conv(d4)                d3 = self.Up3(d4)        d3 = torch.cat((e2, d3), dim=1)  # 将e2特征图与d3特征图横向拼接        d3 = self.Up_conv3(d3)        d2 = self.Up2(d3)        d2 = torch.cat((e1, d2), dim=1)  # 将e1特征图与d1特征图横向拼接        d2 = self.Up_conv2(d2)        out = self.Conv(d2)                return out\n\n\n\n参考博客：\n\n图像分割必备知识点 | Unet详解 理论+ 代码 - 忽逢桃林 - 博客园 (cnblogs.com)\nunet模型及代码解析_静待缘起的博客-CSDN博客_unet模型代码\n\n5.5 VNetVNet 是 UNet 的一种改进网络，其构建与 UNet 高度一致。最大的特点就是可以高效地处理三维影像。\n下面是 VNet 的网络结构图，它保留了 UNet 进行特征图的拼接增大感受野。除了将主要处理对象修改成为了三维影像之外，其最大的改进就是在每一个下采样之后，VNet 采用了 ResNet 的短路连接方式(灰色路线)。相当于在 UNet 中引入残差块。这是 VNet 最大的改进之处。源论文指出这种改进有助于 VNet 训练过程的收敛。\n\n\nVNet 实现如下：\nimport torchfrom torch import nnimport torch.nn.functional as Fclass ConvBlock(nn.Module):    def __init__(self, n_stages, n_filters_in, n_filters_out, normalization=&#x27;none&#x27;):        super(ConvBlock, self).__init__()        ops = []        for i in range(n_stages):            if i==0:                input_channel = n_filters_in            else:                input_channel = n_filters_out            ops.append(nn.Conv3d(input_channel, n_filters_out, 3, padding=1))            if normalization == &#x27;batchnorm&#x27;:                ops.append(nn.BatchNorm3d(n_filters_out))            elif normalization == &#x27;groupnorm&#x27;:                ops.append(nn.GroupNorm(num_groups=16, num_channels=n_filters_out))            elif normalization == &#x27;instancenorm&#x27;:                ops.append(nn.InstanceNorm3d(n_filters_out))            elif normalization != &#x27;none&#x27;:                assert False            ops.append(nn.ReLU(inplace=True))        self.conv = nn.Sequential(*ops)    def forward(self, x):        x = self.conv(x)        return xclass ResidualConvBlock(nn.Module):    def __init__(self, n_stages, n_filters_in, n_filters_out, normalization=&#x27;none&#x27;):        super(ResidualConvBlock, self).__init__()        ops = []        for i in range(n_stages):            if i == 0:                input_channel = n_filters_in            else:                input_channel = n_filters_out            ops.append(nn.Conv3d(input_channel, n_filters_out, 3, padding=1))            if normalization == &#x27;batchnorm&#x27;:                ops.append(nn.BatchNorm3d(n_filters_out))            elif normalization == &#x27;groupnorm&#x27;:                ops.append(nn.GroupNorm(num_groups=16, num_channels=n_filters_out))            elif normalization == &#x27;instancenorm&#x27;:                ops.append(nn.InstanceNorm3d(n_filters_out))            elif normalization != &#x27;none&#x27;:                assert False            if i != n_stages-1:                ops.append(nn.ReLU(inplace=True))        self.conv = nn.Sequential(*ops)        self.relu = nn.ReLU(inplace=True)    def forward(self, x):        x = (self.conv(x) + x)        x = self.relu(x)        return xclass DownsamplingConvBlock(nn.Module):    def __init__(self, n_filters_in, n_filters_out, stride=2, normalization=&#x27;none&#x27;):        super(DownsamplingConvBlock, self).__init__()        ops = []        if normalization != &#x27;none&#x27;:            ops.append(nn.Conv3d(n_filters_in, n_filters_out, stride, padding=0, stride=stride))            if normalization == &#x27;batchnorm&#x27;:                ops.append(nn.BatchNorm3d(n_filters_out))            elif normalization == &#x27;groupnorm&#x27;:                ops.append(nn.GroupNorm(num_groups=16, num_channels=n_filters_out))            elif normalization == &#x27;instancenorm&#x27;:                ops.append(nn.InstanceNorm3d(n_filters_out))            else:                assert False        else:            ops.append(nn.Conv3d(n_filters_in, n_filters_out, stride, padding=0, stride=stride))        ops.append(nn.ReLU(inplace=True))        self.conv = nn.Sequential(*ops)    def forward(self, x):        x = self.conv(x)        return xclass UpsamplingDeconvBlock(nn.Module):    def __init__(self, n_filters_in, n_filters_out, stride=2, normalization=&#x27;none&#x27;):        super(UpsamplingDeconvBlock, self).__init__()        ops = []        if normalization != &#x27;none&#x27;:            ops.append(nn.ConvTranspose3d(n_filters_in, n_filters_out, stride, padding=0, stride=stride))            if normalization == &#x27;batchnorm&#x27;:                ops.append(nn.BatchNorm3d(n_filters_out))            elif normalization == &#x27;groupnorm&#x27;:                ops.append(nn.GroupNorm(num_groups=16, num_channels=n_filters_out))            elif normalization == &#x27;instancenorm&#x27;:                ops.append(nn.InstanceNorm3d(n_filters_out))            else:                assert False        else:            ops.append(nn.ConvTranspose3d(n_filters_in, n_filters_out, stride, padding=0, stride=stride))        ops.append(nn.ReLU(inplace=True))        self.conv = nn.Sequential(*ops)    def forward(self, x):        x = self.conv(x)        return xclass Upsampling(nn.Module):    def __init__(self, n_filters_in, n_filters_out, stride=2, normalization=&#x27;none&#x27;):        super(Upsampling, self).__init__()        ops = []        ops.append(nn.Upsample(scale_factor=stride, mode=&#x27;trilinear&#x27;,align_corners=False))        ops.append(nn.Conv3d(n_filters_in, n_filters_out, kernel_size=3, padding=1))        if normalization == &#x27;batchnorm&#x27;:            ops.append(nn.BatchNorm3d(n_filters_out))        elif normalization == &#x27;groupnorm&#x27;:            ops.append(nn.GroupNorm(num_groups=16, num_channels=n_filters_out))        elif normalization == &#x27;instancenorm&#x27;:            ops.append(nn.InstanceNorm3d(n_filters_out))        elif normalization != &#x27;none&#x27;:            assert False        ops.append(nn.ReLU(inplace=True))        self.conv = nn.Sequential(*ops)    def forward(self, x):        x = self.conv(x)        return xclass VNet(nn.Module):    def __init__(self, n_channels=3, n_classes=2, n_filters=16, normalization=&#x27;none&#x27;, has_dropout=False):        super(VNet, self).__init__()        self.has_dropout = has_dropout        self.block_one = ConvBlock(1, n_channels, n_filters, normalization=normalization)        self.block_one_dw = DownsamplingConvBlock(n_filters, 2 * n_filters, normalization=normalization)        self.block_two = ConvBlock(2, n_filters * 2, n_filters * 2, normalization=normalization)        self.block_two_dw = DownsamplingConvBlock(n_filters * 2, n_filters * 4, normalization=normalization)        self.block_three = ConvBlock(3, n_filters * 4, n_filters * 4, normalization=normalization)        self.block_three_dw = DownsamplingConvBlock(n_filters * 4, n_filters * 8, normalization=normalization)        self.block_four = ConvBlock(3, n_filters * 8, n_filters * 8, normalization=normalization)        self.block_four_dw = DownsamplingConvBlock(n_filters * 8, n_filters * 16, normalization=normalization)        self.block_five = ConvBlock(3, n_filters * 16, n_filters * 16, normalization=normalization)        self.block_five_up = UpsamplingDeconvBlock(n_filters * 16, n_filters * 8, normalization=normalization)        self.block_six = ConvBlock(3, n_filters * 8, n_filters * 8, normalization=normalization)        self.block_six_up = UpsamplingDeconvBlock(n_filters * 8, n_filters * 4, normalization=normalization)        self.block_seven = ConvBlock(3, n_filters * 4, n_filters * 4, normalization=normalization)        self.block_seven_up = UpsamplingDeconvBlock(n_filters * 4, n_filters * 2, normalization=normalization)        self.block_eight = ConvBlock(2, n_filters * 2, n_filters * 2, normalization=normalization)        self.block_eight_up = UpsamplingDeconvBlock(n_filters * 2, n_filters, normalization=normalization)        self.block_nine = ConvBlock(1, n_filters, n_filters, normalization=normalization)        self.out_conv = nn.Conv3d(n_filters, n_classes, 1, padding=0)        # droppout rate = 0.5 用了两个dropout        self.dropout = nn.Dropout3d(p=0.5, inplace=False)        # self.__init_weight()    def encoder(self, input):        x1 = self.block_one(input)        x1_dw = self.block_one_dw(x1)        x2 = self.block_two(x1_dw)        x2_dw = self.block_two_dw(x2)        x3 = self.block_three(x2_dw)        x3_dw = self.block_three_dw(x3)        x4 = self.block_four(x3_dw)        x4_dw = self.block_four_dw(x4)        x5 = self.block_five(x4_dw)        # x5 = F.dropout3d(x5, p=0.5, training=True)        if self.has_dropout:            x5 = self.dropout(x5)        res = [x1, x2, x3, x4, x5]        return res    def decoder(self, features):        x1 = features[0]        x2 = features[1]        x3 = features[2]        x4 = features[3]        x5 = features[4]        x5_up = self.block_five_up(x5)        x5_up = x5_up + x4        x6 = self.block_six(x5_up)        x6_up = self.block_six_up(x6)        x6_up = x6_up + x3        x7 = self.block_seven(x6_up)        x7_up = self.block_seven_up(x7)        x7_up = x7_up + x2        x8 = self.block_eight(x7_up)        x8_up = self.block_eight_up(x8)        x8_up = x8_up + x1        x9 = self.block_nine(x8_up)        # x9 = F.dropout3d(x9, p=0.5, training=True)        if self.has_dropout:            x9 = self.dropout(x9)        out = self.out_conv(x9)        return out    def forward(self, input, turnoff_drop=False):        if turnoff_drop:            has_dropout = self.has_dropout            self.has_dropout = False        features = self.encoder(input)        out = self.decoder(features)        if turnoff_drop:            self.has_dropout = has_dropout        return out\n\n\n\n参考博客：\n\nUNet 、3D-UNet 、VNet 区别_阿里云小仙女的博客-CSDN博客_3d unet\n\n","categories":["深度学习"],"tags":["深度学习","CNN","医学图像分割"]},{"title":"算法笔记学习记录","url":"/2021/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"排序插入排序插入排序的思想是从第一个数开始逐渐扩大已排序序列，具体实现是将某个数与已排序序列中的数比较，决定其在排好序的序列中位置。\nfor (int i = 1; i &lt; n; i++) {    for (int j = i - 1; j &gt;= 0 &amp;&amp; a[j] &gt; a[j+1]; j—-) {        swap(a[j], a[j+1]);    }    // ...}\n冒泡排序冒泡排序的思想是相邻两个之间比较然后交换，一轮下来可以确定最后一个数的位置（注意不论是递增还是递减，都是先确定最后一个数），然后依次向前敲定。\nfor (int i = 0; i &lt; n; i++) {    for (int j = 0; j &lt; n - i; j++) {        if (a[j] &gt; a[j+1]) {            swap(a[j], a[j+1]);        }    }}\n\n递归\n要理解递归，首先你要理解递归，直到你能理解递归（笑）。\n\n全排列输入一个整数n，给出1～n这n个整数的全排列，要求按照字典序从小到大排列。\n#include &lt;iostream&gt;using namespace std;const int maxn = 11;int n, p[maxn];bool hashTable[maxn] = {false};void generateP(int index) {    if(index &gt; n) {        for(int i = 1; i &lt;= n; i++) {            printf(\"%d\", p[i]);        }        printf(\"\\n\");        return;    }    for(int i = 1; i &lt;= n; i++) {        if(hashTable[i] == false) {            hashTable[i] = true;            p[index] = i;            generateP(index + 1);            hashTable[i] = false;        }    }}int main() {    n = 3;    generateP(1);        return 0;}\n不可以将代码中的generateP(index + 1)改成index++ + generateP(index)，因为index表示下标，当没有深入到下一层递归时，index不应该改变。\nN皇后（回溯法)N皇后基础算法在全排列的基础上进行改进，可看作不在对角线上的全排列。回溯法更优的地方在于：在放置了一部分皇后之后，可判断剩下的皇后是否有必要放下去，当无论怎么放都会冲突时则没必要递归，直接返回上层即可。\n#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 1010;int p[MAXN], n, count = 0; //p为暂时储存序列的数组，n为最大值bool hashTable[MAXN] = {false};void nQueen(int index) {    if (index == n + 1) {        count++;    //当能够进入这里，说明一定是合法序列        return;    }    for (int i = 1; i &lt;= n; i++) {        if (hashTable[i] == false) {            bool flag = true;            for (int pre = 1; pre &lt; index; pre++) {                if (abs(index - pre) == abs(i - p[pre])) {                    flag = false;                    break;                }            }            if (flag) {                hashTable[i] = true;                p[index] = i;                nQueen(index + 1);                hashTable[i] = false;            }        }    }}int main() {    scanf(\"%d\", &amp;n);    nQueen(1);    printf(\"%d\", count);    return 0;}\n\n贪心简单贪心没有固定的写法，视题目而定，下面给出区间贪心的做法\n区间贪心\n给出n个区间(x, y)，从中选择尽可能多的开区间，使得这些开区间两两没有交集，求出最大的开区间数。\n\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 10;  //表示最大区间数struct Interval {    int x, y;} I[MAXN];bool cmp(Interval a, Interval b) {    if (a.x != b.x) return a.x &gt; b.x;    else return a.y &lt; b.y;}int main() {    int n;  //区间数    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(\"%d%d\", &amp;I[i].x, &amp;I[i].y);    }    sort(I, I + n, cmp);    int ans = 1, lastx = I[0].x;    //表示最多能选ans个区间    for (int i = 1; i &lt; n; i++) {        if (I[i].y &lt;= lastx) {            lastx = I[i].x;            ans++;        }    }    printf(\"%d\", ans);    return 0;}\n当题目改为区间选点问题时，即给出n个闭区间[x, y]，求最少需要多少个点，才能使每个闭区间中都至少存在一个点。只需要将I[i].y &lt;= lastx改成I[i].y &lt; lastx即可。\n二分二分模板\n寻找有序序列中第一个满足某条件的元素的位置的代码模板。\n\n// 二分区间左闭右闭，初值必须能覆盖解的所有可能取值int solve(int left, int right, int x) {    int mid = (left + right) / 2;    while(left &lt; right) {        if(条件成立) {            right = mid;        } else {            left = mid + 1;        }    }    return left;}\n\n当左开右闭时，代码修改如下：\n// 二分区间左开右闭，初值必须能覆盖解的所有可能取值int solve(int left, int right, int x) {    int mid = (left + right) / 2;    while(left + 1 &lt; right) {        if(条件成立) {            right = mid;        } else {            left = mid;        }    }    return right;}\n\n二分法求√2的近似值const double eps = 1e-5;    // 表示精度double f(double x) {    return x * x;}double calSqrt() {    double left = 1, right = 2, mid;    while(left &lt; right) {        mid = (left + right) / 2;        if(right - left &lt; eps) return mid;        if(f(mid) &gt; 2) {            right = mid;        } else {            left = mid;        }    }    return mid;}\n\n双指针归并排序（递归实现）const int maxn = 100;// 此处l2为r1 + 1void merge(int a[], int l1, int r1, int l2, int r2) {    int i = l1, j = l2;     // 双指针指向待合并数组最左端    int temp[maxn], index = 0;    while (i &lt;= r1 &amp;&amp; j &lt;= r2) {        if (a[i] &lt;= a[j] {            temp[index++] = a[i++];        } else {            temp[index++] = a[j++];        }    }    while (i &lt;= r1) temp[index++] = a[i++]; // 将剩余元素加入序列    while (j &lt;= r2) temp[index++] = a[j++];    for (int x = 0; x &lt; index; x++) {        a[l1+x] = temp[x];  // 将合并后的序列赋值回数组a    }}// 将array数组当前[left, right]进行归并排序void mergeSort(int a[], int left, int right) {    if (left &lt; right) {        int mid = (left + right) / 2;   // 取中点        mergeSort(a[], left, mid);        mergeSort(a[], mid + 1, right);        merge(a[], left, mid, mid + 1, right);  // 将左子区间和右子区间合并    }}\n\n快速排序（递归实现）int Partition(int a[], int left, int right) {    int temp = a[left];    while (left &lt; right) {      // 只要left和right不相遇        while (left &lt; right &amp;&amp; a[right] &gt; temp) right—-;        a[left] = a[right];        while (left &lt; right &amp;&amp; a[left] &lt;= temp) left++;        a[right] = a[left];    }    a[left] = temp;    return left;    // 返回相遇时的下标}void quickSort(int a[], int left, int right) {    if (left &lt; right) {        int pos = Partition(a[], left, right);  // 此时已确定一个数位置        quickSort(a[], left, pos - 1);  // 对左子区间进行快排        quickSort(a[], pos + 1, right); // 对右子区间进行快排    }}\n\n栈 &amp; 队列简易计算器\n读入一个只包含+，-，*，/的非负整数计算表达式，计算该表达式的值。\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;struct node {    int num;    char op;    bool flag;};string str;stack&lt;node&gt; s;queue&lt;node&gt; q;map&lt;char, int&gt; op;void Change() {    node temp;    for (int i = 0; i &lt; str.length();) {        if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {            temp.flag = true;            temp.num = str[i++] - '0';            while (i &lt; str.length() &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {                temp.num = temp.num * 10 + (str[i++] - '0');            }            q.push(temp);        } else {            temp.flag = false;            while (!s.empty() &amp;&amp; op[str[i]] &lt;= op[s.top().op]) {                q.push(s.top());                s.pop();            }            temp.op = str[i++];            q.push(temp);        }    }    while (!s.empty()) {        q.push(s.top());        s.pop();    }}double Cal() {    double first, second;    node cur, temp;    stack&lt;int&gt; st;    while (!q.empty()) {        cur = q.front();        q.pop();        if (cur.flag == true) st.push(cur.num);        else {            second = st.top();            st.pop();            first = st.top();            st.pop();            temp.flag = true;            if (cur.op == '+') temp.num = first + second;            else if (cur.op == '-') temp.num = first - second;            else if (cur.op == '*') temp.num = first * second;            else temp.num = first / second;            s.push(temp);        }    }    return s.top().num;}int main() {    op['+'] = op['-'] = 1;    op['*'] = op['/'] = 2;    getline(cin, str);    for (string::iterator it = str.end(); it != str.begin(); it++) {        if (*it == ' ') str.erase(it);    }    Change();    printf(\"%.2f\", Cal());        return 0;}\n\nDFS背包问题\n有n件物品，每件物品重量为w[i]，价值为c[i]。如果需要选出若干物品放入一个容量为v的背包中，问如何放才能在重量不超过v的基础上使得总价值最大。\n\n\n常规递归解法\n\n#include &lt;iostream&gt;using namespace std;const int maxn = 30;int n, v, maxValue = 0, w[maxn], c[maxn];void DFS(int index, int sumW, int sumC) {    if (index == n) {        if (sumW &lt;= v &amp;&amp; sumC &gt; maxValue) maxValue = sumC;        return;    }    DFS(index + 1, sumW, sumC);     // 不选该物品的分支    DFS(index + 1, sumW + w[index], sumC + c[index]);   // 选的分支}int main() {    scanf(“%d %d”, &amp;n, &amp;v);    for (int i = 0; i &lt; n; i++) scanf(“%d”, &amp;w[i]);    for (int i = 0; i &lt; n; i++) scanf(“%d”, &amp;c[i]);    DFS(0, 0, 0);   // 初始index，sumW和sumC都是0    printf(“%d”, maxValue);}\n\n剪枝改进\n\nvoid DFS(int index, int sumW, int sumC) {    if (index == n) return;    DFS(index + 1, sumW, sumC);    if (sumW + w[index] &lt;= v) {        if (sumC + c[index] &gt; maxValue) maxValue = sumC + c[index];        DFS(index + 1, sumW + w[index], sumC + v[index]);    }}\n\n求子序列该一类问题描述给定一个序列，枚举这个序列的所有子序列（可以不连续），以下给出一个具体案例：\n\n给定n个整数（可能为负），从中选择k个数，使得这k个数之和恰好等一给定的一个整数x，如果有多种方案，则从其中选择平方和最大的一个。\n\n// maxSumSqu为最大平方和int n, k, x, maxSumSqu = -1, a[maxn];// temp存放临时方案，ans存放平方和最大的方案vector&lt;int&gt; temp, ans;void DFS(int index, int tempK, int sum, int sumSqu) {    if (tempK = k &amp;&amp; sum == x) {        if (sumSqu &gt; maxSumSqu) {            maxSumSqu = sumSqu;            ans = temp;        }        return;    }    if (tempK &gt; k || index == n || sum &gt; x) return;    temp.push_back(a[index]);    DFS(index + 1, tempK + 1, sum + a[index], sumSqu + a[index] * a[index]);    temp.pop_back();    DFS(index + 1, tempK, sum, sumSqu);}\n\nBFSBFS模版一般使用队列实现\nvoid BFS(int s) {    queue&lt;int&gt; q;    q.push(s);    while (!q.empty()) {        取出队首元素top;        访问队首元素top（例如print）;        将队首元素出队;        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;    }}\n\n迷宫找出口\n给定一个n * m大小的迷宫，其中*代表不可通过的墙壁，而“.”代表平地，s表示起点，t表示终点。移动过程中，如果当前位置时（x, y）（下标从0开始），且每次只能往上下左右移动，求从起点s到终点t的最少步数。\n\n#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;struct Node {    int x, y;    int step;   // 表示步长} s, t, node;int n, m;char maze[maxn][maxn];bool inq[maxn][maxn] = {false};int x[4] = {0, 0, 1, -1};int y[4] = {1, -1, 0, 0};// 检测位置是否有效bool test(int x, int y) {    if (x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0) return false;    if (maze[x][y] == ‘*’) return false;    if (inq[x][y] == true) return false;    return true;}int BFS() {    queue&lt;Node&gt; q;    q.push(s);    while (!q.empty()) {        Node top = q.front();        q.pop();        if (top.x = t.x &amp;&amp; top.y == t.y) return top.step;        for (int i = 0; i &lt; 4; i++) {            int newx = top.x + x[i];            int newy = top.y + y[i];            if (test(newx, newy)) {                node.x = newx;                node.y = newy;                node.step = top.step + 1;                q.push(node);                inq[newx][newy] = true;            }        }        return -1;    }}int main() {    scanf(“%d%d”, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        getchar();        for (int j = 0; j &lt; m; j++) {            maze[x][y] = getchar();        }        maze[x][m+1] = ‘\\0’;    }    scanf(“%d%d%d%d”, &amp;s.x, &amp;s.y, &amp;t.x, &amp;t.y);    s.step = 0;    printf(“%d”, BFS());        return 0;}\n\n树与二叉树二叉树的储存和操作二叉树的储存结构\n通常采用二叉链表来储存二叉树，二叉链表有以下好处：\n\n结构体中存放指针，占用空间小\n删除方便，只需要将指针置空就行\n可以实时控制新生成结点的个数\n\n\nstruct node {    typename data;    node* left;    node* right;};node* newNode(int v) {    node* node = new node;    node-&gt;data = v;    node-&gt;left = node-&gt;right = NULL;    return node;}\n\n二叉树结点的查找、修改void search(node* root, int x, int newdata) {    if (root == NULL) return;    if (root-&gt;data == x) root-&gt;data = newdata;    search(root-&gt;left, x, newdata);    search(root-&gt;right, x, newdata); }\n二叉树结点的插入// insert函数将在二叉树中插入一个数据域为x的新结点（参数root要加引用）void insert(node* &amp;root, int x) {    if (root == NULL) {     // 空树，说明查找失败，也即插入位置        root = newNode(x);  //根root也已修改，因为传了引用        return;    }    if (root-&gt;data == x) return;    // 说明已经存在    else if (x &lt; root-&gt;data) insert(root-&gt;left, x);    else insert(root-&gt;right, x);}\n\n二叉树的建立node* create(int data[], int n) {    node* root = NULL;    for (int i = 0; i &lt; n; i++) {        insert(root, data[i]);    }    return root;}\n\n二叉树的遍历二叉树先序遍历// 定义二叉树节点的结构体struct Node {    Node left;    int data;    Node right;};// 先序遍历函数void PreOrder(Node a) {    if(a) {        printf(“%d”, a.data);        PreOrder(a.left);        PreOrder(a.right);    }}\n中序和后序遍历只需要调换printf语句和递归的顺序即可\n二叉树先序&amp;中序遍历（栈）中序实现void InOrder(Node a) {    Node b = a;    stack&lt;Node&gt; s;    while (b || !empty(s)) {        while (b) {            s.push(b);            b = b.left;        }        if (!empty(s)) {            b = s.top();            printf(“%d”, b.data);            s.pop();            b = b.right;        }    }}\n前序实现将printf语句放在s.push(b)这一句之前即可，表示第一次遇见这个结点就打印\n二叉树层序遍历（队）void LayerOrder(Node a) {    queue&lt;Node&gt; q;    Node b = a;    if (!b) return;  // 如果结点空了则返回    q.push(b);    if (!empty(q)) {        printf(“%d”, b.data);        if (b.left) q.push(b.left);        if (b.right) q.push(b.right);    }}\n\n重建二叉树给出先序序列和中序序列，要求重建这棵二叉树。\nnode* create(int preL, int preR, int inL, int inR) {    if (preL &gt; preR) return NULL;    int k;    node* root = new node;    root-&gt;data = pre[preL];    for (k = 0; k &lt; inR; k++) {        if (pre[preL] == in[k]) break;    }    int numLeft = k - inL;  // 注意是减中序的左结点    root-&gt;left = create(preL + 1, pre + numLeft, inL, k - 1);    root-&gt;right = create(pre + numLeft + 1, preR, k + 1, inR);    return root;}\n\n树的遍历树的静态写法struct node {    int data;    vector&lt;int&gt; child;  // 动态数组防止子结点过多空间超限} Node[maxn];\n树的先根遍历void PreOrder(int root) {    printf(“%d”, &amp;Node[root].data);    for (int i = 0; i &lt; Node[root].child.size(); i++) {        PreOrder(Node[root].child[i]);    }}\n后根遍历只需要将printf语句下放即可。\n树的层序遍历（记录层号）struct node {    int data;    int layer;  // 记录层号    vector&lt;int&gt; child;} Node[maxn];void LayerOrder(int root) {    queue&lt;node&gt; q;    Node[root].layer = 0;    q.push(Node[root]);    while (!q.empty()) {        int front = q.front();        q.pop();        printf(“%d”, Node[front].data);        for (int i = 0; i &lt; Node[front].child.size(); i++) {            int child = Node[front].child[i];            child.layer = Node[front].layer + 1;            q.push(child);        }    }}\n\n二叉查找树（BST）\n\n要么二叉查找树是一棵空树。\n要么二叉查找树由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有的结点数据域均大于根结点的数据域（其中可以得到一个规律：二叉查找树的中序遍历必然是非递减序列）。\n\n\n查找操作// search函数查找二叉查找树中数据域为x的结点void search(node* root, int x) {    if (root == NULL) {        printf(“search failed”);        return;    }    if (x == root-&gt;data) {        printf(“%d”, root-&gt;data);    } else if (x &lt; root-&gt;data) {        search(root-&gt;left, x);    } else {        search(root-&gt;right, x);    }}\n插入操作// insert函数将在二叉树中插入一个数据域为x的新结点（参数root要加引用）void insert(node* &amp;root, int x) {    if (root == NULL) {     // 空树，说明查找失败，也即插入位置        root = newNode(x);        return;    }    if (root-&gt;data == x) return;    // 说明已经存在    else if (x &lt; root-&gt;data) insert(root-&gt;left, x);    else insert(root-&gt;right, x);}\n二叉查找树的建立node* create(int data[], int n) {    node* root = NULL;    for (int i = 0; i &lt; n; i++) {        insert(root, data[i]);    }    return root;}\n删除操作// 寻找以root为根结点的树中的最大权值结点node* findMax(node* root) {    while (root-&gt;right != NULL) {        root = root-&gt;right;    }    return root;}// 寻找以root为根结点的树中的最小权值结点node* findMin(node* root) {    while (root-&gt;left != NULL) {        root = root-&gt;left;    }    return root;}// 删除以root为根结点的树中权值为x的结点void delete(node* &amp;root, int x) {    if (root == NULL) return;    if (root-&gt;data == x) {        if (root-&gt;right == NULL &amp;&amp; root-&gt;left == NULL) {            root = NULL;    // 如果是叶子结点直接置空        } else if (root-&gt;left != NULL) {            node* pre = findMax(root-&gt;left);            root-&gt;data = pre-&gt;data;            delete(root-&gt;left, pre-&gt;data);        } else if (root-&gt;right != NULL) {            node* next = findMin(root-&gt;right);            root-&gt;data = next-&gt;data;            delete(root-&gt;right, next-&gt;data);        }    } else if (root-&gt;data &gt; x) {        delete(root-&gt;left, x);    } else {        delete(root-&gt;right, x);    }}\n\n并查集并查集模版int father[N];//初始化并查集void init() {    for (int i = 1; i &lt;= N; i++) {        father[i] = i;    }}//查找根结点操作int findFather(int x) {    int a = x;  //a会被根结点替换掉，先储存    while (x != father[x]) {        x = father[x];    }    while (a != father[a]) {        int z = a;  //a会被father[a]替换掉，先储存        a = father[a];        father[z] = x;    }    return x;}//合并两个集合void union(int a, int b) {    int fa = findFather(a);    int fb = findFather(b);    if (fa != fb) {        father[fa] = fb;    }}\n\n好朋友（练习题）\n有一个数码宝贝的世界，不同的数码宝贝可能是好朋友，数码宝贝的好朋友关系存在交换律和传递律，现在输入一组数码宝贝的编号和它们之间的关系，问能将这些数码宝贝最多分为多少组。\n\n解题思路：将题目中的组视为集合，可以对在输入时对这些数码宝贝进行合并操作，最后得到的组数就是答案。关于如何获取组数，可以建立一个bool数组flag[n]来判断每个元素是否时某个集合的根结点。最后遍历该数组为true时累加即可。\n#include &lt;iostream&gt;using namespace std;const int N = 110;int father[N];bool flag[N];int findFather(int x) {    int a = x;    while (x != father[x]) x = father[x];    // 缩短路径    while (a != father[a]) {        int z = a;        a = father[a];        father[z] = x;    }    return x;}void Union(int a, int b) {    int faA = findFather(a);    int faB = findFather(b);    if (faA != faB) father[faA] = faB;}void init(int n) {    for (int i = 1; i &lt;= n; i++) {        father[i] = i;        flag[i] = false;    }}int main() {    int n, m, a, b, cnt = 0;    scanf(\"%d%d\", &amp;n, &amp;m);    init(n);    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;a, &amp;b);        Union(a, b);    }    for (int i = 1; i &lt;= n; i++) {        flag[findFather(i)] = true;    }    for (int i = 1; i &lt;= n; i++) {        if (flag[i] == true) cnt++;    }    printf(\"%d\", cnt);}\n\n堆大顶堆向下调整// 对heap数组在[low, high]范围进行向下调整// 其中low为欲调整结点的数组下标，而high为堆的最后一个元素void downAdjust(int low, int high) {    int i = low, j = low * 2;    while (j &lt;= high) {        if (j + 1 &lt;= high &amp;&amp; heap[j+1] &gt;= heap[j]) j = j + 1;        if (heap[j] &gt; heap[i]) {            swap(heap[i], heap[j]);            i = j;            j = i * 2;        } else break;    } }// 有了上面的函数，就可以很简便的建堆了void createHeap() {    for (int i = n / 2; i &gt;= 1; i—-) {        downHeap(i, n);    }}// 还有删除堆顶void deleteTop() {    heap[1] = heap[n—-];    downHeap(1, n);}\n大顶堆向上调整// 对heap数组在[low, high]范围进行向上调整// 其中low一般设置为1，而high为欲调整的结点树组下标void upAdjust() {    int i = high, j = i / 2;    while (j &gt;= low) {        if (heap[j] &lt; heap[i]) {            swap(heap[i], heap[j]);            i = j;            j = i / 2;        } else break;    }}// 再此基础上就很容易实现添加元素的代码了void insert(int x) {    heap[++n] = x;    upAdjust(1, n);}\n\n图图的储存方法通常采用邻接矩阵和邻接表储存，邻接矩阵采用二维数组，下标表示端点，值表示权值；邻接表一般使用链表储存，也可以用动态数组vector，更易理解。\n邻接表struct Node {   // v是端点编号，w是权值    int v, w;    Node (int _v, _w) {     // 添加构造函数方便添加结点        v = _v;        w = _w;    }};vector&lt;Node&gt; adj[100];// 添加一条从1号到3号顶点的无向边，权值为4adj[1].push_back(Node(3,4));adj[3].push_back(Node(1,4));\n\n图的遍历序列DFS以下解法都是针对图的通解（不针对联通分量），如果确定图是联通分量或强联通分量，则只需依次DFS即可。\n邻接矩阵的DFS解法const int maxn = 1000;const int inf = 1000000000;int n, g[maxn][maxn];bool vis[maxn] = {false};void DFS(int v, int depth) {    vis[v] = true;    // 如果要对v进行一些操作，可以在这里进行    // 下面对所有从u出发能达到的分支顶点进行枚举    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false &amp;&amp; g[v][i] != inf) {            DFS(i, depth+1);        }    }}void DFSTrave() {    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false) {            DFS(i, 1);        }    }}\n邻接表写法const int maxn = 1000;int n;  // 表示端点数vector&lt;int&gt; adj[maxn];bool vis[maxn] = {false};void DFS(int v, int depth) {    vis[v] = true;    // 如果要对v进行一些操作，可以在这里进行    // 下面对所有从u出发能达到的分支顶点进行枚举    for (int i = 0; i &lt; adj[v].size(); i++) {        int u = adj[v][i];        if (vis[u] == false) {            DFS(u, depth+1);        }    }}void DFSTrave() {    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false) {            DFS(i, 1);        }    }}\nBFS邻接矩阵写法int n, g[maxn][maxn];   // n为顶点数，maxn为最大顶点数bool inq[maxn] = {false};void BFS(int u) {    queue&lt;int&gt; q;    q.push(u);    inq[u] = true;    while (!q.empty()) {        int u = q.front();        q.pop();        for (int v = 0; v &lt; n; v++) {            if (inq[v] == false &amp;&amp; g[u][v] != inf) {                            }        }    }}void BFSTravel() {    for (int i = 0; i &lt; n; i++) {        if (inq[i] == false) {            BFS(i);        }    }}\n邻接表写法vector&lt;int&gt; adj[maxn];int n;bool inq[maxn];void BFS(int u) {    inq[u] = true;    queue&lt;int&gt; q;    q.push(u);    while (!q.empty()) {        int u = q.front();        q.pop();        for (int v = 0; v &lt; adj[u].size(); v++) {            int v = adj[u][v];            if (inq[v] == false) {                q.push(v);                inq[v] = true;            }        }    }}void BFSTravel() {    for (int i = 0; i &lt; n; i++) {        if (inq[i] == false) {            BFS(i);        }    }}\n给定初始点输出层号struct node {    int v;    int layer;};vector&lt;node&gt; adj[maxn];void BFS(int s) {    queue&lt;node&gt; q;    node start;    start.v = s;    start.layer = 0;    q.push(start);    while (!q.empty()) {        node front = q.front();        q.pop();        int u = front.v;        for (int i = 0; i &lt; adj[u].size(); i++) {            node next = adj[u][i];            next.layer = front.layer + 1;            if (vis[next.v] == false) {                q.push(next);                vis[next.v] = true;            }        }    }}\n\n最短路径Dijkstra算法\n解决单源最短路径的一种算法。\n\n邻接矩阵写法const int inf = 1000000000;const int maxn = 1000;int g[maxn][maxn], n;   // g是图，n是顶点数bool vis[maxn] = {false};     // vis表示是否访问过int d[maxn];    // 表示起点到各点的最短路径长度void Dijkstra(int s) {    fill(d, d + maxn, inf);    d[s] = 0;   // 初始化    for (int i = 0; i &lt; n; i++) {   // 循环n次        int u = -1, min = inf;        for (int j = 0; j &lt; n; j++) {            if (d[j] &lt; min &amp;&amp; vis[j] == false) {                u = j;  // u是起点到当前未访问顶点中距离最小的点                min = d[j];            }        }        if (u == -1) return;    // 说明剩下的顶点和s不连通        vis[u] = true;        for (int v = 0; v &lt; n; v++) {            if (vis[v] == false &amp;&amp; g[u][v] + d[u] &lt; d[v] &amp;&amp;                 g[u][v] != inf) {                d[v] = d[u] + g[u][v];            }        }    }}\n邻接表写法struct Node {    int v, dis; // v为边的目标顶点，dis为边权};vector&lt;Node&gt; g[maxn]; // 存放图int d[maxn];    // 存放最短路径bool vis[maxn] = {false}; // 判定是否访问过void Dijkstra(int s) {    fill(d, d + maxn, 0);    d[s] = 0;   // 初始化    for (int i = 0; i &lt; n; i++) {        int u = -1, min = inf;          for (int j = 0; j &lt; n; j++) {            // 这个循环是拿到当前未访问点中距离最小的那个            if (vis[j] == false &amp;&amp; d[j] &lt; min) {                u = j;                min = d[j];            }        }        if (u == -1) return;        vis[u] = true;        for (int j = 0; j &lt; g[u].size(); j++) {            int v = g[u][j].v;            if (vis[v] == false &amp;&amp; g[u][j].dis + d[u] &lt; d[v]) {                d[v] = d[u] + g[u][j].dis;            }        }    }}\nDijkstra+DFS\n用于处理逻辑更为复杂的边权或者点权的计算（非和），比起Dijkstra更为通用而模版化\n\n\nDijkstra部分\n\nvector&lt;int&gt; pre[maxn];  // pre[v]表示v顶点的所有前驱void Dijkstra(int s) {    fill(d, d + maxn, inf);    d[s] = 0;   // 初始化    for (int i = 0; i &lt; n; i++) {   // 循环n次        int u = -1, min = inf;        for (int j = 0; j &lt; n; j++) {            if (d[j] &lt; min &amp;&amp; vis[j] == false) {                u = j;  // u是起点到当前未访问顶点中距离最小的点                min = d[j];            }        }        if (u == -1) return;    // 说明剩下的顶点和s不连通        vis[u] = true;        for (int v = 0; v &lt; n; v++) {            if (vis[v] == false &amp;&amp; g[u][v] != inf) {                if (g[u][v] + d[u] &lt; d[v]) {                    d[v] = d[u] + g[u][v];                    pre[v].clear();                    pre[v].push_back(u);    // 令v的前驱为u                }                else if (g[u][v] + d[u] == d[v]) {                    pre[v].push_back(u);                }            }        }    }}\n\nDFS部分\n\nint optValue;   //表示第二标尺最优值vector&lt;int&gt; pre[maxn];vector&lt;int&gt; path, tempPath; //最优路径和临时最优路径void DFS(int s) {    //递归边界    if (v == st) {  //到达了叶子结点st        tempPath.push_back(v);        int value;        value = tempPath上的value值        if (value 优于 optValue) {            optValue = value;            path = tempPath;        }        tempPath.pop();        return;    }    //递归式    tempPath.push_back(v);    for (int i = 0; i &lt; pre[v].size(); i++) {        DFS(pre[v][i]);    }    tempPath.pop_back();}\n\n访问部分（因为递归的原因，所以一般要逆向访问）\n\n//边权部分int value = 0;for (int i = tempPath.size() - 1; i &gt; 0; i--) {    int id = tempPath[i], nextId = tempPath[i-1];    value += v[i][i-1]; //value增加id-&gt;idNext的边权}//点权部分int value = 0;for (int i = tempPath.size() - 1; i &gt; 0; i--) {    int id = tempPath[i];    value += w[i]; //value增加id的点权}\n\nBellman-Ford\n用于处理负环的情况，当存在负环而且负环从源点可达时Dijkstra算法会出错，因为负环会导致在第一次遍历结束后最短路径的某部分可以通过负环得到优化。Bellman算法不是进行1次，而是进行v-1（v为顶点个数）次，每一次都至少优化一层（可以证明最短路径一定不会超过v-1层）。\n\nstruct Node {    int v, dis; // v为邻接边的目标顶点，dis为邻接边的边权};const int MAXN = 0x3fffffff;vector&lt;Node&gt; g[MAXN];int n;  //顶点数int d[MAXN];    //起点到达各点的最短路径长度void Bellman(int s) {    fill(d, d + MAXN, INF);    //以下为求解数组d的部分    for (int i = 0; i &lt; n - 1; i++) {        for (int u = 0; u &lt; n; u++) {            for (int j = 0; j &lt; g[u].size(); j++) {                int v = g[u][j].v;                int dis = g[u][j].dis;                if (d[u] + dis &lt; d[v]) {                    d[v] = d[u] + dis;                }            }        }    }}\n\nSPFAvector&lt;Node&gt; adj[maxn]; //图g的邻接表int n, d[maxn], num[maxn];  //num数组记录顶点的入队次数bool inq[maxn]; //判断顶点是否在队列中bool SPFA(int s) {    //初始化部分    memset(inq, false, sizeof(inq));    memset(num, 0, sizeof(num));    fill(d, d + maxn, inf);    //核心部分    queue&lt;int&gt; q;    q.push(s);    d[s] = 0;    inq[s] = true;    num[s]++;    while (!q.empty()) {        int u = q.front();        q.pop();        inq[u] = false;        //遍历u的所有邻接边v        for (int j = 0; j &lt; adj[u].size(); j++) {            int dis = adj[u][j].dis;            int v = adj[u][j].v;            if (d[u] + dis &lt; d[v]) {                d[v] = d[u] + dis;                if (!inq[v])  {                    q.push(v);                    inq[v] = true;                    num[v]++;                    if (num[v] &gt;= n)                        return false;   //有可达负环                }            }        }    }    return true;    //无可达负环}\n\nFloyd（全源最短路径）#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 1000000000; //初始的所有边权const int MAXV = 1000;  //最大顶点数int n, m;   //n为顶点数，m为边数int dis[MAXV][MAXV];    //dis[i][j]表示顶点i和顶点j的最短距离void Floyd() {    for (int k = 0; k &lt; n; k++) {        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; n; j++) {                if (dis[i][k] + dis[k][j] &lt; dis[i][j] &amp;&amp;                    dis[i][k] != INF &amp;&amp; dis[k][j] != INF) {                    dis[i][j] = dis[i][k] + dis[k][j];                }            }        }    }}int main() {    fill(dis[0], dis[0] + MAXV * MAXV, INF);  //初始化边权    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++)         dis[i][i] = 0;  //别忘了顶点到自身的距离是0    int u, v;    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;u, &amp;v);        scanf(\"%d\", &amp;dis[u][v]);    }    Floyd();    //执行完Floyd之后dis[i][j]储存i到j的最短路径    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            printf(\"%d \", dis[i][j]);        }        printf(\"\\n\");    }    return 0;}\n\n最小生成树prim算法#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 1000000000; //初始的所有边权const int MAXV = 1000;  //最大顶点数int n, m;   //n为顶点数，m为边数int d[MAXV];    //顶点到集合s的最短距离int g[MAXV][MAXV];  //图bool vis[MAXV] = {false};   //vis表示顶点是否访问过int Prim() {    //默认0号为初始点，返回最小生成树的边权之和    fill(d, d + MAXV, INF);   //将整个d数组初始化为INF    d[0] = 0;    int ans = 0;    //ans值为最小生成树的边权之和    for (int i = 0; i &lt; n; i++) {        int u = -1, MIN = INF;  //min一般初始赋值很大值，max一般赋很小值        for (int j = 0; j &lt; n; j++) {            if (vis[j] == false &amp;&amp; d[j] &lt; MIN) {                u = j;                MIN = d[j];            }        }        //找不到小于INF的d[u]，说明剩下的顶点和集合s不联通        if (u == -1) return -1;        vis[u] = true;        ans += d[u];    //将与集合s距离最小的边加入最小生成树        for (int v = 0; v &lt; n; v++) {            if (vis[v] == false &amp;&amp; g[u][v] != INF &amp;&amp;                d[v] &gt; g[u][v]) {                d[v] = g[u][v]; //将g[u][v]赋值给d[v]，说明是距离集合的最小值            }        }    }    return ans;}int main() {    fill(g[0], g[0] + MAXV * MAXV, INF);  //初始化边权    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++)         g[i][i] = 0;  //别忘了顶点到自身的距离是0    int u, v;    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;u, &amp;v);        scanf(\"%d\", &amp;g[u][v]);        g[v][u] = g[u][v];    }    int ans = Prim();    printf(\"%d\", ans);    return 0;}\nKruskal算法#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 110;  //最大顶点数const int maxe = 11000; //最大边数int n, m;   //n为顶点数，m为边数int father[maxv];   //并查集来判断是否为连通图struct Edge {    int u, v;   //表示边的两个顶点    int value;  //边权值} edge[maxe];bool cmp(Edge a, Edge b) {    return a.value &lt; b.value;}int findFather(int x) {    int a = x;    while (a != father[a]) {        a = father[a];  //寻找父亲，循环结束时a储存该连通图的根结点    }    while (x != father[x]) {    //路径压缩        int z = x;  //先储存，x会被father[x]替换掉        x = father[x];        father[z] = a;    }    return a;}int Kruskal() {    int ans = 0, numEdge = 0;   //ans表示最小生成树边权值和，numEdge表示边数    for (int i = 0; i &lt; m; i++) {        if (numEdge == n - 1) break;        int fau = findFather(edge[i].u);        int fav = findFather(edge[i].v);        if (fau != fav) {   //说明两个联通分量独立            father[fau] = fav;            ans += edge[i].value;            numEdge++;        }    }    if (numEdge != n - 1) return -1;    //说明整个图不联通    return ans;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {   //初始化并查集        father[i] = i;    }    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d%d\", &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].value);    }    sort(edge, edge + m, cmp);    int ans = Kruskal();    printf(\"%d\", ans);    return 0;}\n\n拓扑排序拓扑排序可以用来判断一个有向图是否是有向无环图。\nvector&lt;int&gt; g[maxn];    //邻接表int n, m, inDegree[maxn];   //表示顶点数，边数和入度//拓扑排序bool topuSort() {   //当为有向无环图时返回true    int num = 0;    queue&lt;int&gt; q;    for (int i = 0; i &lt; n; i++) {   //如果入度为0，则入队        if (inDegree[i] == 0) {            q.push(i);        }    }    while (!q.empty()) {        int u = q.front();        q.pop();        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i];    //后继结点            inDegree[v]—-;            if (inDegree[v] == 0) {                q.push(v);            }        }        num++;    }    if (num == n) return true;    else return false;}\n\n\n动态规划什么是动态规划\n动态规划（Dynamic Programming）是一种用来解决一类最优化问题的算法思想。简单来说，动态规划将一个复杂的问题分解成若干个问题，通过综合子问题的最优解来得到原问题最优解的过程。十分灵活，无固定写法。有以下几个特性：\n\n一个问题必须要有重叠子问题和最优子结构才能用动态规划求解\n与分治的区别：分治不拥有重叠子问题\n与贪心的区别：贪心“自顶向下”，只考虑子问题中最优的一个解。动态规划会考虑所有子问题，并选择继承能得到最优结果的那一个\n设计状态转移方程是动态规划的核心，也是动态规划最难的地方。动态转移方程必须满足状态的无后效性\n\n\n递归写法（斐波那契数列）思路：每次访问到一个数时将其储存起来，来大量减少重复计算。类似打表的思想，以空间换取时间代价\nint F(int n) {    if (n == 0 || n == 1) return 1;    if (dp[n] != -1) return dp[n];    else {        dp[n] = F(n-1) + F(n-2);        return dp[n];    }}\n\n递推写法（数塔问题）状态转移方程：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1000;int f[maxn][maxn], dp[maxn][maxn];int main() {    int n;    scanf(“%d”, &amp;n);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= i; j++) {            scanf(“%d”, &amp;f[i][j]);        }    }    for (int j = 1; j &lt;= n; j++) {        dp[n][j] = f[n][j];    }    for (int i = n - 1; i &gt;= 1; i—-) {        for (int j = 1; j &lt;= i; j++) {            max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];        }    }    printf(“%d”, dp[1][1]);    return 0;}\n\n最大连续子序列和\n给定一个数字序列，就其中最大的连续子序列的和。\n\n思路：设立一个数组dp，存放的是以a[i]作为末尾的连续序列的最大和，可以发现dp[i]可以由dp[i-1]和a[i]得到。状态转移方程为：。\nint main() {    int n, k;    scanf(“%d”, &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(“%d”, &amp;a[i]);    }    dp[0] = a[0];    for (int i = 1; i &lt; n; i++) {        dp[i] = max{a[i], dp[i-1] + a[i]};    }    for (int i = 1; i &lt; n; i++) {        if (dp[i] &gt; dp[k]) k = i;    }    printf(“%d”, dp[k]);}\n\n最长不下降子序列（LIS）\n在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降（非递减）的。\n\n状态转移方程：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int A[N], dp[N];int main() {    int n;    scanf(“%d”, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(“%d”, &amp;A[i]);    int ans = -1;   // 记录最大长度    for (int i = 1; i &lt;=; i++) {        dp[i] = 1;        for (int j = 1; j &lt; i; j++) {            dp[i] = dp[j] + 1;  // 状态转移方程，用以更新dp[i]        }    }    ans = max(ans, dp[i]);}printf(“%d”, ans);return 0;\n\n最长公共子序列（LCS）\n给定两个字符串a和b（下标从1开始），求一个字符串，使得这个字符串是a和b的最长公共部分（子序列可以不连续)。\n\n状态转移方程为：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[100][100];int main() {    string a, b;    scanf(“%s%s”, a, b);    a = “(” + a;    // 让a和b下标从1开始，找两个不同的字符    b = “)” + b;    int lena = a.length(), b = b.length();    memset(dp, 0, sizeof(dp)); // 初始化为0    // 状态转移方程    for (int i = 1; i &lt;= lena; i++) {        for (int j = 1; j &lt;= lenb; j++) {            if (a[i] == b[j]) {                dp[i][j] = dp[i-1][j-1] + 1;            } else {                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);            }        }    }    printf(“%d”, dp[lena][lenb]);    return 0;}\n\n最长回文子串\n给出一个字符串s，求s的最长回文子串的长度。\n\n状态转移方程：\n#include &lt;iostream&gt;using namespace std;int dp[1001][1001];int main() {    string s;    can &gt;&gt; s;    int len = s.length(), ans = 1;    memset(dp, 0, sizeof(dp));  // dp数组初始化为0    for (int i = 0; i &lt; len; i++) {        dp[i][i] = 1;        if (i &lt; len - 1) {            if (s[i] == s[i+1]) {                dp[i][i+1] = 1;                ans = 2;            }        }    }    // 状态转移方程    for (int l = 3; l &lt;= len; l++) {        for (int i = 0; l + i - 1 &lt; len; i++) {            int j = l + i - 1;            if (s[i] == s[j] &amp;&amp; dp[i+1][j-1] == 1) {                dp[i][j] = 1;                ans = l;            }        }    }    printf(“%d”, ans);    return 0;}\n\n背包问题01背包问题\n有n件物品，每件物品重量为w[i]，价值为w[i]。现在有一个容量为v的背包，问如何选取物品放入背包中，使得背包中的总价值最大。其中每件物品都只有1件。\n\n二维数组做法（便于理解）的状态转移方程：\n空间优化解法的状态转移方程：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int w[100], c[100], dp[1000];int main() {    int n, V;    scanf(“%d%d”, &amp;n, &amp;V);    for (int i = 1; i &lt;= n; i++) scanf(“%d”, &amp;w[i]);    for (int i = 1; i &lt;= V; i++) scanf(“%d”, &amp;c[i]);    memset(dp, 0, sizeof(dp));    for (int i = 1; i &lt;= n; i++) {        for (int v = V; v &gt;= w[i]; v--) {            dp[v] = max(dp[v], dp[v-w[i]] + c[i]);        }    }    int maxn = 0;    for (int v = 0; v &lt;= V; v++) {        if (dp[v] &gt; maxn) maxn = dp[v];    }    printf(“%d”, maxn);    return 0;}\n\n完全背包问题\n有n件物品，每件物品重量为w[i]，价值为w[i]。现在有一个容量为v的背包，问如何选取物品放入背包中，使得背包中的总价值最大。其中每件物品有无穷件。\n\n状态转移方程：边界为：\n一维状态转移方程：边界为：\n此处和01背包问题的不同点在于是正向枚举的\nfor (int i = 1; i &lt;= n; i++) {    for (int v = w[i]; v &lt;= V; v++) {        dp[v] = max(dp[v], dp[v - w[i]] + c[i]);    }}\n\n\n字符串匹配KMP时间复杂度为：（）\n//getNext求解长度为n的字符串s的next数组void getNext(string s, int n) {    int j = -1;    next[0] = -1;   //初始化j = next[0] = -1表示    for (int i = 1; i &lt; n; i++) {   //求解1～n-1的next数组        while（j != -1 &amp;&amp; s[i] != s[j+1]) {            j = next[j];    //反复让j = next[j]        }   //当j = -1或s[i] == s[j+1]        if (s[i] == s[j+1]) {            j++;    //next[i] = j + 1        }        next[i] = j;    }}//KMP算法，判断pattern是否是text的子串bool KMP(string text, string pattern) {    int lent = text.length(), lenp = pattern.length();    getNext(pattern, lenp);    int j = -1;    for (int i = 0; i &lt; n; i++) {        while (j != -1 &amp;&amp; text[i] != pattern[j+1]) {            j = next[j];        }        if (text[i] == pattern[j+1]) {            j++;        }        if (j == m - 1) {            return true;        }    }    return false;}\n\n\n数学问题最大公约数 &amp; 最小公倍数最大公约数通常采用辗转相除法解决\nint gcd(int a, int b) {    if (b == 0) return a;    else return gcd(b, a % b);}\n得到最大公约数d后，最小公倍数即为\n素数判断一般方法bool isPrime(int n) {    if (n &lt;= 1) return false;    for (int i = 2; i * i &lt;= n; i++) {        if (n % i == 0) return false;    }    return true;}\n该方法判断1～n之间的素数时时间复杂度为o（n√n)\n埃氏筛法const int maxn = 101;int prime[maxn], pNum = 0;bool p[maxn] = {0};void findPrime() {    for (int i = 2; i &lt; maxn; i++) {        if (!p[i]) {            prime[pNum++] = i;            for (int j = i + i; j &lt; maxn; j += i) {                p[j] = true;            }        }    }}\n\n质因子分解一个重要结论：对一个正整数n来说，如果它存在[2,n]范围内的质因子，要么这些质因子全部小于等于sqrt（n），要么只存在一个大于sqrt（n）的质因子，而其余质因子全部小于等于sqrt（n）。\n模版如下：\nif (n % prime[i] == 0) {    fac[num].x = prime[i];    fac[num].cnt = 0;    while (n % prime[i] == 0) {        fac[num].cnt++;        n /= prime[i];    }    num++;}\n\n大整数运算大整数储存struct bign {    int d[1000];    int len;    // 储存该大整数的长度，很有用    bign () {   // 初始化该结构体，默        memset(d, 0, sizeof(d));        len = 0;    }};\n高精度加法bign add (bign a, bign b) {    bign c;    int carry = 0;  // 表示进位值    for (int i = 0; i &lt; a.len || i &lt; b.len; i++) {        int temp = a.d[i] + b.d[i] + carry;        c.d[c.len++] = temp % 10;        carry = temp / 10;    }    if (carry != 0) {   // 如果最后进位不为0，则直接赋值给最高位        c.d[c.len++] = carry;    }    return c;}\n高精度减法bign sub(bign a, bign b) {  // a为减数，b为被减数    bign c;    for (int i = 0; i &lt; a.len || i &lt; b.len; i++) {        if (a.d[i] &lt; b.d[i]) {            a.d[i+1]—-;            a.d[i] += 10;         }        c.d[c.len++] = a.d[i] - b.d[i];    }    while (c.len - 1 &gt; 1 &amp;&amp; c.d[c.len-1] == 0) {        c.len—-;    // 去除最高位的0，同时至少保留一位最低位    }    return c;}\n高精度与低精度的乘法bign multi(bign a, int b) {    bign c;    int carry = 0;    for (int i = 0; i &lt; a.len; i++) {        int temp = a.d[i] * b + carry;        c.d[len++] = temp % 10;        carry = temp / 10;    }    while (carry != 0) {        c.d[c.len++] = carry % 10;        carry /= 10;    }    return c;}\n高精度与低精度的除法bign divide(bign a, bign b, int&amp; r) {    bign c;    c.len = a.len;  // 被除数的每一位和商的每一位是一一对应的，先令长度相等    for（int i = a.len - 1; i &gt;= 0; i--) {   // 从高位开始        r = r * 10 + a.d[i];    // 与上一位留下的余数组合        if (r &lt; b) c.d[i] = 0;  // 不够除，该位为0        else {  // 够除            c.d[i] = r / b;            r = r % b;        }    }    while (c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) {        c.len--;    }    return c;}\n\n拓展欧几里得算法\n给定两个非零整数a和b，求一组整数解（x，y），使得ax + by = gcd（a，b）成立。推导可以得到一个递推公式，，。其中x1，y1表示新值，x2，y2表示旧值。\n\nint exGcd(int a, int b, int &amp;x, int &amp;y) {    if (b == 0) {        x = 1;        y = 0;        return a;   // 此处的a即为边界的gcd    }    int g = exGcd(b, a % b, x, y);    int temp = x;   // 存放x值    x = y;   // 更新x = y（old）    y = temp - a / b * y;   // 更新y = x(old) - a / b * y(old)    return g;}\n此处x和y使用引用是因为保留对x和y的更新。\n组合数\n求n！中有多少个质因子p。\n\n// 计算n！中有多少质因子pint cal(int n, int p) {    int ans = 0;    while (n) {        ans += n / p;   // 累加n/p^k        n /= p;     // 相当于分母多乘一个p    }    return ans;}\n此处代入cal(n, 5)可以很快得到n！末尾有多少个零。因为末尾0的个数等于因子中10的个数，每个10都可以且只能分解出一个5，所以数目相等。\n","categories":["数据结构与算法"],"tags":["排序","递归","贪心","双指针","图论","树","数学","动态规划"]},{"title":"面向对象基础","url":"/2021/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","content":"说明该文章大部分内容来自以下开源博客：面向对象思想\n1 三大特性1.1 封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。内部的数据被隐藏了起来，外部只可以通过提供的接口访问数据。因此用户无需关心对象内部的细节，同时也无从得知其内部的细节。\n优点：\n\n减少耦合：可以独立地开发、测试、优化、使用、理解和修改\n\n减轻维护的负担：可以更容易被理解，并且在调试的时候不影响其他模块\n\n有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能\n\n提高软件的可重用性\n\n降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的\n\n\n1.2 继承继承实现了IS-A关系，例如Cat和Animal就是一种IS-A关系，Cat可以继承ziAnimal，从而获得Animal非private的属性和方法。\n继承应该遵循里氏替换原则。\nCat可以当作Animal来使用，也就是说可以使用Animal引用Cat对象（这是一个十分常用的写法）。父类对象引用指向子类对象称为向上转型。\nAnimal animal = new Cat();\n\n1.3 多态多态分为编译时多态和运行时多态：\n\n编译时多态主要指方法的重载（Overload），发生在一个类之内。常见的形式是重载多个构造函数，提供创建新对象时的方便。重载应该满足的条件是：\n\n函数名必须相同\n\n参数列表必须不同（参数个数、数据类型、参数顺序）\n\n函数的返回类型可以相同也可以不同\n\n仅仅返回类型不同不足以称为重载\n\n\n\n运行时多态是指程序中定义的对象引用所指向的具体类型在运行期间才确定，具体实现有重写（Override），运行时多态有三个条件：\n\n继承\n\n覆盖（重写）\n\n向上转型\n\n\n\n\n重写与重载的区别重载（Overload）实现的是编译时的多态性，重写（Overrid）实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。\n2 六种关系2.1 泛化关系用来描述继承关系，在Java中使用extends关键字，uml写法如下：\n\n\n2.2 实现关系用来实现一个接口，在Java中使用implements关键字。\n\n\n2.3 聚合关系聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has - a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，比如计算机与CPU、公司与员工的关系等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。\n\n\n2.4 组合关系组合也是关联关系的一种特例，他体现的是一种contains - a的关系，这种关系比聚合更强，也称为强聚合。他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如你和你的大脑，表现在代码层面，和关联关系是一致的，只能从语义级别来区分。\n以公司和部门为例子，如果公司没了，则部门就不存在了。\n\n\n2.5 关联关系关联关系体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友。这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，关系一般是平等的、关联可以是单向、双向的。表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。\n这是一种静态的关系，与运行过程的状态无关。可以用1对1、1对多，多对多这种关系来表示。举例来说，学校和学生就是一种关联关系，一个学校可以有很多学生，一个学生只能属于一个学校。这种关系在运行之前就可以确定。\n\n\n2.6 依赖关系可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。\n与关联关系不同的是，依赖关系是在运行过程中起作用的。A类和B类是依赖关系主要有三种形式：\n\nA类是B类方法的局部变量\n\nA类是B类方法的参数\n\nA类向B类发送消息，从而影响B类发生变化\n\n\n\n\n\n关系的耦合程度耦合程度排序：泛化 ≈ 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖。\n好的代码应该实现：高内聚，低耦合。\n3 五种设计原则\n\n\n简写\n全拼\n中文翻译\n\n\n\nSRP\nThe Single Responsibility Principle\n单一职责原则\n\n\nOCP\nThe Open Closed Principle\n开放封闭原则\n\n\nLSP\nThe Liskov Substitution Principle\n里氏替换原则\n\n\nISP\nThe Interface Segregation Principle\n接口分离原则\n\n\nDIP\nThe Dependency Inversion Principle\n依赖倒置原则\n\n\n3.1 单一职责原则\n修改一个类的原因应该只有一个。\n\n一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。\n如果一个类承担的职责过多，那么某个职责的变化可能会削弱这个类完成其他职责的能力。\n多职责会导致脆弱和不易理解的设计。\n3.2 开放封闭原则\n类应该对拓展开放，对修改关闭。\n\n该原则要求在添加新功能时可以新增，但是不能修改原代码。\n符合开闭原则最典型的例子就是装饰者模式，它可以动态地将责任附加在对象上，而不用去修改类的代码。\n实现OCP的主要机制是抽象和多态，LSP和DIP是OCP的基础。\n3.3 里氏替换原则\n子类对象必须能够替换掉所有父类对象。\n\n所有出现父类对象的地方将其换成子类都不会出问题。子类应该在实现父类的一切功能的基础上比父类更加特殊。\nLSP是多态顺利实现的保证，从而使OCP称为可能，因为正是子类型的可替换性才使得使用基类的模块在无需修改的情况下就可以拓展：\n\n增加或修改任何一个子类型，基类不用修改（封闭）\n\n基类的使用者（客户程序）可以通过多态得到拓展或修改过的行为（开放）\n\n\n3.4 接口分离原则\n不应该强迫客户依赖于他们不用的方法。\n\n使用多个专门的接口比使用单一的总接口要好。\n3.5 依赖倒置原则\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\n\n按照自上而下的依赖关系，高层的策略设置模块往往是无法重用的，如果设法让高层模块独立于低层模块，则实现重用就变成可能。\n面向接口编程：依赖倒置原则的启发式建议是“依赖于抽象”，具体做法是将高层需要的服务声明为抽象接口，高层使用这些接口，低层实现这些接口，使得高层不再依赖于底层，而是依赖于抽象接口，同样底层也依赖于抽象接口。\n依赖于抽象意味着：\n\n任何变量都不应该持有一个指向具体类的指针或者引用\n\n任何类都不应该从具体类派生\n\n任何方法都不应该重写它的任何基类中已经实现的方法\n\n\n细节抽象类和接口的区别\n抽象类中可以有0～n个抽象方法，也可以有普通方法，接口中只能有抽象方法（JDK1.8之后允许有普通方法）。\n\n抽象类定义之前必须有abstract修饰符，而接口不用class，用interface，其实这也说明了接口并不是类。\n\n抽象类可以继承自抽象类，接口可以继承自接口，抽象类可以实现接口，但是接口不能实现接口。\n\n抽象类中的成员变量和方法可以是各种类型的（public，protected，default，private），但抽象方法必须是protected or public（因为要给子类访问）。接口不能有变量，只能拥有常量（public static final），抽象方法必须为public（通用接口）。\n\n\n","categories":["面向对象"],"tags":["设计原则","类的关系","三大特性"]},{"title":"设计模式模板","url":"/2021/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/","content":"致谢本文章大量参考了B站up主子烁爱学习的五分钟设计模式系列视频与GitHub用户CyC2018的开源博客。已获得转载许可。附上链接：子烁爱学习的空间CyC2018的设计模式目录\n什么是设计模式？设计模式是软件工程的基石，是现在合作开发工程化的理论基础。不同的设计模式是现实生活中不断重复发生的时间的核心解决方案。\n通俗来讲，就是前人总结出来的类和对象的写法，通过这种写法，能够让你的代码可以复用，不至于相同的功能写N遍；拓展性也好，能够很方便地应对变化的需求。\n所以实际上市面上教设计模式的书也可以改名成《代码这样写，产品经理再刁钻也不怕》。\n1 创建型1.1 单例模式（Singleton）确保类中只有一个实例，并提供该实例的全局访问点。\n1.1.1 懒汉式-线程不安全public class Singleton &#123;    //私有单例对象，保证只有这一个实例    private static Singleton uniqueInstance;        //私有构造方法，覆盖默认构造，保证无法new对象    private Singleton() &#123;    &#125;        //公有get方法，可以享受延迟实例化带来的内存优势，但是当多线程时可能出错    public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            uniqueInstance = new Singleton();        &#125;        return uniqueInstance;    &#125;&#125;\n\n1.1.2 饿汉式-线程安全//多线程安全，但是不能延迟实例化private static Singleton uniqueInstance = new Singleton();\n\n1.1.3 懒汉式-线程安全//使用synchronized关键字加锁，可以应对多线程情况，但是可能造成线程拥塞时间过长，有性能问题public static synchronized Singleton getUniqueInstance() &#123;    if (uniqueInstance == null) &#123;        uniqueInstance = new Singleton();    &#125;    return uniqueInstance;&#125;\n\n1.1.4 双重校验锁-线程安全public class Singleton &#123;        //valatile关键字可以禁止JVM指令重排，保证多线程环境下也能正常运行    private volatile static Singleton uniqueInstance;    private Singleton() &#123;    &#125;        //内部的if语句是为了应对多线程同时进入外层if的情况，如果没有内部if，当多个线程同时进入外层if时，那么必然会new出多个对象    public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            synchronized (Singleton.class) &#123;                if (uniqueInstance == null) &#123;                    uniqueInstance = new Singleton();                &#125;            &#125;        &#125;        return uniqueInstance;    &#125;&#125;\n\n1.1.5 静态内部类（推荐）//既有延迟初始化的好处，又有JVM对线程安全负责public class Singleton &#123;        private Singleton() &#123;    &#125;        //静态内部类    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;        public static Singleton getUniqueInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;\n\n\n\n1.2 简单工厂（SimpleFactory）创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口，也就是工厂。\n怎么理解工厂？将建造方法集成在一个类中，当要用到时就建立工厂（new SimpleFactory），然后通过工厂方法生产。\nProductpublic interface Product &#123;&#125;public class ConcreteProduct1 implements Product &#123;&#125;public class ConcreteProduct2 implements Product &#123;&#125;public class ConcreteProduct3 implements Product &#123;&#125;\n\nSimpleFactorypublic class SimpleFactory &#123;    public Product createProduct(int type) &#123;        if (type == 1) &#123;            return new ConcreteProduct1();        &#125; else if (type == 2) &#123;            return new ConcreteProduct2();        &#125; else if (type == 3) &#123;                return new ConcreteProduct3();        &#125;    &#125;&#125;\n\nClientpublic class Client &#123;    public static void main(String[] args) &#123;        SimpleFactory simpleFactory = new SimpleFactory();        Product product = simpleFactory.createProduct(1);        // do something with the product    &#125;&#125;\n\n1.3 工厂模式（Factory）定义一个创建对象的接口，此接口并不实例化类，由其子类来实例化，工厂方法将实例化操作推迟到了子类。\n实现public abstract class Factory &#123;    abstract public Product factoryMethod();    public void doSomething() &#123;        Product product = factoryMethod();        // do something with product    &#125;&#125;public class ConcreteFactory1 extends Factory &#123;    public Product factoryMethod() &#123;        return new ConcreteProduct1();    &#125;&#125;public class ConcreteFactory2 extends Factory &#123;    public Product factoryMethod() &#123;        return new ConcreteProduct2();    &#125;&#125;\n\n\n1.4 抽象工厂（AbstractFactory）提供一个接口，用于创建相关的对象家族。\n实现说明：可以将AbstractProduct理解为某一类产品，例如衣服类中的商务套装，商务套装包括上衣和裤子，需要一起使用。所以会让ProductA1和A2基础ProductA（B同理）。而用另一种分类法，上衣可以划分一类，裤子可以划分一类，对于工厂来说，这种划分方法更加科学。所以某一具体的工厂会按照这样的方式生产。\npublic class AbstractProductA &#123;&#125;public class AbstractProductB &#123;&#125;public class ProductA1 extends AbstractProductA &#123;&#125;public class ProductA2 extends AbstractProductA &#123;&#125;public class ProductB1 extends AbstractProductB &#123;&#125;public class ProductB2 extends AbstractProductB &#123;&#125;public abstract class AbstractFactory &#123;    abstract AbstractProductA createProductA();    abstract AbstractProductB createProductB();&#125;public class ConcreteFactory1 extends AbstractFactory &#123;    AbstractProductA createProductA() &#123;        return new ProductA1();    &#125;    AbstractProductB createProductB() &#123;        return new ProductB1();    &#125;&#125;public class ConcreteFactory2 extends AbstractFactory &#123;    AbstractProductA createProductA() &#123;        return new ProductA2();    &#125;    AbstractProductB createProductB() &#123;        return new ProductB2();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractFactory abstractFactory = new ConcreteFactory1();        AbstractProductA productA = abstractFactory.createProductA();        AbstractProductB productB = abstractFactory.createProductB();        // do something with productA and productB    &#125;&#125;\n\n\n1.5 生成器（Builder）封装一个复杂对象的构造过程，允许一步一步构造这个复杂对象而不是通过构造函数一次性建成。例如对于一个房屋对象，可以先构造其窗户对象，再构造门，墙，地板等等。\n实现public class BuildPattern &#123;    public static void main(String[] arts) &#123;        House house = new House.Builder();        house.setWindow(new Window());        house.setDoor(new Door());        house.setWall(new Wall());        house.build();    &#125;&#125;class House &#123;    private Window window;    private Door door;    private Wall wall;        public House(Builder builder) &#123;        this.window = builder.window;        this.door = builder.door;        this.wall = builder.wall;    &#125;        static final class Builder &#123;        private Window window;        private Door door;        private Wall wall;                  public Builder setWindow(Window window) &#123;            this.window = window;            return this;    //返回自己，很关键        &#125;                public Builder setDoor(Door door) &#123;            this.door = door;            return this;    //返回自己，很关键        &#125;                public Builder setWindow(Wall wall) &#123;            this.wall = wall;            return this;    //返回自己，很关键        &#125;                public House build() &#123;  //build方法用于返回house对象            return new House(builder.this);        &#125;    &#125;&#125;\n\n1.6 原型模式（Prototype）通过在类的内部实现一个克隆的方法，使得这个类可以很方便地被外部类克隆拿到属性值。\n实现interface Prototype &#123;    Object clone();&#125;class Plane() implements Prototype &#123;    private String name;    private String type;        public Plane() &#123;        //自己设定的name和type值    &#125;       public String getName() &#123;        return name;    &#125;        public String getType() &#123;        return type;    &#125;        public Object clone() &#123;        return new Plane(this);    &#125;&#125;\n\n2 行为型2.1 责任链模式（ResponsibilityChain）是一种处理请求的模式，它让多个处理器有机会处理该请求，知道某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。\n优点是将请求和处理分离开，请求者和处理者都不需要知道处理的全貌。也可以提高系统的灵活性，新增一个处理器代价小，不需要修改源代码。缺点是当链条比较长时性能会大幅下降，例如某个请求应该交给顶级BOSS处理，但是这个请求必须走个一整个完整的链条。\n实现abstract class Handler &#123;    protected Handler nextHandler;    public void setNextHandler(Handler nextHandler) &#123;        this.nextHandler = nextHandler;    &#125;        public abstract void process(int info);&#125;\n\nclass Leader extends Handler &#123;        @override    public void process(int info) &#123;        if (info &gt; 0 &amp;&amp; info &lt; 20)             System.out.println(“Leader处理！”);        else            nextHandler.process(info);    &#125;&#125;class Boss extends Handler &#123;        @override    public void process(int info) &#123;        System.out.println(“Boss处理！”);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Handler level1 = new Handler();        Handler level2 = new Handler();        level1.setNextHandler(level2);        level1.process(10);        level1.process(20);    &#125;&#125;\n\nLeader处理Boss处理\n\n2.2 命令模式（Command）命令模式可以将请求转化成为一个包含与请求相关的所有信息的独立对象。该转换能让你根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。\n实现//[图像渲染层]保存按钮class SaveButton &#123;    private Command command;        // 此处省略图像渲染过程        public void bindCommand(Command command) &#123;        this.command = command;    &#125;        public void doPrint() &#123;        if (command == null)             throw new RuntimeException(“设备初始化失败！”);        command.execute();    &#125;&#125;\n\n//[业务逻辑层]打印服务class PrintService &#123;    public void print(String text) &#123;        System.out.println(text);    &#125;&#125;\n\ninterface Command &#123;    public void execute();&#125;\n\nclass PrintCommand implements Command &#123;    private PrintService serviceProvider = new PrintService();    private TextBox text;        public PrintCommand(TextBox text) &#123;        this.text = text;    &#125;        @Override    public void execute() &#123;        serviceProvider.print(box.getContext());    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        SaveButton.saveButton = new SaveButton();        TextBox box = new TextBox();                PrintCommand printCommand = new PrintCommand(box);        saveButton.bindCommand(printCommand);                box.setContext(“ABCDEFG”);        saveButton.doPrint();                box.setContext(“ABCDEFGHIJK”);        saveButton.doPrint();    &#125;&#125;\n\n2.3 观察者模式（Observer）定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。\n\n\n实现天气数据布告板会在天气信息改变时更新其内容，布告板有多个，并且在将来会继续增加。\npublic interface Subject &#123;    void registerObserver(Observer o);    void removeObserver(Observer o);    void notifyObserver();&#125;\n\npublic class WeatherData implements Subject &#123;    private List&lt;Observer&gt; observers;    private float temperature;    private float humidity;    private float pressure;    public WeatherData() &#123;        observers = new ArrayList&lt;&gt;();    &#125;    public void setMeasurements(float temperature, float humidity, float pressure) &#123;        this.temperature = temperature;        this.humidity = humidity;        this.pressure = pressure;        notifyObserver();    &#125;    @Override    public void registerObserver(Observer o) &#123;        observers.add(o);    &#125;    @Override    public void removeObserver(Observer o) &#123;        int i = observers.indexOf(o);        if (i &gt;= 0) &#123;            observers.remove(i);        &#125;    &#125;    @Override    public void notifyObserver() &#123;        for (Observer o : observers) &#123;            o.update(temperature, humidity, pressure);        &#125;    &#125;&#125;\n\npublic interface Observer &#123;    void update(float temp, float humidity, float pressure);&#125;\n\npublic class StatisticsDisplay implements Observer &#123;    public StatisticsDisplay(Subject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;\n\npublic class CurrentConditionsDisplay implements Observer &#123;    public CurrentConditionsDisplay(Subject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;\n\npublic class WeatherStation &#123;    public static void main(String[] args) &#123;        WeatherData weatherData = new WeatherData();        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);        weatherData.setMeasurements(0, 0, 0);        weatherData.setMeasurements(1, 1, 1);    &#125;&#125;\n\nCurrentConditionsDisplay.update: 0.0 0.0 0.0StatisticsDisplay.update: 0.0 0.0 0.0CurrentConditionsDisplay.update: 1.0 1.0 1.0StatisticsDisplay.update: 1.0 1.0 1.0\n\n2.4 中介者模式（Mediator）中介者模式通过设置一个中介者，能够减少对象之间混乱无序的依赖关系，该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作（就像计算机网络中的星型拓扑结构）。\n\n\n每个参与者Component都会维护一个Mediator中介者对象，通过该中介者来执行相关操作，而不是直接与其他参与者交互。\n实现以婚姻中介为例子，一个婚姻中介场所吸纳了很多会员，会员不需要与其他会员产生联系，婚姻中介会自动给其匹配。该例中婚姻中介即为中介者，而会员是参与者。\ninterface MarriageAgency &#123;    void register(Person person);   //注册会员    void pair(Person person);   //为person配对&#125;\n\nclass Person &#123;    int age;    Sex sex;    int requestAge; //要求对象年龄，此处找对象只有这一个要求，十分理想    MarriageAgency agency;  //婚姻中介    public Person(String name, int age, Sex sex, int requestAge,                  MarriageAgency agency) &#123;        this.name = name;        this.age = age;        this.sex = sex;        this.requestAge = requestAge;        this.agency = agency;        agency.register(person:this);   //注册会员    &#125;        public void findPartner() &#123;        agency.pair(person:this);   //与中介者交互    &#125;&#125;enum Sex &#123;    MALE, FEMALE;&#125;\n\nclass MarriageAgencyImpl implements MarriageAgency &#123;    List&lt;Person&gt; people = new ArrayList&lt;&gt;();    //女会员        public void register(Person person) &#123;        people.add(person);    &#125;        public void pair(Person person) &#123;        for (Person p : people) &#123;            if (p.age == person.requestAge &amp;&amp; p.sex != person.sex) &#123;                System.out.println(“配对成功“);            &#125;        &#125;    &#125;&#125;\n\n2.5 迭代器（Iterator）提供一种顺序访问聚合对象元素的方法，并且不暴露对象的内部表示。\n\n实现public interface Aggregate &#123;    Iterator createIterator();&#125;public class ConcreteAggregate implements Aggregate &#123;    private Integer[] items;    public ConcreteAggregate() &#123;        items = new Integer[10];        for (int i = 0; i &lt; items.length; i++) &#123;            items[i] = i;        &#125;    &#125;    @Override    public Iterator createIterator() &#123;        return new ConcreteIterator&lt;Integer&gt;(items);    &#125;&#125;\n\npublic interface Iterator&lt;Item&gt; &#123;    Item next();    boolean hasNext();&#125;public class ConcreteIterator&lt;Item&gt; implements Iterator &#123;    private Item[] items;    private int position = 0;    public ConcreteIterator(Item[] items) &#123;        this.items = items;    &#125;    @Override    public Object next() &#123;        return items[position++];    &#125;    @Override    public boolean hasNext() &#123;        return position &lt; items.length;    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Aggregate aggregate = new ConcreteAggregate();        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;\n\n2.6 备忘录模式（Memento）备忘录模式允许在不暴露对象内部细节的情况下保存和恢复对象之前的状态。\n\n\n实现class Document &#123;    private String content; //需要备份的数据        public Backup save() &#123;        return Backup(content);    &#125;        public void resume(Backup backup) &#123;        content = backup.content;    &#125;        public void change(String content) &#123;        this.content = content;    &#125;        public void print() &#123;        System.out.println(content);    &#125;&#125;\n\ninterface Memento &#123;    &#125;class Backup implements Memento &#123;    String content;        public Backup(String content) &#123;        this.content = content;    &#125;&#125;\n\nclass History &#123;    stack&lt;Backup&gt; backupStack = new Stack&lt;&gt;();        public void add(Backup backup) &#123;        backupStack.add(backup);    &#125;        public Backup getLastVersion() &#123;        return backupStack.pop();    &#125;&#125;\n\n2.7 状态模式（State）允许一个对象在其内部状态改变时改变他的行为，对象看起来似乎修改了他的类。状态模式是一种对象行为型模式。\n\n\n\n实现以张三为例，他在电子厂上班。他有多种状态，当状态不同时，他的行为不同。\nabstract class State &#123;    abstract void doWork();&#125;class Happy extends State &#123;    void doWork() &#123;        System.out.println(“积极主动”);    &#125;&#125;class Angry extends State &#123;    void doWork() &#123;        System.out.println(“暴躁易怒”);    &#125;&#125;class Sad extends State &#123;    void doWork() &#123;        System.out.println(“啥也不干”);    &#125;&#125;\n\nclass Context &#123;    private State state;        public void changeState(State state) &#123;        this.state = state;    &#125;        public void doSomething() &#123;        state.doWork();    &#125;&#125;\n\npublic class Client &#123;    public void static main(string[] args) &#123;        Context zhangsan = new Context();        zhangsan.changeState(new Happy());        zhangsan.doSomething();        zhangsan.changeState(new Sad());        zhangsan.doSomething();    &#125;&#125;\n\n2.8 策略模式（Strategy）定义一组算法，将每个算法都封装起来，并且使它们只见可以互换，策略模式让算法独立于使用它的客户变化而变化。\n\n与状态模式的比较如类图所示，状态模式和策略模式十分相似。不同点在于状态模式是通过状态转移来改变Context所组合的State对象，从而改变Context行为。而策略模式侧重点在于行为具体采用何种策略，并且可以灵活地更换不同的策略。\n实现public interface QuackBehavior &#123;    void quack();&#125;public class Quack implements QuackBehavior &#123;    public void quack() &#123;        System.out.println(“quack!”);    &#125;&#125;public class Squeak implements QuackBehavior&#123;    @Override    public void quack() &#123;        System.out.println(&quot;squeak!&quot;);    &#125;&#125;\n\npublic class Duck &#123;    private QuackBehavior quackBehavior;    public void performQuack() &#123;        if (quackBehavior != null) &#123;            quackBehavior.quack();        &#125;    &#125;    public void setQuackBehavior(QuackBehavior quackBehavior) &#123;        this.quackBehavior = quackBehavior;    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Duck duck = new Duck();        duck.setQuackBehavior(new Squeak());        duck.performQuack();        duck.setQuackBehavior(new Quack());        duck.performQuack();    &#125;&#125;\n\nsqueak!quack!\n\n2.9 模版方法模式（TemplateMethod）定义一个算法中操作的框架，而将一些步骤延迟到子类中。使得子类可以不改变这个算法的结构即可重定义该算法的某些特定步骤。\n\n实现以炒菜做饭为例子，Cooking中的Cook方法是算法的具体实现步骤，其中的某些步骤在父类中不做定义，而在具体子类再具体实现。\nabstract class Cooking &#123;    public abstract void step1();    public abstract void step2();    public void cook() &#123;        System.out.println(“做饭开始”);        step1();        step2();        System.out.println(“做饭结束”);    &#125;&#125;class CookingFood extends Cooking &#123;    public void step1() &#123;        System.out.println(“放鸡蛋和西红柿！”);    &#125;        public void step2() &#123;        System.out.println(“多放盐少放味精”);    &#125;&#125;\n\npublic class TemplateMethod &#123;    public static void main(String[] args) &#123;        Cooking cooking = new CookingFood();        cooking.cook();    &#125;&#125;\n\n2.10 访问者模式（Visitor）用于封装一些作用于某种数据结构中各元素的操作，它可以在不改变该数据结构的条件下定义作用于这些数据结构的新操作。\n实现interface Visitor &#123;    void visitCPU(CPU cpu);&#125;class UpdateVisitor implements Visitor &#123;    public void visitCPU(CPU cpu) &#123;        cpu.command += “:1+1=2”;    &#125;&#125;\n\nclass EggRobot &#123;    private CPU cpu;        public EggRobot() &#123;        this.cpu = new CPU(command:”记住1+1=1”);    &#125;        public void calc() &#123;        cpu.run();    &#125;        public void accept(Visitor vis) &#123;        cpu.accept(vis);    &#125;&#125;abstract class Hardware &#123;    String command;    public Hardware(String command) &#123;        this.command = command;    &#125;        public void run() &#123;        System.out.println(command);    &#125;        public abstract void accept(Visitor);&#125;class CPU extends Hardware &#123;    public CPU(String command) &#123;        super(command);    &#125;        public void accept(Visitor visitor) &#123;        visitor.visitCPU(this);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        EggRobot erDan = new EggRobot();        erDan.calc();        Visitor updatePack = new UpdateVisitor();        erDan.accept(updatePack);        erDan.calc();    &#125;&#125;\n\n\n\n3 结构型结构型模式是指将对象和类组装成一个更大的结构，同时保持结构的灵活和高效。\n3.1 适配器模式（Adapter）通过适配器将一个类的接口转换成另一个用户需要的接口。\n实现鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack 方法，而 Turkey 调用 gobble方法。\n要求将 Turkey 的 gobble 方法适配成 Duck 的 quack 方法，从而让火鸡冒充鸭子！\npublic interface Duck() &#123;    void quack();&#125;public interface Turkey() &#123;    void gobble();&#125;public class WildTurkey implements Turkey &#123;    @Override    public void gobble() &#123;        System.out.println(“gobble”);    &#125;&#125;//火鸡适配器，继承自Duck，但是用类内部火鸡对象覆写quack方法，让鸭子发出火鸡的声音public class TurkeyAdapter implements Duck &#123;    Turkey turkey;        public TurkeyAdapter(Turkey turkey) &#123;        this.turkey = turkey;    &#125;        @Override    public void quack() &#123;        System.out.println(“gobble”);    &#125;&#125;public class Client &#123;    public static void main(String[] arts) &#123;        Turkey turkey = new WildTurkey();        //来自火鸡适配器的鸭子，从发声的角度来说时假鸭子，真火鸡        Duck duck = new TurkeyAdapter(turkey);        duck.quack();    &#125;&#125;\n\n3.2 装饰器模式（Decorator）为对象（不是类）动态（非静态）的添加功能。\n说明所谓装饰，就是将带有新功能的装饰物套在某个对象身上，这样就不用修改其原来的类也能让其拥有新功能。与继承的区别在于：适配器是对对象的功能拓展，并且适配器是动态的二继承是静态的。\n实现以饮料和配料为例。\n设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。\n下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost 方法，外层类的 cost 方法调用了内层类的 cost 方法。\n//饮料接口，之后要用具体的配料来实现这个接口，可返回实现这个接口的饮料的对象public interface Beverage &#123;    double cost();&#125;public class DarkRoast implements Beverage &#123;    @Override    public double cost() &#123;        return 1;    &#125;&#125;public class HouseBlend implements Beverage &#123;    @Override    public double cost() &#123;        return 1;    &#125;&#125;public abstract class CondimentDecorator implements Beverage &#123;    protected Beverage beverage;&#125;public class Milk extends CondimentDecorator &#123;    public Milk(Beverage beverage) &#123;        this.beverage = beverage;    &#125;    @Override    public double cost() &#123;        return 1 + beverage.cost();    &#125;&#125;public class Mocha extends CondimentDecorator &#123;    public Mocha(Beverage beverage) &#123;        this.beverage = beverage;    &#125;    @Override    public double cost() &#123;        return 1 + beverage.cost();    &#125;&#125;\n\npublic class Client &#123;        public static void main(String[] arts) &#123;        Beverage beverage = new HouseBlend();        //添加抹茶配料，抹茶配料会返回        beverage = new Mocha(beverage);        beverage = new Milk(beverage);        System.out.println(beverage.cost()); // 3    &#125;&#125;\n\n3.3 桥接模式（Bridge）将抽象和实现分离开，使它们可以独立变化。\n成果是将继承关系转变为关联关系，可以将一个复杂类的不同类型的功能解耦出来，便于独立添加新功能。\n缺点是对于抽象思维能力要求比较高，需要熟知类的特点。\n实现RemoteControl 表示遥控器，指代 Abstraction。\nTV 表示电视，指代 Implementor。\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\npublic abstract class TV &#123;    public abstract void on();    public abstract void off();    public abstract void tuneChannel();&#125;public class Sony extends TV &#123;    @Override    public void on() &#123;        System.out.println(&quot;Sony.on()&quot;);    &#125;    @Override    public void off() &#123;        System.out.println(&quot;Sony.off()&quot;);    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;Sony.tuneChannel()&quot;);    &#125;&#125;public class RCA extends TV &#123;    @Override    public void on() &#123;        System.out.println(&quot;RCA.on()&quot;);    &#125;    @Override    public void off() &#123;        System.out.println(&quot;RCA.off()&quot;);    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;RCA.tuneChannel()&quot;);    &#125;&#125;public abstract class RemoteControl &#123;    protected TV tv;    public RemoteControl(TV tv) &#123;        this.tv = tv;    &#125;    public abstract void on();    public abstract void off();    public abstract void tuneChannel();&#125;public class ConcreteRemoteControl1 extends RemoteControl &#123;    public ConcreteRemoteControl1(TV tv) &#123;        super(tv);    &#125;    @Override    public void on() &#123;        System.out.println(&quot;ConcreteRemoteControl1.on()&quot;);        tv.on();    &#125;    @Override    public void off() &#123;        System.out.println(&quot;ConcreteRemoteControl1.off()&quot;);        tv.off();    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;ConcreteRemoteControl1.tuneChannel()&quot;);        tv.tuneChannel();    &#125;&#125;public class ConcreteRemoteControl2 extends RemoteControl &#123;    public ConcreteRemoteControl2(TV tv) &#123;        super(tv);    &#125;    @Override    public void on() &#123;        System.out.println(&quot;ConcreteRemoteControl2.on()&quot;);        tv.on();    &#125;    @Override    public void off() &#123;        System.out.println(&quot;ConcreteRemoteControl2.off()&quot;);        tv.off();    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;ConcreteRemoteControl2.tuneChannel()&quot;);        tv.tuneChannel();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());        remoteControl1.on();        remoteControl1.off();        remoteControl1.tuneChannel();        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());        remoteControl2.on();        remoteControl2.off();        remoteControl2.tuneChannel();    &#125;&#125;\n\n3.4 组合模式（Composite）将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合关系。\n组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。\n组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。\n\n实现public abstract class Component &#123;    protected String name;    public Component(String name) &#123;        this.name = name;    &#125;    public void print() &#123;        print(0);    &#125;    abstract void print(int level);    abstract public void add(Component component);    abstract public void remove(Component component);&#125;\n\npublic class Composite extends Component &#123;    private List&lt;Component&gt; child;    public Composite(String name) &#123;        super(name);        child = new ArrayList&lt;&gt;();    &#125;    @Override    void print(int level) &#123;        for (int i = 0; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(&quot;Composite:&quot; + name);        for (Component component : child) &#123;            component.print(level + 1);        &#125;    &#125;    @Override    public void add(Component component) &#123;        child.add(component);    &#125;    @Override    public void remove(Component component) &#123;        child.remove(component);    &#125;&#125;\n\npublic class Leaf extends Component &#123;    public Leaf(String name) &#123;        super(name);    &#125;    @Override    void print(int level) &#123;        for (int i = 0; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(&quot;left:&quot; + name);    &#125;    @Override    public void add(Component component) &#123;        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点    &#125;    @Override    public void remove(Component component) &#123;        throw new UnsupportedOperationException();    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Composite root = new Composite(&quot;root&quot;);        Component node1 = new Leaf(&quot;1&quot;);        Component node2 = new Composite(&quot;2&quot;);        Component node3 = new Leaf(&quot;3&quot;);        root.add(node1);        root.add(node2);        root.add(node3);        Component node21 = new Leaf(&quot;21&quot;);        Component node22 = new Composite(&quot;22&quot;);        node2.add(node21);        node2.add(node22);        Component node221 = new Leaf(&quot;221&quot;);        node22.add(node221);        root.print();    &#125;&#125;\n\nComposite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3\n\n3.5 外观模式（Facade）提供一个统一的接口，用于访问子系统中的一群接口，提供便利。\n缺点是违反了开闭原则，如果添加了新的子系统，需要修改Facade类的代码。\n\n\n实现以看电影为例子，看电影需要启动很多电器，在外观模式中提供一个方法统一启动这些电器。\npublic class SubSystem &#123;    public void turnOnTV() &#123;        System.out.println(“turnOnTV()”);    &#125;        public void setCD(String cd) &#123;        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);    &#125;        public void startWatching()&#123;        System.out.println(&quot;startWatching()&quot;);    &#125;&#125;\n\npublic class Facade &#123;    private SubSystem subSys = new SubSystem();        public void watchMovie() &#123;        subSys.turnOnTV();        subSys.setCD(“巡礼之年”);        subSys.startWatching();    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Facade facade = new Facade();        facade.watchMovie();    &#125;&#125;\n\n3.6 享元模式（Flyweight）利用共享的方式来支持大量的细粒度对象，这些对象一部分内部状态是相同的。\n\n实现public interface Flyweight &#123;    void doOperation(String exState);&#125;\n\npublic class ConcreteFlyweight implements Flyweight &#123;    private String intrinsicState;    public ConcreteFlyweight(String intrinsicState) &#123;        this.intrinsicState = intrinsicState;    &#125;    @Override    public void doOperation(String extrinsicState) &#123;        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);    &#125;&#125;\n\npublic class FlyweightFactory &#123;        private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();        Flyweight getFlyweight(String inState) &#123;        if (!flyweights.containsKey(inState) &#123;            Flyweight fw = new ConcreteFlyweight(inState);            flyweights.put(inState, fw);        &#125;        return flyweights.get(inState);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        FlyweightFactory factory = new FlyweightFactory();        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);        flyweight1.doOperation(&quot;x&quot;);        flyweight2.doOperation(&quot;y&quot;);    &#125;&#125;\n\nObject address: 1163157884IntrinsicState: aaExtrinsicState: xObject address: 1163157884IntrinsicState: aaExtrinsicState: y\n\n3.7 代理模式（Proxy）代理模式为其他对象提供一种代理来控制对这个对象的访问。\n共有4种代理模式：远程代理，虚拟代理，保护代理和智能代理。\n虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。\n实现以下是一个虚拟代理的实现，模拟了图片延迟家在的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。\npublic interface Image &#123;    void showImage();&#125;\n\npublic class HighResolutionImage implements Image &#123;    private URL imageURL;    private long startTime;    private int height;    private int width;    public int getHeight() &#123;        return height;    &#125;    public int getWidth() &#123;        return width;    &#125;    public HighResolutionImage(URL imageURL) &#123;        this.imageURL = imageURL;        this.startTime = System.currentTimeMillis();        this.width = 600;        this.height = 600;    &#125;    public boolean isLoad() &#123;        // 模拟图片加载，延迟 3s 加载完成        long endTime = System.currentTimeMillis();        return endTime - startTime &gt; 3000;    &#125;    @Override    public void showImage() &#123;        System.out.println(&quot;Real Image: &quot; + imageURL);    &#125;&#125;\n\npublic class ImageProxy implements Image &#123;    private HighResolutionImage highResolutionImage;    public ImageProxy(HighResolutionImage highResolutionImage) &#123;        this.highResolutionImage = highResolutionImage;    &#125;    @Override    public void showImage() &#123;        while (!highResolutionImage.isLoad()) &#123;            try &#123;                System.out.println(&quot;Temp Image: &quot; + highResolutionImage.getWidth() + &quot; &quot; + highResolutionImage.getHeight());                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        highResolutionImage.showImage();    &#125;&#125;\n\npublic class ImageViewer &#123;    public static void main(String[] args) throws Exception &#123;        String image = &quot;http://image.jpg&quot;;        URL url = new URL(image);        HighResolutionImage highResolutionImage = new HighResolutionImage(url);        ImageProxy imageProxy = new ImageProxy(highResolutionImage);        imageProxy.showImage();    &#125;&#125;","categories":["设计模式"],"tags":["设计模式"]},{"title":"数据结构与算法","url":"/2021/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"数据范围反推复杂度及算法内容一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在∼为最佳。\n下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：\n\n，指数级别。dfs+剪枝，状态压缩dp。\n，。floyd，dp，高斯消元。\n，，。dp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford。\n，。块状链表，分块，莫队。\n，。各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，spfa，求凸包，求半平面交，二分，CDQ分治，整体二分。\n，和常数较小的 。单调队列、 hash、双指针扫描、并查集，kmp、AC自动机。常数比较小的 的做法：sort、树状数组、heap、dijkstra、spfa。\n，。双指针扫描、kmp、AC自动机、线性筛素数。\n，。判断质数。\n，。最大公约数，快速幂。\n，。高精度加减乘除。\n，。k表示位数，高精度加减，FFT/NTT。\n\n作者：yxc链接：https://www.acwing.com/blog/content/32/来源：AcWing\n1 基础算法1.1 快速排序在一次排序中找到一个位置，通过左右交换的方式使得该位置之前全部小于这个位置上的数（以升序为例），之后的数全部大于该位置上的数。由此确定序列中第一个数。然后以该位置为分界点分为左右两个序列，分别递归即可确定整个序列的排序。\n因为二分且递归，平均时间复杂度为。\n\n\n关于为什么i和j要取l-1和r+1：使用的是do while循环，每次先移动，再交换。do while和l-1，r+1的写法其实都有关边界，关于边界问题，建议直接背下来。\n为什么x要选取中间点，选取左边界和右边界也是可以的，只是中间点更加不容易出现最坏情况，所以推荐采用这种写法。\n\n\nvoid quickSort(int a[], int l, int r) {    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = a[l+r&gt;&gt;1];    while (i &lt; j) {        do i++; while (a[i] &lt; x);        do j--; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    }    quickSort(a, l, j);    quickSort(a, j+1, r);}\n\n1.2 归并排序归并排序的思想是：将序列中排好序的归并，得到一个新的更长的排好序的序列。最开始的序列长度为1（长度为1的序列一定排好序），逐渐扩大为2，再4，以此类推。\n因为序列长度由大到小，所以应该先递归，再进行其他操作。代码中的i表示的归并序列A的下标，j表示的是归并序列B的下标，k表示temp数组下标。temp数组的存在是必要的，用于存放归并好的A+B序列，并在结束归并后必须返还给原a数组，因为接下来的归并需要用到归并好的序列。\n归并排序稳定，时间复杂度为。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], n, temp[N];void mergeSort(int l, int r) {    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    mergeSort(l, mid);    mergeSort(mid + 1, r);        int i = l, j = mid + 1, k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= r) {        if (a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[j++];    }    while (i &lt;= mid) temp[k++] = a[i++];    while (j &lt;= r) temp[k++] = a[j++];        for (i = l, k = 0; i &lt;= r; i++, k++) a[i] = temp[k];}int main() {    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    mergeSort(0, n - 1);    for (int i = 0; i &lt; n; i++) printf(\"%d \", a[i]);        return 0;}\n\n1.3 二分二分有以下两种情况，两种情况的选择是先写check条件，根据条件判断r = mid或者r = mid + 1，再确定mid是否需要加1。\n版本1\n当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1，计算mid时不需要加1。\nint bsearch_1(int l, int r) {    while (l &lt; r) {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    return l;}\n\n版本2\n当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid，此时为了防止死循环，计算mid时需要加1。\nint bsearch_2(int l, int r) {    while (l &lt; r) {        int mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}\n\n对本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置，找不到就输出-1 -1。\n这里很明显需要求解两次二分，一次是某元素出现的起始位置，一次是终止位置，以下解法刚好演示了上述整数二分的两种可能。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, q, a[N];int main() {    scanf(\"%d%d\", &amp;n, &amp;q);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    while (q--) {        int x;        scanf(\"%d\", &amp;x);                int l = 0, r = n - 1;        while (l &lt; r) {            int mid = l + r &gt;&gt; 1;            if (a[mid] &gt;= x) r = mid;            else l = mid + 1;        }        if (a[l] != x) printf(\"-1 -1\\n\");        else {            printf(\"%d \", l);            int r = n - 1;            while (l &lt; r) {                int mid = l + r + 1 &gt;&gt; 1;                if (a[mid] &lt;= x) l = mid;                else r = mid - 1;            }            printf(\"%d\\n\", l);        }            }        return 0;}\n\n1.4 高精度\n高精度数据一般使用数组存储。\n\n1.4.1 高精度加法给定两个正整数（不含前导 0），计算它们的和。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) {    if (a.size() &lt; b.size()) return add(b, a);    int t = 0;    vector&lt;int&gt; res;    for (int i = 0; i &lt; a.size() || t; i++) {        t += a[i];        if (i &lt; b.size()) t += b[i];        res.push_back(t % 10);        t /= 10;    }    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    vector&lt;int&gt; a, b, res;    string s1, s2;    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.length() - 1; i &gt;=0; i--)        a.push_back(s1[i] - '0');    for (int i = s2.length() - 1; i &gt;=0; i--)        b.push_back(s2[i] - '0');    res = add(a, b);    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    return 0;}\n\n1.4.2 高精度减法给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) {    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i++) {        t = a[i] - t;        if (i &lt; b.size()) t -= b[i];        c.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    }    while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back();    return c;}int main() {    bool flag = true;   //是否a&gt;b    vector&lt;int&gt; a, b;    string s1 = \"\", s2 = \"\";    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.length() - 1; i &gt;= 0; i--)         a.push_back(s1[i] - '0');    for (int i = s2.length() - 1; i &gt;= 0; i--)         b.push_back(s2[i] - '0');    if (a.size() &lt; b.size()) {        flag = false;    } else if (a.size() == b.size()) {        for (int i = a.size() - 1; i &gt;= 0; i--) {            if (a[i] &lt; b[i]) {                flag = false;                break;            } else if (a[i] &gt; b[i]) break;        }    }    vector&lt;int&gt; res;    if (flag) {        res = sub(a, b);    } else {        res = sub(b, a);        cout &lt;&lt; \"-\";    }    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    return 0;}\n\n1.4.3 高精度乘法给定两个非负整数（不含前导 0）A和B，请你计算A×B的值。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b) {    vector&lt;int&gt; res;    int t = 0;    for (int i = 0; i &lt; A.size() || t; i++) {        if (i &lt; A.size()) t += b * A[i];        res.push_back(t % 10);        t /= 10;    }    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    string s;    int b;    vector&lt;int&gt; A, res;    cin &gt;&gt; s &gt;&gt; b;    for (int i = s.length() - 1; i &gt;= 0; i--)         A.push_back(s[i] - '0');    res = mul(A, b);    for (int i = res.size() - 1; i &gt;= 0; i--)         cout &lt;&lt; res[i];    return 0;}\n\n1.4.4 高精度除法给定两个非负整数（不含前导0）A和B，请你计算A/B的商和余数。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) {    r = 0;    vector&lt;int&gt; res;    for (int i = A.size() - 1; i &gt;= 0; i--) {        r = r * 10 + A[i];        res.push_back(r / b);        r %= b;    }    reverse(res.begin(), res.end());    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    string s;    int b, r;    vector&lt;int&gt; A, res;    cin &gt;&gt; s &gt;&gt; b;    for (int i = s.length() - 1; i &gt;= 0; i--)        A.push_back(s[i] - '0');    res = div(A, b, r);    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;    return 0;}\n\n1.5 前缀和1.5.1 一维前缀和\n输入一个长度为 n 的整数序列。接下来再输入 m 个询问，每个询问输入一对 l, r。对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。n，m可能比较大。\n\n适用于需要大量计算序列中某一部分和的情况。\n维护一个 s数组，其中s[i]表示的含义是前 i 个数据的和。求第 l 到第 r 个数的和时，只需要S[r] - s[l - 1]即可。\n#include &lt;iostream&gt;using namespace std;const int maxn = 1e5 + 10;int a[maxn], s[maxn];int main() {    int n, m, l, r;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;a[i]);        s[i] = s[i-1] + a[i];    }    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;l, &amp;r);        int res = s[r] - s[l-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.5.2 二维前缀和\n输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1, y1, x2, y2 表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。\n\ns[i][j]表示的是从 0, 0 到 i, j 的矩形中所有数的和。\n输入时s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];。\n输出时int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];。\n#include &lt;iostream&gt;using namespace std;int a[1010][1010], s[1010][1010];int main() {    int n, m, q;    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            scanf(\"%d\", &amp;a[i][j]);            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];        }    }    for (int i = 0; i &lt; q; i++) {        int x1, y1, x2, y2;        scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2);        int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.6 差分1.6.1 一维差分\n输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l, r, c, 表示将序列中 [l, r] 之间的每个数加上 c。请你输出进行完所有操作后的序列。n, m可能会很大。\n\n定义一个b数组，。理所应当b[1] = a[1]。\n由差分数组的定义可知，当批量修改某些连续的a[i]值时，只需对 b 数组两个数做修改，假设修改区间为[l, r]，那么只需要修改b[l]和b[r+1]即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int a[N], b[N];int main() {    int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;a[i]);        b[i] = a[i] - a[i-1];    }    while (m--) {        int l, r, c;        scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c);        b[l] += c;        b[r+1] -= c;    }    for (int i = 1; i &lt;= n; i++) {        a[i] = a[i-1] + b[i];        printf(\"%d \", a[i]);    }        return 0;}\n\n1.6.2 差分矩阵\n输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1, y1, x2, y2, c，其中 (x1, y1) 和 (x2, y2)  表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 c。请你将进行完所有操作后的矩阵输出。\n\n可以看成二维前缀和的逆运算，a[i][j] 等于b数组中从(0, 0)到(i, j)的和。b 数组的影响范围是其右下角。\n\n\n#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c) {    b[x1][y1] += c;    b[x2+1][y1] -= c;    b[x1][y2+1] -= c;    b[x2+1][y2+1] += c;}int main() {    int n, m, q;    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            scanf(\"%d\", &amp;a[i][j]);            insert(i, j, i, j, a[i][j]);        }    }    while (q--) {        int x1, y1, x2, y2, c;        scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);        insert(x1, y1, x2, y2, c);    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + b[i][j];            printf(\"%d \", a[i][j]);        }        printf(\"\\n\");    }    return 0;}\n\n1.7 位运算if (k &amp; 1)表示k二进制的最后一位是否是1，是的话返回true。求n二进制的第k位数字：n &gt;&gt; k &amp; 1 返回n的最后一位二进制1(十进制)：n &amp; -n 或者直接用 lowbit(n)\n\n1.8 离散化离散化问题解决区间庞大但是实际使用的数不多的情况。思路是将使用到的区间点进行映射储存起来，使用时再查找。\n该代码涉及到的知识点包括二分，前缀和，离散化，比较综合，可以多看。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;  using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10;int n, m;int a[N], s[N]; //分别存储离散化后的下标对应数和前缀和vector&lt;int&gt; alls;   //离散之前的所有下标vector&lt;PII&gt; add, query; //表示添加和查询int find(int x) {    int l = 0, r = alls.size() - 1;    while (l &lt; r) {        int mid = l + r &gt;&gt; 1;        if (alls[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r + 1;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        int x, c;        scanf(\"%d%d\", &amp;x, &amp;c);        alls.push_back(x);        add.push_back({x, c});    }    for (int i = 0; i &lt; m; i++) {        int l, r;        scanf(\"%d%d\", &amp;l, &amp;r);        alls.push_back(l);        alls.push_back(r);        query.push_back({l, r});    }        sort(alls.begin(), alls.end());    alls.erase(unique(alls.begin(), alls.end()), alls.end());        for (auto item : add) {        int x = find(item.first);        a[x] += item.second;    }    for (int i = 1; i &lt;= alls.size(); i++) {        s[i] = s[i-1] + a[i];    }    for (auto item : query) {        int l = find(item.first);        int r = find(item.second);        int res = s[r] - s[l-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.9 区间合并v[i].second = max(v[i].second, v[i-1].second);要用整个区间的最靠右的数值进行比较，以[1,9]，[2,3]，[4,5]来举例子，实际上这是一个区间，但是两两比较答案为2。\npair的默认sort排序规则是按从小到大顺序先排first，相等时再排second，这里正符合我们的预期。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;int main() {    int n;    scanf(\"%d\", &amp;n);    vector&lt;pii&gt; v;    for (int i = 0; i &lt; n ; i++) {        int l, r;        scanf(\"%d%d\", &amp;l, &amp;r);        v.push_back({l, r});    }        sort(v.begin(), v.end());        int res = n;        for (int i = 1; i &lt; n; i++) {        if (v[i].first &lt;= v[i-1].second) {            res--;            v[i].second = max(v[i].second, v[i-1].second);        }    }        cout &lt;&lt; res;        return 0;}\n\n2 数据结构2.1 单链表2.1.1 指针 + 结构体此处为含头指针的单向链表，实现了插入，删除，查找操作。\n做算法题目时不推荐用这种方法，因为要用到new字符，十分花时间，有很大可能会TLE，推荐用下面的数组方法。\nstruct node {    int data;    node* next;};node *head = new node;void insert(int pos, int x) {    node *p = head;    for (int i = 0; i &lt; pos; i++) {        p = p-&gt;next;       }    node *q = new node;    q-&gt;data = x;    q-&gt;next = p-&gt;next;    p-&gt;next = q;}void del(int pos) {    node *p = head;    for (int i = 0; i &lt; pos; i++) {        p = p-&gt;next;    }    p-&gt;next = p-&gt;next-&gt;next;}\n\n2.1.2 数组数组维护单链表的关键在于要存储每个节点的下标的值，ne[N]的作用就在此。此外head是一个头节点，本身并不存储任何数值，但是指向第一个存储数值的节点，head值为-1，第一个值节点下标为0。\n关于idx的必要性：idx表示现在插入了多少个数值，即使删除了部分节点，其idx依然可以表示它插入的顺序，这在某些题目中很有用。\n// head表示头节点下标，idx表示当前节点下标，e是当前的值，ne是下一个的下标const int N = 1e5 + 10;int e[N], ne[N], idx, head;// 初始化，无节点所以head指向-1，如果当前要插入节点，其下标应该为0// 所以idx为0void init() {    head = -1;    idx = 0;}// head储存第一个节点下标void insertHead(int x) {    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;}void insert(int k, int x) {    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;}void del(int k) {    ne[k] = ne[ne[k]];}\n\n2.2 双链表对于任何链表题目来说，都建议首先划出图形辅助理解。双链表的难点在于插入操作，插入操作需要操作四条线，别忘记了操作完成之后idx++。\n谨记访问上下节点是l[k]和r[k]，不是k-1或者k+1。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int e[N], l[N], r[N], idx;// 不定义头节点和尾节点，0表示左节点，1表示右节点void init() {    l[1] = 0, r[0] = 1;    idx = 2;}// 在下标是k的节点的右边，插入xvoid insert(int k, int x) {    e[idx] = x;    r[idx] = r[k];    l[idx] = k;    l[r[k]] = idx; // 这两行不可以调换位置    r[k] = idx;    idx++;}// 删除下标为k的节点void del(int k) {    l[r[k]] = l[k];    r[l[k]] = r[k];}int main() {    init();        int m, k, x;    cin &gt;&gt; m;    for (int i = 0; i &lt; m; i++) {        string op;        cin &gt;&gt; op;        // 记住下标是从2开始的，所以要加1        if (op == \"L\") {            cin &gt;&gt; x;            insert(0, x);        } else if (op == \"R\") {            cin &gt;&gt; x;            insert(l[1], x);        } else if (op == \"D\") {            cin &gt;&gt; k;            del(k + 1);        } else if (op == \"IL\") {            cin &gt;&gt; k &gt;&gt; x;            insert(l[k + 1], x);        } else {            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1, x);        }    }        for (int i = r[0]; i != 1; i = r[i])        cout &lt;&lt; e[i] &lt;&lt; \" \";        return 0;}\n\n2.3 栈模拟计算器#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;stack&gt;using namespace std;//存储运算数 运算符stack&lt;int&gt; num;stack&lt;char&gt; op;//建立映射来判断运算优先级unordered_map&lt;char, int&gt; pr = {    {'+', 1}, {'-', 1} , {'*', 2}, {'/', 2}};//模拟一次算术操作void eval(){    int b = num.top(); num.pop();    int a = num.top(); num.pop();    char opt = op.top(); op.pop();        int x;    if (opt == '+') x = a + b;    else if (opt == '-') x = a - b;    else if (opt == '*') x = a * b;    else if (opt == '/') x = a / b;        num.push(x);}int main(){    string str;    cin &gt;&gt; str;    for(int i = 0; i &lt; str.size(); i++){        char c = str[i];        //读入运算数        if(isdigit(c)){            int j = i, x = 0;            while(j &lt; str.size() &amp;&amp; isdigit(str[j])){                //j++ 迭代不能忘                 x = x * 10 + str[j++] - '0';            }            num.push(x);            //由于每轮循环有i++,我们需要倒指向最后一个数字            i = j - 1;        } else if( c == '(' ){            //标记一下，括号内数据            op.push(c);        } else if( c == ')' ){            //括号的优先级，先算括号            while( op.size() &amp;&amp; op.top() != '(' ) eval();            //左括号可以弹出            op.pop();        } else{            //得先把乘除法算了再算加减            //这里必须得带等于号 我们这题都是正整数计算            // 0 - 5 + 3             //如果不算，上式会被错误计算成 -8            while( op.size() &amp;&amp; pr[op.top()] &gt;= pr[c]) eval();            //压入新运算符            op.push(c);        }    }    //清理低优先级操作    while(op.size()) eval();    cout &lt;&lt; num.top() &lt;&lt; endl;        return 0;}\n\n2.4 单调栈最常见的情况就是求解序列中每个数左边最靠近它且最小的数。\n答案要求是尽可能靠近并且小于它，对于任意其左边某个值x，x左边所有大于等于x的值都没有意义，所以维护的栈必定时刻单调递增。\n只需不断将栈顶元素与当前值比较即可，st.top() &gt;= temp就弹出。\n#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        int temp;        cin &gt;&gt; temp;        while (!st.empty() &amp;&amp; st.top() &gt;= temp) st.pop();        if (st.empty()) cout &lt;&lt; -1 &lt;&lt; \" \";        else cout &lt;&lt; st.top() &lt;&lt; \" \";        st.push(temp);    }        return 0;}\n\n2.5 单调队列最常见问题就是求滑动窗口的最大最小值，以下即为滑动窗口问题。\n推荐使用数组写法，因为数组写法既可以操控队列头，还可以操纵队列尾，这道题目中二者都要用。所以stl中的queue是无法胜任的。不会数组写法的话也可以用deque。\n假设要访问一个滑动窗口的最小值，那么对于某个值来说，假设它更小一些，那么在它之前的所有比它大的值都没有意义，因为它们更加早出窗口，而且更大。所以可以时刻维持一个单调递增的队列，最大值镜像即可。\nif (!minq.empty() &amp;&amp; minq.front() &lt; i - k + 1) minq.pop_front();这句代码不可省略，作用是维系滑动窗口的大小。\nwhile循环处即是在维护队列的单调性，注意到此处用上了pop_bcak()，queue容器是没有该操作的。\n还有至关重要的一点是，队列中存储的是最小值or最大值的下标。\n#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;const int N = 1e6 + 10;int a[N];deque&lt;int&gt; minq, maxq;int main() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    for (int i = 0; i &lt; n; i++) {        if (!minq.empty() &amp;&amp; minq.front() &lt; i - k + 1)             minq.pop_front();        while (!minq.empty() &amp;&amp; a[i] &lt;= a[minq.back()])             minq.pop_back();        minq.push_back(i);        if (i &gt;= k - 1) printf(\"%d \", a[minq.front()]);    }    cout &lt;&lt; endl;    for (int i = 0; i &lt; n; i++) {        if (!maxq.empty() &amp;&amp; maxq.front() &lt; i - k + 1)             maxq.pop_front();        while (!maxq.empty() &amp;&amp; a[i] &gt;= a[maxq.back()])             maxq.pop_back();        maxq.push_back(i);        if (i &gt;= k - 1) printf(\"%d \", a[maxq.front()]);    }        return 0;}\n\n2.6 KMPKMP很难，最好天天练习，达到任何时候3分钟之内能将以下模版默写出来就算过关。\nne[i]表示p[i]之前的字符串的最长公共前后缀。\n为什么要求这个ne数组呢？因为KMP算法优化的原理就是当匹配到不相等的那一位时，通过已经得到的长串的后缀和短串的前缀匹配成功的最长长度，来确定短串的移动位置，而不是傻傻地让长串向下移动一个字符并让短串从头开始匹配。\nKMP的重点在于求ne数组，ne数组可以通过递推的方式求：如果p[ne[i-1]] = p[i - 1]，则说明ne[i] = ne[i - 1] + 1，别忘记了ne表示的是最长公共前后缀。如果不相等，则不断使j = ne[j]，直到相等为止。如果直到j = 0为止还是不相等，则判断p[0]和p[i - 1]的是否相等来决定ne[i]是0或1。\n为什么可以用上述求法，原理很复杂，来看这个解析。\n得到的ne虽然表示的是p字符串的最长前后缀匹配长度，但是因为这一段长度实际也是p和s匹配上的子字符串，所以具有传递性，也就是说，ne[i]实际可以表示最长的p字符串前缀和s字符串后缀相等的长度。\nne[0] = ne[1] = 0;这句代码是固定的，任何情况下都对，别忘记写。\nwhile循环中为什么要判断j是否为0？因为当j = 0时，ne[j] = 0，如果不判断的话会进入死循环。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s, p;    // s是长串，p是短串int n, m;int ne[N];  // ne[i]表示p字符串的最长公共前后缀int main() {    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;    ne[0] = 0;    ne[1] = 0; // 前后缀长度要小于字符串长度    for (int i = 2; i &lt; n + 1; i++) {        int j = ne[i - 1];        while (j &amp;&amp; p[j] != p[i - 1]) j = ne[j];        if (j != 0) ne[i] = j + 1;        else {            if (p[j] == p[i - 1]) ne[i] = 1;            else ne[i] = 0;        }    }    for (int i = 0, j = 0; i &lt; m; i++) {        while (j &amp;&amp; s[i] != p[j]) j = ne[j];        if (s[i] == p[j]) j++;        if (j == n) {            cout &lt;&lt; i - j + 1 &lt;&lt; \" \";        }    }        return 0;}\n\n2.7 并查集2.7.1 并查集现在有n个数，要进行m个操作，操作有两种，分别是M a b，将编号a和b的两个数合并入一个集合。Q a b，查询编号a和b的两个数是否在一个集合内。对于每一个Q查询，返回一个查询结果，YES或者NO。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, father[N];int find(int a) {   // 路径压缩    int x = a;    while (a != father[a]) a = father[a];    while (x != father[x]) {        int z = x;        x = father[x];        father[x] = a;    }    return a;}void merge(int a, int b) {    int fa = find(a), fb = find(b);    if (fa != fb) father[fa] = fb;}int main() {    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        father[i] = i;    }    while (m--) {        char c;        int a, b;        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;        if (c == 'M') merge(a, b);        else {            if (find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }        return 0;}\n\n2.7.2 带权并查集#include &lt;iostream&gt;using namespace std;const int N = 5e4 + 10;int p[N], d[N];  int find(int x) {    if (p[x] != x) {        int u = find(p[x]); // u是祖宗，在d[x]更新前，p[x]还不能变成祖宗        d[x] += d[p[x]];        p[x] = u;    }    return p[x];}int main() {    int n, k, cnt = 0;    scanf(\"%d%d\", &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++) {        p[i] = i;        d[i] = 0;    }    while (k--) {        int t, x, y;        scanf(\"%d%d%d\", &amp;t, &amp;x, &amp;y);        if (x &gt; n || y &gt; n) cnt++;        else {            int px = find(x), py = find(y);            if (t == 1) {                if (px == py &amp;&amp; (d[x] - d[y]) % 3) cnt++;                else if (px != py) {                    p[px] = py;                    d[px] = d[y] - d[x];                }            } else {                if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) cnt++;                else if (px != py) {                    p[px] = py;                    d[px] = d[y] + 1 - d[x];                }            }        }    }    cout &lt;&lt; cnt &lt;&lt; endl;        return 0;}\n\n2.8 堆2.8.1 模拟堆堆是完全二叉树，完全二叉树有个很棒的性质：假设某个根节点下标为x，那么其左子树下标为2x，右子树为2x + 1。这样用数组来储存读取起来很方便。\n模拟堆主要实现五个操作（以小根堆为例）：\n\n插入一个数\n求集合当中的最小值\n删除最小值\n删除任意一个元素\n修改任意一个元素\n\n这五个操作都可以用up和down两个方法来实现。down函数的作用是将某个不符合堆定义的节点不断下沉，直到其到达合适的位置，up同理。时间复杂度为。\n\nvoid down(int u) {    int t = u;    if (u * 2 &lt;= cur_size &amp;&amp; h[t] &gt; h[u * 2])        t = u * 2;    if (u * 2 + 1 &lt;= cur_size &amp;&amp; h[t] &gt; h[u * 2 + 1])        t = u * 2 + 1;    if (u != t) {        swap(h[u], h[t]);        down(t);    }}void up(int u) {    if (u / 2 &gt; 0 &amp;&amp; h[u] &lt; h[u / 2]) {        swap(h[u], h[u / 2]);        up(u / 2);    }}\n\n\n2.9 哈希表2.9.1 模拟散列表核心思路是将庞大的区间离散然后解决冲突问题，之前的离散化过程可以看作哈希的一种特殊情况——保序的离散化。\n根据解决冲突方式的不同分为开放寻址法和拉链法，下面代码为拉链法。拉链法原理是采用邻接表，每一个vector储存所有产生的值，例如说1e5 + 4和2e5 + 7离散值相同，都为1，则共同存放在v[1]中。\n为什么N取1e5 + 3而不是从前的1e5 + 10。1e5 + 3是大于1e5的最小质数，选择质数能使冲突的次数尽可能少，降低时间复杂度。\nint k = (x % N + N) % N这句代码是为了解决cpp中负数取模的问题。在数学上任何数取模都为正数，但是cpp中是负数。这句代码具有通用性，建议记下来。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 3;vector&lt;int&gt; v[N];void insert(int x) {    int k = (x % N + N) % N;    v[k].push_back(x);}bool find(int x) {    int k = (x % N + N) % N;    for (int i = 0; i &lt; v[k].size(); i++) {        if (x == v[k][i]) return true;    }    return false;}int main() {    int n, x;    cin &gt;&gt; n;    while (n--) {        char c;        cin &gt;&gt; c &gt;&gt; x;        if (c == 'I') {            insert(x);        } else {            if (find(x)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }        return 0;}\n\n2.9.2 字符串哈希字符串哈希功能十分强大，甚至有时候比KMP更强。\n主要思路是将字符转化成P进制的数字，经验表明当P取131或13331时冲突的概率十分十分小，所以可以将转换前后看作一一对应。\n转换后的数字可能非常大，要用unsigned long long存储，使用ull依然可能溢出，但是不用担心，溢出后会自动取余。\np[N]用来存储P的次方，因为cpp中写次方稍微麻烦一点，这种写法可以学习一下。\nh[r] - h[l - 1] * p[r - l + 1]这句话像前缀和的写法，其中r - l + 1是长度差。\n#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;const int N = 1e5 + 10; const int P = 131;  // 131为经验值，记住// 溢出就可取余ull h[N], p[N]; // h[N]存储转换后的数，p[N]存储P的n次方ull get(int l, int r) {    return h[r] - h[l - 1] * p[r - l + 1];}int main() {    int n, m;    string str;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str;        p[0] = 1;    for (int i = 1; i &lt;= n; i++) {        p[i] = p[i - 1] * P;        h[i] = h[i - 1] * P + str[i-1];   // 自动获取字符的ascii值    }        while (m--) {        int l1, r1, l2, r2;        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;        if (get(l1, r1) == get(l2, r2)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;        else cout &lt;&lt; \"No\" &lt;&lt; endl;    }        return 0;}\n\n2.10 Trie\nTrie树是用来高效地存储和查找字符串集合的数据结构。\n\n\n\n\n\n题目描述：维护一个字符串集合，支持两种操作：I x向集合中插入一个字符串x；Q x询问一个字符串在集合中出现了多少次。\nTrie树中有个二维数组son[N][26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1][0] = 2表示1结点的一个值为a的子结点为结点2。如果son[1][0] = 0，则意味着没有值为a子结点。这里的son[N][26]相当于链表中的ne[N]。\n从y总给出的代码可以看出，idx的操作总是idx++，这就保证了不同的idx值对应不同的结点。因此可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int son[N][26], cnt[N], idx; // son[1][0] = 2表示第一条子树的a下一个节点为2void insert(string s) {    int p = 0;    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u]) son[p][u] = ++idx;        p = son[p][u];    }    cnt[p]++;}int query(string s) {    int p = 0;    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    }    return cnt[p];}int main() {    int n;    cin &gt;&gt; n;    while (n--) {        string c, s;        cin &gt;&gt; c &gt;&gt; s;        if (c == \"I\") insert(s);        else cout &lt;&lt; query(s) &lt;&lt; endl;    }        return 0;}\n\n3 贪心3.1 区间贪心3.1.1 区间不相交记住是按右端点从小到大排序（也可以按左端点从大到小排序）。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;bool cmp(pii a, pii b) {    return a.second &lt; b.second;}int main() {    int n, res = 1;    cin &gt;&gt; n;    vector&lt;pii&gt; vp;    for (int i = 0; i &lt; n; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    int end = vp[0].second;    for (int i = 1; i &lt; n; i++) {        if (end &lt; vp[i].first) {            res++;            end = vp[i].second;        }    }    cout &lt;&lt; res;    return 0;}\n\n3.1.2 区间选点同上，如果都是闭区间问题的话代码完全相同。\n3.1.3 区间分组heap用来维护所有组的最大右端点，top()值表示的是所有最大右端点中最小的值，如果某个区间的左端点甚至小于等于这个最小值，那么说明它一定不能放进该组内，必须开一个新组heap.push(el.second);。\n如果一个区间的左端点比最小组的右端点要大，则放在该组中。heap.pop(), heap.push(el.second);。\n每组去除右端点最小的区间，只保留一个右端点较大的区间，这样heap有多少区间，就有多少组。\n时间复杂度是。\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; vp;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;bool cmp(pii a, pii b) {    return a.first &lt; b.first;}int main() {    int n, x, y;    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    for (int i = 0; i &lt; n; i++) {        pii el = vp[i];        if (heap.empty() || heap.top() &gt;= el.first)            heap.push(el.second);        else {            heap.pop();            heap.push(el.second);        }    }    cout &lt;&lt; heap.size();        return 0;}\n\n3.1.4 区间覆盖区间覆盖问题是指给定一个若干个闭区间区间，问其中至少选择多少个才能将某个给定的闭区间覆盖。\n核心思路是：\n\n按左端点从小到大排序（我们期望找到的区间应该是重叠长度尽可能少的，按这种排序方式符合我们的要求，甚至找到正好重叠的，极度满足强迫症）\n从前往后枚举找到左端点小于start并且end最大的区间\n用end更新start\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; vp;bool cmp(pii a, pii b) {    return a.first &lt; b.first;}int main() {    int st, ed, n, res = 0;    scanf(\"%d%d%d\", &amp;st, &amp;ed, &amp;n);    for (int i = 0; i &lt; n; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    bool flag = false;    for (int i = 0; i &lt; n; i++) {        int j = i, r = -2e9;        while (j &lt; n &amp;&amp; vp[j].first &lt;= st) {            r = max(r, vp[j].second);            j++;        }        if (r &lt; st) {   // 出现断层或者所有区间小于st            flag = false;            break;        }        res++;        if (r &gt;= ed) {            flag = true;            break;        }        i = j - 1;  // 那些end没有vp[j]大的都无用        st = r;    }    if (!flag) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n这里再来谈一个容易错的地方，一开始r &lt; st的判断我是这样写的：\nif (r &lt; st) {    cout &lt;&lt; -1 &lt;&lt; endl;    return 0;}\n\n这样写是会报错的，无法通过以下用例\n1 52-1 32 4\n\n后来改成以下代码就成功通过了，原因是成功的判断条件只有一个，那就是r &gt;= ed，哪怕是正常结束循环也可能无法覆盖，所以需要添加一个flag来判断成功与否。\nif (r &lt; st) {    flag = false;    break;}\n\n3.2 推公式\nN只奶牛决定叠罗汉。表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。\n\n这道题的贪心衡量指标是w + s，w + s小的要放在更上面。\n证明方法是将中间任意两头牛进行交换，得到交换前后的最大风险值，可以发现当w + s更小值在上时，得到的最大风险值更小。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; v;int main() {    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        int w, s;        cin &gt;&gt; w &gt;&gt; s;        v.push_back({w + s, s});    }    sort(v.begin(), v.end());    int res = -2e9, sum = 0;    for (int i = 0; i &lt; n; i++) {        int s = v[i].second, w = v[i].first - s;        res = max(res, sum - s);        sum += w;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n4 搜索4.1 DFSDFS可以用来暴力求解动态规划问题，如果实在想不到动态规划问题该怎么写，可以先用DFS偷一点分。时间复杂度一般为指数级别。DFS可以用递归或者递推实现，下面的代码使用递归。\n4.1.1 背包问题\n有n件物品，每件物品重量为w[i]，价值为c[i]。如果需要选出若干物品放入一个容量为v的背包中，问如何放才能在重量不超过v的基础上使得总价值最大。\n\n\n常规递归解法\n\n#include &lt;iostream&gt;using namespace std;const int maxn = 30;int n, v, maxValue = 0, w[maxn], c[maxn];void DFS(int index, int sumW, int sumC) {    if (index == n) {        if (sumW &lt;= v &amp;&amp; sumC &gt; maxValue) maxValue = sumC;        return;    }    DFS(index + 1, sumW, sumC);     // 不选该物品的分支    DFS(index + 1, sumW + w[index], sumC + c[index]);   // 选的分支}int main() {    scanf(“%d %d”, &amp;n, &amp;v);    for (int i = 0; i &lt; n; i++) scanf(“%d”, &amp;w[i]);    for (int i = 0; i &lt; n; i++) scanf(“%d”, &amp;c[i]);    DFS(0, 0, 0);   // 初始index，sumW和sumC都是0    printf(“%d”, maxValue);}\n\n\n剪枝改进\n\nvoid DFS(int index, int sumW, int sumC) {    if (index == n) return;    DFS(index + 1, sumW, sumC);    if (sumW + w[index] &lt;= v) {        if (sumC + c[index] &gt; maxValue) maxValue = sumC + c[index];        DFS(index + 1, sumW + w[index], sumC + v[index]);    }}\n\n4.1.2 求子序列该一类问题描述给定一个序列，枚举这个序列的所有子序列（可以不连续），以下给出一个具体案例：\n\n给定n个整数（可能为负），从中选择k个数，使得这k个数之和恰好等一给定的一个整数x，如果有多种方案，则从其中选择平方和最大的一个。\n\n// maxSumSqu为最大平方和int n, k, x, maxSumSqu = -1, a[maxn];// temp存放临时方案，ans存放平方和最大的方案vector&lt;int&gt; temp, ans;void DFS(int index, int tempK, int sum, int sumSqu) {    if (tempK = k &amp;&amp; sum == x) {        if (sumSqu &gt; maxSumSqu) {            maxSumSqu = sumSqu;            ans = temp;        }        return;    }    if (tempK &gt; k || index == n || sum &gt; x) return;    temp.push_back(a[index]);    DFS(index + 1, tempK + 1, sum + a[index], sumSqu + a[index] * a[index]);    temp.pop_back();    DFS(index + 1, tempK, sum, sumSqu);}\n\n4.2 BFS4.2.1 BFS模版一般使用队列实现：\nvoid BFS(int s) {    queue&lt;int&gt; q;    q.push(s);    while (!q.empty()) {        取出队首元素top;        访问队首元素top（例如print）;        将队首元素出队;        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;    }}\n\n4.2.2 迷宫找出口\n给定一个n * m大小的迷宫，其中*代表不可通过的墙壁，而“.”代表平地，s表示起点，t表示终点。移动过程中，如果当前位置时（x, y）（下标从0开始），且每次只能往上下左右移动，求从起点s到终点t的最少步数。\n\n#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;struct Node {    int x, y;    int step;   // 表示步长} s, t, node;int n, m;char maze[maxn][maxn];bool inq[maxn][maxn] = {false};int x[4] = {0, 0, 1, -1};int y[4] = {1, -1, 0, 0};// 检测位置是否有效bool test(int x, int y) {    if (x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0) return false;    if (maze[x][y] == ‘*’) return false;    if (inq[x][y] == true) return false;    return true;}int BFS() {    queue&lt;Node&gt; q;    q.push(s);    while (!q.empty()) {        Node top = q.front();        q.pop();        if (top.x = t.x &amp;&amp; top.y == t.y) return top.step;        for (int i = 0; i &lt; 4; i++) {            int newx = top.x + x[i];            int newy = top.y + y[i];            if (test(newx, newy)) {                node.x = newx;                node.y = newy;                node.step = top.step + 1;                q.push(node);                inq[newx][newy] = true;            }        }        return -1;    }}int main() {    scanf(“%d%d”, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        getchar();        for (int j = 0; j &lt; m; j++) {            maze[x][y] = getchar();        }        maze[x][m+1] = ‘\\0’;    }    scanf(“%d%d%d%d”, &amp;s.x, &amp;s.y, &amp;t.x, &amp;t.y);    s.step = 0;    printf(“%d”, BFS());        return 0;}\n\n5 图5.1 图的储存方法通常采用邻接矩阵和邻接表储存，邻接矩阵采用二维数组，下标表示端点，值表示权值；邻接表一般使用链表储存，也可以用动态数组vector，更易理解。\n5.1.1 邻接表struct Node {   // v是端点编号，w是权值    int v, w;    Node (int _v, _w) {     // 添加构造函数方便添加结点        v = _v;        w = _w;    }};vector&lt;Node&gt; adj[100];// 添加一条从1号到3号顶点的无向边，权值为4adj[1].push_back(Node(3,4));adj[3].push_back(Node(1,4));\n\n5.2 图的遍历序列以下解法都是针对图的通解（不针对联通分量），如果确定图是联通分量或强联通分量，则只需依次DFS即可。\n5.2.1 邻接矩阵(DFS)const int maxn = 1000;const int inf = 1000000000;int n, g[maxn][maxn];bool vis[maxn] = {false};void DFS(int v, int depth) {    vis[v] = true;    // 如果要对v进行一些操作，可以在这里进行    // 下面对所有从u出发能达到的分支顶点进行枚举    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false &amp;&amp; g[v][i] != inf) {            DFS(i, depth+1);        }    }}void DFSTrave() {    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false) {            DFS(i, 1);        }    }}\n\n5.2.2 邻接表(DFS)const int maxn = 1000;int n;  // 表示端点数vector&lt;int&gt; adj[maxn];bool vis[maxn] = {false};void DFS(int v, int depth) {    vis[v] = true;    // 如果要对v进行一些操作，可以在这里进行    // 下面对所有从u出发能达到的分支顶点进行枚举    for (int i = 0; i &lt; adj[v].size(); i++) {        int u = adj[v][i];        if (vis[u] == false) {            DFS(u, depth+1);        }    }}void DFSTrave() {    for (int i = 0; i &lt; n; i++) {        if (vis[i] == false) {            DFS(i, 1);        }    }}\n\n5.3 拓扑排序首先说明一下，拓扑排序和快排，归并排序，堆排序这样对一个序列的排序是不同的。拓扑排序是对图的排序，简而言之一句话就是如果我是你的父节点，我就一定出现在你前面。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, d[N];vector&lt;int&gt; v[N], res;queue&lt;int&gt; q;bool topoSort() {    for (int i = 1; i &lt;= n; i++) {        if (d[i] == 0) {            q.push(i);        }    }    while (!q.empty()) {        int u = q.front(); q.pop();        res.push_back(u);        for (int i = 0; i &lt; v[u].size(); i++) {            int j = v[u][i];            d[j]--;            if (d[j] == 0) {                q.push(j);            }        }    }    if (res.size() == n) return true;    else return false;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        v[a].push_back(b);        d[b]++;    }    if (topoSort()) {        for (int i = 0; i &lt; n; i++) {            cout &lt;&lt; res[i] &lt;&lt; \" \";        }       } else cout &lt;&lt; -1;    return 0;}\n\n5.4 朴素Dijkstra结构体写法可以换成pair，可以加快一些运行速度。\n其中最不好理解的一部分大概就是求解未到达点中距离最小的一个点。事实上，这也是时间复杂度的原因。朴素Dijkstra只能处理稀疏图（稀疏稠密都是指边）。\n时间复杂度为。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3fffffff;int n, m, d[N];vector&lt;pii&gt; g[N];bool vis[N];void Dijkstra(int s) {    fill(d, d + N, INF);    d[s] = 0;    for (int i = 0; i &lt; n; i++) {        int u = -1, minn = INF;        for (int j = 0; j &lt; n; j++) {            if (!vis[j] &amp;&amp; minn &gt; d[j]) {                minn = d[j];                u = j;            }        }        if (u == -1) return;        vis[u] = true;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (!vis[v] &amp;&amp; d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;            }        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    while (m--) {        int a, v ,dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    Dijkstra(1);    int res = d[n] == INF ? -1 : d[n];    printf(\"%d\", res);    return 0;}\n\n5.5 堆优化Dijkstra堆优化Dijkstra优化了求解最小距离的部分，时间复杂度降低到了。既可以处理稀疏图，也可以处理稠密图。\n堆优化当然更好，考试时优先写堆优化的Dijkstra。\n用邻接表来存储图的话，不用care自环，反正根据算法必定会求得一个最短路径。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3fffffff;int n, m, d[N];vector&lt;pii&gt; g[N];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;bool vis[N];void Dijkstra_Heap(int s) {    fill(d, d + N, INF);    d[s] = 0;    heap.push({0, s});    while (!heap.empty()) {        pii p = heap.top(); heap.pop();        int u = p.second;        if (vis[u]) continue;        vis[u] = true;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (!vis[v] &amp;&amp; d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;                heap.push({d[v], v});            }        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    while (m--) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    Dijkstra_Heap(1);    int res = d[n] == INF ? -1 : d[n];    printf(\"%d\", res);        return 0;}\n\n5.6 Bellman-FordBellman-Ford算法可以求负环，请注意，当有负环而且最短路径可以经过负环时，最短路径是不存在的，因为当不限定次数的时候，可以无限经过该负环使最短路径降低为负无穷。\nBellman算法的原理是首先遍历所有点，每一次遍历都可以确定最短路径树某一层的最短路径。到第n-1次时即可确定整个n层的树的最短。（可以证明，最短路径树一定不超过n层）。这个时候再判断，如果还能修改最短路径，那一定存在负环。\nBellman算法的时间复杂度是。时间复杂度很高，一般不用。\n时间复杂度高是因为内层不知道哪一条边可以松弛，所以傻傻地遍历所有边，实际上可以判断出一定是某一条刚刚更新过的，确定了最短路径的边才会更新新的边。这种改进就是SPFA。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 510, M = 1e4 + 10, INF = 0x3fffffff;int n, m, k;int d[N], backup[N];vector&lt;pii&gt; g[M];int Bellman(int s) {    memset(d, 0x3f3f3f3f, sizeof d);    d[s] = 0;    for (int i = 0; i &lt; k; i++) {        memcpy(backup, d, sizeof d);        for (int u = 1; u &lt;= n; u++) {            for (int j = 0; j &lt; g[u].size(); j++) {                int v = g[u][j].first;                int dis = g[u][j].second;                d[v] = min(d[v], backup[u] + dis);            }        }    }    if (d[n] &gt; 0x3f3f3f3f / 2) return -1;    else return d[n];}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    int t = Bellman(1);    if (t == -1) cout &lt;&lt; \"impossible\";    else cout &lt;&lt; t;    return 0;}\n\n5.7 SPFA5.7.1 SPFA求最短路径st数组的作用是判断哪些点在队列中，一个点不需要重复加入队列，更新新值即可。虽然不用判断也可以，但是加上st数组可以加快速度。\n平均时间复杂度是，最坏时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3f3f3f3f;int n, m, d[N];vector&lt;pii&gt; g[N];bool st[N];queue&lt;int&gt; q;int spfa(int s) {    fill(d, d + N, INF);    d[s] = 0;    q.push(s);    st[s] = true;    while (!q.empty()) {        int u = q.front(); q.pop();        st[u] = false;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;                if (!st[v]) {                    q.push(v);                    st[v] = true;                }            }        }    }    if (d[n] == INF) return -1;    else return d[n];}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    int t = spfa(1);    if (t == -1) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; t &lt;&lt; endl;    return 0;}\n\n5.7.2 SPFA判断负环几乎没有变化，但是注意初始时不再是将1加入队列，而是要将所有点加入队列，因为有时候负环存在但是从1开始到达n不会经过负环。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3f3f3f3f;int n, m, d[N], cnt[N];vector&lt;pii&gt; g[N];bool st[N];queue&lt;int&gt; q;bool spfa() {    fill(d, d + N, INF);    for (int i = 1; i &lt;= n; i++) {        q.push(i);        st[i] = true;    }    while (!q.empty()) {        int u = q.front(); q.pop();        st[u] = false;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (d[v] &gt; d[u] + dis) {                cnt[v] = cnt[u] + 1;                if (cnt[v] &gt;= n) return true;                d[v] = d[u] + dis;                if (!st[v]) {                    q.push(v);                    st[v] = true;                }            }        }    }    return false;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    if (spfa()) cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else cout &lt;&lt; \"No\" &lt;&lt; endl;    return 0;}\n\n5.8 Floyd求解全源最短路径，原理是简单动态规划，最外层k循环逐层确定最短路径，下一层就可以用上一层的结论，当以k节点作为中介点可以更小时更新。\n初始化邻接矩阵要考虑自环。\n时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 210, INF = 0x3fffffff;int d[N][N];int n, m, q;void floyd() {    for (int k = 1; k &lt;= n; k++)        for (int i = 1; i &lt;= n; i++)             for (int j = 1; j &lt;= n; j++)                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) {            if (i == j) d[i][j] = 0;            else d[i][j] = INF;        }    }    while (m--) {        int a, b, dis;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;dis);        d[a][b] = min(d[a][b], dis);    }    floyd();    while (q--) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        if (d[a][b] &gt; INF / 2) cout &lt;&lt; \"impossible\" &lt;&lt; endl;        else cout &lt;&lt; d[a][b] &lt;&lt; endl;    }        return 0;}\n\n5.9 最小生成树5.9.1 PrimPrim算法步骤和Dijkstra十分相似。\nprim算法步骤如下：\n\n遍历n次，每次遍历首先找到集合外距离最近的点t。\n用t更新其他点到集合的距离。（这是和Dijkstra不同的地方，到集合的距离是指到集合中的点的最小距离）\n\n这一段代码和Dijkstra算法唯一不同的地方就在于d[]表示的含义不同，这里是表示到集合的距离。\n和Dijkstra一样，时间复杂度是，如果使用heap优化的话可以降低到。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 510, INF = 0x3f3f3f3f;int n, m, d[N];vector&lt;PII&gt; g[N];bool vis[N];int prim() {    int res = 0;    fill(d, d + N, INF);    d[1] = 0;    for (int i = 0; i &lt; n; i++) {        int u = -1, minn = INF;        for (int j = 1; j &lt;= n; j++) {            if (!vis[j] &amp;&amp; d[j] &lt; minn) {                minn = d[j];                u = j;            }        }        vis[u] = true;        if (u == -1) return INF;        res += d[u];        for (int j = 0; j &lt; g[u].size(); j++) {            int v = g[u][j].first;            int dis = g[u][j].second;            if (!vis[v] &amp;&amp; d[v] &gt; dis) {    //唯一不同的地方                d[v] = dis;            }        }    }    return res;}int main() {    cin &gt;&gt; n &gt;&gt; m;    while (m--) {        int a, b, dis;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dis;        g[a].push_back({b, dis});        g[b].push_back({a, dis});    }    int t = prim();    if (t == INF) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; t &lt;&lt; endl;        return 0;}\n\n5.9.2 Kruskalkruskal算法采用边贪心的策略，初始时隐去图中所有边，这样图中每个顶点都自成一个联通块。之后执行下面的步骤：\n\n对所有边按边权从小到大进行排序。\n按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个联通块中，则把这条测试边加入当前最小生成树中，否则舍弃。\n重复执行2，直到最小生成树中的边数等于总顶点数减1或是所有边测试完。结束时如果最小生成树边数小于总顶点数减1，说明该图不连通。\n\n排序保证最小，两个顶点非同一连通块才合并保证不会成图。合并过程需要用到并查集。\n时间复杂度是。可见kruskal算法适用于稀疏图。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10, M = 2 * N, INF = 0x3f3f3f3f;int n, m;int father[N];struct edge {    int a, b, dis;  } e[M];bool cmp(edge a, edge b) {    return a.dis &lt; b.dis;}int find(int a) {    int x = a;    while (a != father[a]) {        a = father[a];    }    while (x != father[x]) {        x = father[x];        father[x] = a;    }    return a;}int kruskal() {    sort(e, e + m, cmp);    for (int i = 1; i &lt;= n; i++) {        father[i] = i;    }    int res = 0, num = 0;    for (int i = 0; i &lt; m; i++) {        int fa = find(e[i].a), fb = find(e[i].b);        if (fa != fb) {            father[fa] = fb;            res += e[i].dis;            num++;            if (num == n - 1) break;        }    }    if (num &lt; n - 1) return INF;    else return res;}int main() {    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++) {        int a, b, dis;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dis;        e[i] = {a, b, dis};    }    int res = kruskal();    if (res == INF) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n6 树与二叉树6.1 二叉树的储存和操作6.1.1 储存\n通常采用二叉链表来储存二叉树，二叉链表有以下好处：\n\n结构体中存放指针，占用空间小\n删除方便，只需要将指针置空就行\n可以实时控制新生成结点的个数\n\n\nstruct node {    typename data;    node* left;    node* right;};node* newNode(int v) {    node* node = new node;    node-&gt;data = v;    node-&gt;left = node-&gt;right = NULL;    return node;}\n\n6.1.2 查找和修改void search(node* root, int x, int newdata) {    if (root == NULL) return;    if (root-&gt;data == x) root-&gt;data = newdata;    search(root-&gt;left, x, newdata);    search(root-&gt;right, x, newdata); }\n\n6.1.3 结点插入// insert函数将在二叉树中插入一个数据域为x的新结点（参数root要加引用）void insert(node* &amp;root, int x) {    if (root == NULL) {     // 空树，说明查找失败，也即插入位置        root = newNode(x);  //根root也已修改，因为传了引用        return;    }    if (root-&gt;data == x) return;    // 说明已经存在    else if (x &lt; root-&gt;data) insert(root-&gt;left, x);    else insert(root-&gt;right, x);}\n\n6.1.4 建立node* create(int data[], int n) {    node* root = NULL;    for (int i = 0; i &lt; n; i++) {        insert(root, data[i]);    }    return root;}\n\n6.2 二叉树遍历6.2.1 先序遍历// 定义二叉树节点的结构体struct Node {    Node left;    int data;    Node right;};// 先序遍历函数void PreOrder(Node a) {    if(a) {        printf(“%d”, a.data);        PreOrder(a.left);        PreOrder(a.right);    }}\n\n中序和后序遍历只需要调换printf语句和递归的顺序即可\n6.2.2 中序遍历（栈）void InOrder(Node a) {    Node b = a;    stack&lt;Node&gt; s;    while (b || !empty(s)) {        while (b) {            s.push(b);            b = b.left;        }        if (!empty(s)) {            b = s.top();            printf(“%d”, b.data);            s.pop();            b = b.right;        }    }}\n\n前序实现：\n将printf语句放在s.push(b)这一句之前即可，表示第一次遇见这个结点就打印\n6.2.3 层序遍历（队）void LayerOrder(Node a) {    queue&lt;Node&gt; q;    Node b = a;    if (!b) return;  // 如果结点空了则返回    q.push(b);    if (!empty(q)) {        printf(“%d”, b.data);        if (b.left) q.push(b.left);        if (b.right) q.push(b.right);    }}\n\n6.2.4 重建二叉树给出先序序列和中序序列，要求重建这棵二叉树。\nnode* create(int preL, int preR, int inL, int inR) {    if (preL &gt; preR) return NULL;    int k;    node* root = new node;    root-&gt;data = pre[preL];    for (k = 0; k &lt; inR; k++) {        if (pre[preL] == in[k]) break;    }    int numLeft = k - inL;  // 注意是减中序的左结点    root-&gt;left = create(preL + 1, pre + numLeft, inL, k - 1);    root-&gt;right = create(pre + numLeft + 1, preR, k + 1, inR);    return root;}\n\n6.3 树的遍历6.3.1 树的静态写法struct node {    int data;    vector&lt;int&gt; child;  // 动态数组防止子结点过多空间超限} Node[maxn];\n\n6.3.2 先根遍历void PreOrder(int root) {    printf(“%d”, &amp;Node[root].data);    for (int i = 0; i &lt; Node[root].child.size(); i++) {        PreOrder(Node[root].child[i]);    }}\n\n后根遍历只需要将printf语句下放即可。\n6.3.3 层序遍历（记录层号）struct node {    int data;    int layer;  // 记录层号    vector&lt;int&gt; child;} Node[maxn];void LayerOrder(int root) {    queue&lt;node&gt; q;    Node[root].layer = 0;    q.push(Node[root]);    while (!q.empty()) {        int front = q.front();        q.pop();        printf(“%d”, Node[front].data);        for (int i = 0; i &lt; Node[front].child.size(); i++) {            int child = Node[front].child[i];            child.layer = Node[front].layer + 1;            q.push(child);        }    }}\n\n6.4 二叉查找树（BST）\n\n要么二叉查找树是一棵空树。\n要么二叉查找树由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有的结点数据域均大于根结点的数据域（其中可以得到一个规律：二叉查找树的中序遍历必然是非递减序列）。\n\n\n6.4.1 查找操作// search函数查找二叉查找树中数据域为x的结点void search(node* root, int x) {    if (root == NULL) {        printf(“search failed”);        return;    }    if (x == root-&gt;data) {        printf(“%d”, root-&gt;data);    } else if (x &lt; root-&gt;data) {        search(root-&gt;left, x);    } else {        search(root-&gt;right, x);    }}\n\n6.4.2 插入操作// insert函数将在二叉树中插入一个数据域为x的新结点（参数root要加引用）void insert(node* &amp;root, int x) {    if (root == NULL) {     // 空树，说明查找失败，也即插入位置        root = newNode(x);        return;    }    if (root-&gt;data == x) return;    // 说明已经存在    else if (x &lt; root-&gt;data) insert(root-&gt;left, x);    else insert(root-&gt;right, x);}\n\n6.4.3 二叉查找树的建立node* create(int data[], int n) {    node* root = NULL;    for (int i = 0; i &lt; n; i++) {        insert(root, data[i]);    }    return root;}\n\n6.4.4 删除操作// 寻找以root为根结点的树中的最大权值结点node* findMax(node* root) {    while (root-&gt;right != NULL) {        root = root-&gt;right;    }    return root;}// 寻找以root为根结点的树中的最小权值结点node* findMin(node* root) {    while (root-&gt;left != NULL) {        root = root-&gt;left;    }    return root;}// 删除以root为根结点的树中权值为x的结点void delete(node* &amp;root, int x) {    if (root == NULL) return;    if (root-&gt;data == x) {        if (root-&gt;right == NULL &amp;&amp; root-&gt;left == NULL) {            root = NULL;    // 如果是叶子结点直接置空        } else if (root-&gt;left != NULL) {            node* pre = findMax(root-&gt;left);            root-&gt;data = pre-&gt;data;            delete(root-&gt;left, pre-&gt;data);        } else if (root-&gt;right != NULL) {            node* next = findMin(root-&gt;right);            root-&gt;data = next-&gt;data;            delete(root-&gt;right, next-&gt;data);        }    } else if (root-&gt;data &gt; x) {        delete(root-&gt;left, x);    } else {        delete(root-&gt;right, x);    }}\n\n7 数学7.1 素数7.1.1 试除法判断素数for循环中条件写i &lt;= n / i而不是i * i &lt;= n主要是为了防止溢出。对了，记住一定是&lt;=而不是&lt;，可以举一个反例比如说49。\nbool isPrime(int n) {    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i++) {        if (n % i == 0) return false;    }    return true;}\n\n7.1.2 试除法分解质因数\n给出一个数x，求得该数的所有质因数的底数和指数。\n\n如何分解一个数a的质因数呢？依然可以用试除法来解决。从第一个质数开始枚举，如果这个质数是因数的话，那么就不断用 a 除以这个素数，得到其指数。\n可以证明，所有使if (x % i == 0)条件成立时的数一定是质数。用假设法，如果不是质数，那么一定可以表示为一个比它小的质数乘另一个数，那么比它小的质数也一定是因数，一定在这之前被枚举过，因此被枚举的因数一定是质数。\n一个数x的所有因数中，最多只存在一个大于sqrt(x)的数，所以单独判断就好，这样可以大幅减少计算。时间复杂度为。\nvoid divide(int x) {    for (int i = 2; i &lt;= x / i; i++) {        if (x % i == 0) {            int s = 0;            while (x % i == 0) {                x /= i;                s++;            }            printf(\"%d %d\\n\", i, s);        }    }    if (x &gt; 1) printf(\"%d %d\\n\", x, 1);    printf(\"\\n\");}\n\n7.1.3 埃氏筛求素数个数\n给出一个数n，求1—n之间素数个数。\n\n筛法一般用来判断一大堆数是不是质数。例如说判断之间素数的个数，如果采用试除法，那么时间复杂度为，会超时。\n我们可以选择一种方法，当一些条件成立时将明显非质数的数筛去，这样可以节省大量时间。其中埃氏筛法是比较好理解的一种筛法，它筛选素数的倍数。时间复杂度为。\n代码中的st数组可以将其理解为是否被筛去，不要将其理解为是否是素数，否则会和直觉相反。\nconst int N = 1e6 + 10;int primes[N], cnt;bool st[N];void getPrimes(int n) {    for (int i = 2; i &lt;= n; i++) {        if (!st[i]) {            primes[cnt++] = i;            for (int j = i + i; j &lt;= n; j += i) {                st[j] = true;            }        }     }}\n\n7.1.4 线性筛求素数个数线性筛的筛法为将合数通过其最小质因子筛去，一个合数的最小质因子有且只有一个，因此是线性的。\n在代码中if (i % primes[j] == 0) 成立时 primes[j] 一定是 i 的最小质因子。因为我们从小到大枚举所有已经得到的质数，并且当第一次判断成立时 break。\n任何合数，一定会被其最小质因子筛去，证明如下：\n\n\ni % pj == 0，说明 pj 是 i 的最小质因子，pj 也一定是 pj * i 的最小质因子。\ni % pj != 0，pj 一定小于 i 的所有质因子，pj 也一定是 pj * i 的最小质因子\n\n\n时间复杂度为。\nconst int N = 1e6 + 10;int primes[N], cnt;bool st[N];void getPrimes(int n) {    for (int i = 2; i &lt;= n; i++) {        if (!st[i]) primes[cnt++] = i;        for (int j = 0; primes[j] &lt;= n / i; j++) {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;\t// primes[j]一定是i的最小质因子        }    }}\n\n7.2 约数\n如果 约数个数： 约数之和： \n\n7.2.1 试除法求约数\n按照从小到大的顺序输出一个数的所有约数。\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    int n;    cin &gt;&gt; n;    while (n--) {        int a;        vector&lt;int&gt; v;        cin &gt;&gt; a;        for (int i = 1; i &lt;= a / i; i++) {            if (a % i == 0) {                v.push_back(i);                v.push_back(a / i);                if (i == a / i) v.pop_back();            }        }        sort(v.begin(), v.end());        for (int i = 0; i &lt; v.size(); i++) {            cout &lt;&lt; v[i] &lt;&lt; \" \";        }        cout &lt;&lt; endl;    }        return 0;}\n\n7.2.2 约数的个数\n给定n个正整数ai，请你输出这些数的乘积的约数的个数，答案对1e9+7取模。\n\n用哈希表存储质因数的个数，res * (prime.second + 1)过程可能爆 int 所以要用 long long。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;typedef long long LL;unordered_map&lt;int, int&gt; primes;int main() {    int n;    cin &gt;&gt; n;    while (n--) {        int x;        cin &gt;&gt; x;        for (int i = 2; i &lt;= x / i; i++) {            if (x % i == 0) {                while (x % i == 0) {                    x /= i;                    primes[i]++;                }            }        }        if (x &gt; 1) primes[x]++;    }    LL res = 1;    for (auto prime : primes) {        res = res * (prime.second + 1) % mod;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n7.2.3 约数之和\n给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对1e9+7取模。\n\n#include &lt;bits/stdc++.h&gt;using namespace std;unordered_map&lt;int, int&gt; primes;typedef long long LL;const int mod = 1e9 + 7;int main() {    int n;    cin &gt;&gt; n;    while (n--) {   //求质因数        int c;        cin &gt;&gt; c;        for (int i = 2; i &lt;= c / i; i++) {            if (c % i == 0) {                while (c % i == 0) {                    c /= i;                    primes[i]++;                }            }        }        if (c &gt; 1) primes[c]++;    }    LL res = 1;    for (auto prime : primes) { //套公式        int p = prime.first, mi = prime.second;        LL t = 1;        while (mi--) {            t = (t * p + 1) % mod;        }        res = res * t % mod;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n7.2.4 最大公约数 &amp; 最小公倍数我们将使用辗转相除法来求解两个数 a 和 b 的最大公约数。\n首先给出一个定理：0 和一个整数 a 的最大公约数是 a（不是0）。 \n然后给出一个等式gcd(a, b) = gcd(b, a % b)，其中 gcd 表示两个数的最大公约数，下面证明这个等式：\n\n将 a 写作 a = kb + r，其中 k 为 a 整除 b 得到的商，r 为余数。设 d 为 a 和 b 的任意一个约数。r = a - kb，因此毫无疑问 d 也是 r 的一个约数。也就是说，a 和 b 的任意一个约数，也是 b 和 a % b 的一个约数。同理可以得到 b 和 a % b 的任意一个约数，也是a 和 b 的一个约数。当集合 A 包括集合 B，集合 B 包括集合 A 时，可以得到两个集合相等，因此 a 和 b 的最大公约数，也一定是 b 和 a % b 的最大公约数。\n\n观察等式可以发现如果 a &lt; b 的话，等式会将 a 和 b 交换。\n辗转相除法求最大公约数下降得非常快，是级别的下降速度。\n最小公倍数为 a * b / d，可以从集合的角度来理解，a 和 b 的最小公倍数为二者相乘除以最大重叠的那一部分，即为最大公约数。实际中为了防溢出常写成 a / d * b。\nint gcd(int a, int b) {    if (b == 0) return a;    else return gcd(b, a % b);}\n\n7.2.5 筛法求欧拉函数\n1 ∼ N中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。若在算数基本定理中，，则：。此题给定一个数 n，求1 ～ n之间所有整数的欧拉函数之和。\n\n欧拉函数的求解公式可以用容斥原理简单证明一下：\n\n\n从1 - N中去掉所有 p1，p2，… ，pk 的倍数\n\n加上所有 pi * pj 的倍数\n\n减去所有 pi * pj * pk 的倍数（减了3次，又加了3次，相当于不加不减，实际上它应该被减去1次）\n\n以此类推，最后得到的式子可以化简为上述公式形式\n\n\n\n由欧拉函数的定义我们可以很轻松地推导出来，如果一个数 i 是质数的话，那么其欧拉函数为 i - 1（除了 i 之外都与其互质）。\n同时，结合公式和 N 的形式，我们可以得到，如果i % pj == 0，其中 pj 为质数，用 phi 来表示其欧拉函数，则phi[i * pj] = phi[i] * pj。这是因为 pj 是 i 的一个质因子，相当于 N 中对应 pj 的次数加一，，这对于公式后面没有影响，只是将 N 扩大了 pj 倍而已。\n相应的，如果i % pj != 0，则说明 N 的形式中多了一项 pj ，欧拉函数后面需要添加一项 ，与前面的N中约去一个 pj 之后，可以得到phi[i * pj] = phi[i] * (pj - 1);\n为什么这道题目中要用线性筛法求欧拉函数之和呢？\n我们之前说过，线性筛会保证一件事：如果一个数会被筛去那么一定会而且只会被其最小质因子筛去，我们利用这个性质保证其没有遗漏，并且可以将时间复杂度降低为。\nLL getEulur(int n) {    phi[1] = 1;    for (int i = 2; i &lt;= n; i++) {        if (!st[i]) {            primes[cnt++] = i;            phi[i] = i - 1;        }        for (int j = 0; primes[j] &lt;= n / i; j++) {            st[primes[j] * i] = true;            if (i % primes[j] == 0) {                phi[i * primes[j]] = phi[i] * primes[j];                break;            }            phi[i * primes[j]] = phi[i] * (primes[j] - 1);        }    }    LL res = 0;    for (int i = 1; i &lt;= n; i++) {        res += phi[i];    }    return res;}\n\n7.3 快速幂7.3.1 快速幂模板快速幂用于求解指数位非常非常大的情况。对于一个数，如果 b 十分大，假设是  数量级，用暴力做法一个数一个数相乘，需要运算次，属于级别，对于一般设置时长为 1s 的算法题来说会超时。\n我们可以将指数位 b 分解为二进制数，分别求解其每一位二进制数，然后相乘。例如说，（以上指数位的数皆为二进制）。这样，我们就可以在其二进制位数个次数内求得该数，将算法优化为级别。\n计算出来的数十分的庞大，一般都会输出对于某个数的模，以下代码中 p 即为模数。\nLL quickMi(int a, int b, int p) {    LL res = 1;    while (b) {        if (b &amp; 1) res = res * a % p;        b &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}\n\n7.3.2 快速幂求逆元首先解释一下什么是逆元。通俗的来说，如果两个整数的乘积模m后等于1，那么就称它们互为m的逆元。写作或者。\n逆元有什么用处？对乘法来说有成立，但是对除法来说：\n\n举个例子，12 / 4 对 2 取模，答案为 1 而不是 0。\n因此，逆元的一大意义就在于将除法取模转化为乘法取模。\n可能有一些人有疑问了，虽然上面的两个式子不成立，我为什么不先计算a / b的值然后取模呢？是的，大部分情况下先计算 a / b 都是没有问题的，但是考虑这种情况：计算数值巨大的组合数，  对 1e9 + 7 取模的值，这个数的分子和分母都十分庞大。在每一步的运算过程中都应该对 1e9 + 7 取模，否则甚至会爆long long。所以将除法取模转化为乘法取模十分有必要。\n一个数 b 存在逆元的充要条件是 b 与模数 m 互质。特别的，如果 m 是素数，且 a 不是 m 的倍数，则 a 模 m 的逆元为。这个公式可以由费马小定理推导而来。\n费马小定理的公式：。\n7.4 拓展欧几里得欧几里得算法是我们之前辗转相除求最大公约数的算法。而拓展欧几里得所要解决的一个问题是：给定两个非零整数 a 和 b ，求一组整数解 (x, y)，使得 ax + by = gcd(a, b) 成立。其中gcd为最大公约数。\n理解拓展欧几里得的核心在于理解gcd(a, b) = gcd(b, a % b)这个公式。这个公式在之前欧几里得算法求最大公约数那一节介绍过了。\n我们知道在欧几里得算法递归结束时能得到一个式子a * 1 + b * 0 = gcd(a, b)，这是否就可以理解为 x 和 y 在递归的过程中最后变化成了 1 和 0 呢？是的。我们希望能通过gcd(a, b) = gcd(b, a % b)这个公式，逆推出 x 和 y 初始的值。我们用 x1 和 y1 表示递归上层的 x 和 y 的值，用 x2 和 y2 表示下层的 x 和 y 的值，下面是推导过程：\n\n当计算 gcd(a, b) 时，有 a * x1 + b * y1 = gcd 成立，在下一步计算 gcd(b, a % b) 中，有 b * x2 + (a % b) * y2 = gcd 成立。于是得到 a * x1 + b * y1 =  b * x2 + (a % b) * y2。而 a % b = a - (a / b) * b，所以最后的式子可以写成 a * x1 + b * y1 = a * y2 + b * (x2 - (a / b) * y2)。对比左右两边很快可以得到下面的递推公式：\n\n于是我们就得到了递推公式。细心的你通过上面的证明可能发现了，ax + by = gcd(a, b) 不知有一组解。是的，我们通过拓展欧几里得求出来的其中的一组解。\n观察公式我们可以发现一个有趣的现象：如果在传递 x 和 y 时翻转，那么就不用多余的代码更新 x 的值了，这对于简化代码有一些帮助。同时因为我们希望保留低层递归对 x 和 y 的修改，所以需要传引用。\nint exGcd(int a, int b, int &amp;x, int &amp;y) {    if (b == 0) {        x = 1, y = 0;        return a;    }    int d = exGcd(b, a % b, y, x);    y -= a / b * x;    return d;}\n\n如果不翻转x和y的话，那么拓展欧几里得的代码为：\nint exGcd(int a, int b, int &amp;x, int &amp;y) {    if (b == 0) {        x = 1, y = 0;        return a;    }    int d = exGcd(b, a % b, x, y);    int temp = x;    x = y;    y = temp - a / b * y;    return d;}\n\n\n\n7.5 组合数一个组合数，我们会根据 a 和 b 的取值范围的不同来选取不同的方法计算，保证不超时。组合数很大， 所以一般来说都会要求组合数对一个数取模的值。在接下来的讲解中，这个取模的数都是素数。\n7.5.1 组合数（递推公式）。适用于 n 与 m 较小的情况（当 n 和 m 超过 10000 时就很危险了）。时间复杂度是。递推公式的好处是求出了一张表保存了所有要求的组合数，所以适用于多次查询的情况。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3 + 10;const int mod = 1e9 + 7;int c[N][N];void init() {    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt;= i; j++) {            if (!j) c[i][j] = 1;            else {                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;            }        }    }}int main() {    int n, a, b;    cin &gt;&gt; n;    init();    while (n--) {        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; c[a][b] &lt;&lt; endl;    }        return 0;}\n\n7.5.2 组合数（定义）当时，递推公式明显会超时，我们可以采用定义法：\n因为\n所以需要求阶乘的乘法逆元（注意这里需要 m 是素数）。时间复杂度是。这种方法同样可以求得组合数表。所以也适用于多次查询的情况。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9 + 7;const int N = 1e5 + 10;int fact[N], infact[N]; //表示阶乘和阶乘的逆元LL quickMi(int a, int k, int p) {    LL res = 1;    while (k) {        if (k &amp; 1) res = res * a % p;        k &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}void getFact() {    fact[0] = infact[0] = 1;    for (int i = 1; i &lt; N; i++) {        fact[i] = (LL)fact[i-1] * i % mod;        infact[i] = (LL)infact[i-1] * quickMi(i, mod - 2, mod) % mod;    }}int main() {    int n;    scanf(\"%d\", &amp;n);    getFact();    while (n--) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        int res = (LL)fact[a] * infact[a-b] % mod * infact[b] % mod;        printf(\"%d\\n\", res);    }        return 0;}\n\n7.5.3 组合数（Lucas）我们来考虑的极端情况。如此庞大的数字\n首先介绍我们的解决方案，Lucas定理：\n\n如果 p 是素数，将 m 和 n 表示为 p 进制：那么 Lucas 定理告诉我们：\n\n举个例子来说，对于来说，m = 3， n = 8，将 m 和 n 表示成五进制形式：于是有。\n这意味着我们可以在组合数的表示中将 n 和 m 两个十分庞大的数分解为多个小组合数相乘，其中 a 和 b 都小于 p。当 时都在我们的求解范围内，唯一的要求就是 p 要为素数。\n将 n 和 m 分解的时间复杂度为。求解小组合数的时间复杂度为。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int p;int quickMi(int a, int b) {    int res = 1;    while (b) {        if (b &amp; 1) res = (LL)res * a % p;        b &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}int C(int a, int b) {    int res = 1;    for (int i = 1, j = a; i &lt;= b; i++, j--) {        res = (LL)res * j % p;        res = (LL)res * quickMi(i, p - 2) % p;    }    return res;}int Lucas(LL a, LL b) {    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b);    else return (LL)C(a % p, b % p) * Lucas(a / p, b / p) % p;}int main() {    int n;    cin &gt;&gt; n;    while (n--) {        LL a, b;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; Lucas(a, b) &lt;&lt; endl;;    }        return 0;}\n\n8 动态规划什么是动态规划动态规划（Dynamic Programming）是一种用来解决一类最优化问题的算法思想。简单来说，动态规划将一个复杂的问题分解成若干个问题，通过综合子问题的最优解来得到原问题最优解的过程。十分灵活，无固定写法。有以下几个特性：\n\n一个问题必须要有重叠子问题和最优子结构才能用动态规划求解\n与分治的区别：分治不拥有重叠子问题\n与贪心的区别：贪心“自顶向下”，只考虑子问题中最优的一个解。动态规划会考虑所有子问题，并选择继承能得到最优结果的那一个\n设计状态转移方程是动态规划的核心，也是动态规划最难的地方。动态转移方程必须满足状态的无后效性\n\n8.1 背包问题8.1.1 0-1背包问题\n有 n 件物品和一个容量是 m 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi ，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n\n以下是二维数组的解法，dp[i][j]表示选取 1 ～ i 件物品且背包容量最大为 j 时的最优解。在循环中会逐渐增加能选取的物品数量和背包容量。最终答案就是dp[n][m]。\n为什么扩大背包容量一定能增加总价值？因为当 i 固定时，j 逐渐变大过程中只做加法而不做减法。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int dp[N][N], v[N], w[N];int main() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= m; j++) {            dp[i][j] = dp[i-1][j];            if (j &gt;= v[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n考虑到dp[i]只使用了dp[i-1]的结论，所以可以将二维数组优化成一维，最大的改动如下。需要将背包容量从后向前枚举，否则就不是使用dp[i-1]而是dp[i]的结论了。\nfor (int i = 1; i &lt;= n; i++) {    for (int j = m; j &gt;= v[i]; j--) {        dp[j] = max(dp[j], dp[j-v[i]] + w[i]);    }}\n\n8.1.2 完全背包问题\n问题在0-1背包问题的基础上修改为每件物品可以无限次使用。\n\n只需将\ndp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);\n\n修改为\ndp[i][j] = max(dp[i-1][j], dp[i][j-v[i]] + w[i]);\n\n为什么是dp[i]而不是dp[i-1]？因为dp[i][j] &gt;= dp[i-1][j]一定成立，如今第 i 件物品可以无限选择，那么就一定选择更大的那个。也因为这个道理，所以一维优化不需要再从后向前枚举。\nfor (int i = 1; i &lt;= n; i++) {    for (int j = w[i]; j &lt;= m; j++) {        dp[j] = max(dp[j], dp[j - w[i]] + c[i]);    }}\n\n8.1.3 多重背包问题\n问题在完全背包问题基础上修改，每件物品可以使用s[i]次而不是无限次。\n\n既然可以使用的次数有限，那就逐个枚举，让 DP 算法自己判断选取多少个更合适。时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int dp[N][N], w[N], v[N], s[N];int main() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= m; j++) {            for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) {                dp[i][j] = max(dp[i][j], dp[i-1][j - v[i] * k] +  w[i] * k);            }        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n\n\n8.1.4 多重背包问题（二进制优化）可以将时间复杂度优化为。适用于N，V或者S比较大的情况。\n思路是将每个每个物品的个数拆成其二进制数和某个数的和（如果这个数存在的话），例如将200拆分成 200 = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 73。于是这个物品就可以转化成多个物品，然后整个问题变成了 0-1 背包问题。\n体积变成 k 倍，价值也变成了 k 倍。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 13000;int v[N], w[N];int dp[N];int main() {    int n, m, cnt = 0;  // cnt表示转化后的总物品数    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++) {        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        int k = 1;  // k为二进制倍数        while (k &lt;= s) {            cnt++;            v[cnt] = k * a;            w[cnt] = k * b;            s -= k;            k *= 2;        }        if (s &gt; 0) {            cnt++;            v[cnt] = s * a;            w[cnt] = s * b;        }    }    n = cnt;    for (int i = 1; i &lt;= n; i++) {        for (int j = m; j &gt;= v[i]; j--) {            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);        }    }    cout &lt;&lt; dp[m] &lt;&lt; endl;        return 0;}\n\n8.1.5 分组背包问题\n有N组物品和容量为V的背包，每组物品有若干个，同一组物品最多选一个，求如何选取总价值最大。\n\n多重背包问题是枚举第 i 个物品选多少个，分组背包问题是枚举第 i 组物品选哪一个。二者的代码有一定相似之处。\n一维状态转移如何判断正向枚举还是逆向枚举？只需要观察本层状态的更新是否使用上一层的结论即可。如果使用上一层的结论，那么就需要逆向枚举；如果仅使用本层的结论，那么就正向枚举。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int dp[N], s[N], v[N][N], w[N][N];int main() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; s[i];        for (int k = 1; k &lt;= s[i]; k++)             cin &gt;&gt; v[i][k] &gt;&gt; w[i][k];    }    for (int i = 1; i &lt;= n; i++)         for (int j = m; j &gt;= 0; j--)             for (int k = 1; k &lt;= s[i]; k++)                 if (v[i][k] &lt;= j)                    dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);    cout &lt;&lt; dp[m] &lt;&lt; endl;        return 0;}\n\n8.2 线性DP8.2.1 数字三角形\n 给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。 \n        7     3   8   8   1   0 2   7   4   44   5   2   6   5\n\n注意只能朝着左下方和右下方的结点移动。\n因为结点有可能有负值，所以最好将dp数组初始化为-INF，防止max函数取到三角形之外的数。另外顺序向下有可能需要比较三角形内的数和外的数，所以将其边缘也初始化为-INF。\ndp[1][1]需要预先给定，否则整个dp数组都很难逃离-INF。时间复杂度。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 510;const int INF = 0x3fffffff;int a[N][N], dp[N][N];  // dp表示考虑到第i行第j层为止的最大路径和int main() {    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= i; j++) {            scanf(\"%d\", &amp;a[i][j]);        }    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= i + 1; j++) {            dp[i][j] = -INF;        }    }    dp[1][1] = a[1][1];    for (int i = 2; i &lt;= n; i++) {        for (int j = 1; j &lt;= i; j++) {            dp[i][j] = max(dp[i-1][j-1] + a[i][j], dp[i-1][j] + a[i][j]);        }    }    int maxn = -INF;    for (int i = 1; i &lt;= n; i++) {        if (dp[n][i] &gt; maxn) maxn = dp[n][i];    }    cout &lt;&lt; maxn &lt;&lt; endl;        return 0;}\n\n如果不想考虑边缘情况的话，可以逆序向上。既然一条路正着走路径和最短，那么反着走也一定路径和最短。dp数组表达含义相同。\n逆序因为不用考虑三角之外的数，所以不用考虑边缘情况。代码很简洁。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 510;const int INF = 0x3fffffff;int dp[N][N];  // dp表示考虑到第i行第j层为止的最大路径和int main() {    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= i; j++) {            scanf(\"%d\", &amp;dp[i][j]);        }    }    for (int i = n; i &gt;= 1; i--) {        for (int j = i; j &gt;= 1; j--) {            dp[i][j] = dp[i][j] + max(dp[i + 1][j], dp[i + 1][j + 1]);        }    }    cout &lt;&lt; dp[1][1] &lt;&lt; endl;        return 0;}\n\n8.2.2 最长上升子序列\n 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。 子序列中单调递增的部分可以不连续。\n\ndp[i] 表示以第i个字符结尾的序列严格单调递增的最长长度。有一个边界，若前面没有比i小的，dp[i] 为1（自己为结尾）。时间复杂度为。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int a[N], dp[N];    //dp[i]表示以第i个字符结尾的序列严格单调递增的最长长度int main() {    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;a[i]);    }    int maxn = 0;    for (int i = 1; i &lt;= n; i++) {        dp[i] = 1;        for (int j = 1; j &lt;= i; j++) {            if (a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1);        }        maxn = max(maxn, dp[i]);    }    cout &lt;&lt; maxn &lt;&lt; endl;        return 0;}\n\n有一种二分的优化写法，可以将时间复杂度降低到，这种写法的思想更像是贪心。\n\n状态表示：**f[i] 表示长度为 i 的最长上升子序列，末尾最小的数字**。即长度为 i 的子序列末尾最小元素是什么。cnt 表示目前的最长上升序列长度。\n\n状态计算：对于每一个w[i]，如果大于 f[cnt - 1]那就cnt + 1，当前末尾最小元素为w[i]。 若 w[i] 小于等于f[cnt - 1]，说明不会更新当前的长度，但之前序列末尾的最小数字要发生变化，找到最小的大于或等于 (这里不能是大于) w[i]的位置 r，更新以 r 结尾序列的最小数字。\n\n为什么 cnt 能用来表示最长上升序列长度？这里用到了贪心的思想。举个例子：一个序列 3 1 2 1 8 5 6，长度为 1 时，能接在 3 后面的数字一定可以接在 1 后面，所以 1 比 3 更合适作为结尾的数字。cnt 在这种最优的条件下判断w[i] &gt; f[cnt-1]的次数，所以可以得到最优解。\n\nf[i]一定是一个单调递增的数组，所以可以用二分法来找最小的大于或等于 w[i] 的数字。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int a[N], f[N]; //f[i]表示长度为i的最长上升子序列中末尾最小的数字int n, cnt;int main() {    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)         cin &gt;&gt; a[i];    f[cnt++] = a[0];    for (int i = 1; i &lt; n; i++) {        if (a[i] &gt; f[cnt - 1]) f[cnt++] = a[i];        else {            int l = 0, r = cnt - 1;            while (l &lt; r) {                int mid = l + r &gt;&gt; 1;                if (f[mid] &gt;= a[i]) r = mid;                else l = mid + 1;            }            f[r] = a[i];        }    }    cout &lt;&lt; cnt &lt;&lt; endl;        return 0;}\n\n8.2.3 最长公共子序列\n给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。 \n\ndp[i][j]表示长度为 i 的 A 字符串和长度为 j 的 B 字符串的最长公共子序列长度。考虑不同情况\n\n如果a[i] == b[j]，说明字符串 A 和字符串 B 的 LCS 都增加了一位。\n如果a[i] ！= b[j]，说明字符串 A 和字符串 B 的 LCS 无法继续延长，因此dp[i][j]将会继承dp[i-1][j]和dp[i][j-1]中的较大者。\n\n时间复杂度为。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;char a[N], b[N];int n, m, dp[N][N];  //dp[i][j]表示长度为i的A字符串和长度为j的B字符串的最长公共子序列长度int main() {    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + 1 &gt;&gt; b + 1;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            if (a[i] == b[j])                dp[i][j] = dp[i-1][j-1] + 1;            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n8.2.4 最短编辑距离\n给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：\n\n删除 – 将字符串 A 中的某个字符删除。\n插入 – 在字符串 A 的某个位置插入某个字符。\n替换 – 将字符串 A 中的某个字符替换为另一个字符。\n\n现在请你求出，将 A 变为 B 至少需要进行多少次操作。\n\n一般来说，动态规划，题目怎么问，就怎么表示状态。比如说这道题目中，dp[i][j] 可以表示字符串 A 中前 i 个字符要和 B 中前 j 个字符匹配需要进行的最少的操作次数。操作分三种情况：\n\n删除：即需要删除 A 字符串中第 i 个字符才能使得其与字符串 B 中前 j 个字符匹配，可以得到dp[i][j] = dp[i-1][j] + 1。表示字符串 A 前 i - 1 个字符与 B 前 j 个字符匹配的最小操作数加上删除这个操作。\n增加：同理，既然需要增加才能匹配，那么意为前 i 个字符和前 j - 1 个字符是匹配的。dp[i][j] = dp[i][j-1] + 1。\n替换：这里需要分情况讨论，如果A[i] = B[j]，那么不需要修改，直接继承dp[i-1][j-1]即可，否则需要进行替换操作，dp[i][j] = dp[i-1][j-1] + 1。\n\n上述三种情况取最小值就可以得到我们想要的 dp 数组。\n注意首先要进行边缘化操作：dp[0][i] = i表示 A 字符串前 0 个字符和 B 字符串前 i 个字符想要匹配需要增加 i 个字符，dp[i][0] = i同理。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int dp[N][N];int main() {    cin &gt;&gt; n &gt;&gt; a + 1 &gt;&gt; m &gt;&gt; b + 1;\t//表示把第一位空出来，从第二位开始输入。    for (int i = 0; i &lt;= n; i++)         dp[i][0] = i;    for (int i = 0; i &lt;= m; i++)        dp[0][i] = i;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1);            if (a[i] == b[j])                dp[i][j] = min(dp[i][j], dp[i-1][j-1]);            else                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1);        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n8.3 区间DP\n设有 N 堆石子排成一排，其编号为 1，2，3，…，N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。\n问题是：找出一种合理的方法，使总的代价最小，输出最小代价。\n\n区间 DP 不同于线性 DP，其数组 dp[L][R]表示的含义为将区间 L - R 的石子合并为一堆的方案的集合的最小值。同一个区间有多种合并方案，例如说，我们可以通过最左端的值来区别不同合并方案（如下图所示）。假设我们正在进行这个区间的合并工作，分界点为 k 。现在区间为[L, k] 和 [k + 1, R]。我们所要做的是就是计算前一个区间的最小合并价值，后一个区间的最小合并价值和两个区间合并的价值（两个区间合并价值固定，可以通过前缀和来求出）。这样就得到了 DP 中我们喜闻乐见的重叠子问题。\n\n\n区间 DP 的一个固定模式就是先写出区间长度。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 310;const int INF = 0x3fffffff;int n;int a[N], s[N], dp[N][N];   //dp[L][R]表示的含义为将区间 L - R 的石子合并为一堆的方案的集合的最小值int main() {    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; a[i];        s[i] = s[i-1] + a[i];    }    //区间长度为1时代价为0，不需要考虑    for (int len = 2; len &lt;= n; len++) {  //区间长度        //表示区间长度变大，左端点初始一直为1，右端点始终不大于n        for (int l = 1; l + len - 1 &lt;= n; l++) {                int r = l + len - 1;            dp[l][r] = INF;     //考虑边界点            for (int k = l; k &lt; r; k++) {                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + s[r] - s[l-1]);            }        }    }    cout &lt;&lt; dp[1][n] &lt;&lt; endl;        return 0;}","categories":["数据结构与算法"],"tags":["贪心","图论","树","动态规划","基础算法","数据结构","搜索"]}]