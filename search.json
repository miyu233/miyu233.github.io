[{"title":"面向对象基础","url":"/2021/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","content":"说明该文章大部分内容来自以下开源博客：面向对象思想\n1 三大特性1.1 封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。内部的数据被隐藏了起来，外部只可以通过提供的接口访问数据。因此用户无需关心对象内部的细节，同时也无从得知其内部的细节。\n优点：\n\n减少耦合：可以独立地开发、测试、优化、使用、理解和修改\n\n减轻维护的负担：可以更容易被理解，并且在调试的时候不影响其他模块\n\n有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能\n\n提高软件的可重用性\n\n降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的\n\n\n1.2 继承继承实现了IS-A关系，例如Cat和Animal就是一种IS-A关系，Cat可以继承ziAnimal，从而获得Animal非private的属性和方法。\n继承应该遵循里氏替换原则。\nCat可以当作Animal来使用，也就是说可以使用Animal引用Cat对象（这是一个十分常用的写法）。父类对象引用指向子类对象称为向上转型。\nAnimal animal = new Cat();\n\n1.3 多态多态分为编译时多态和运行时多态：\n\n编译时多态主要指方法的重载（Overload），发生在一个类之内。常见的形式是重载多个构造函数，提供创建新对象时的方便。重载应该满足的条件是：\n\n函数名必须相同\n\n参数列表必须不同（参数个数、数据类型、参数顺序）\n\n函数的返回类型可以相同也可以不同\n\n仅仅返回类型不同不足以称为重载\n\n\n\n运行时多态是指程序中定义的对象引用所指向的具体类型在运行期间才确定，具体实现有重写（Override），运行时多态有三个条件：\n\n继承\n\n覆盖（重写）\n\n向上转型\n\n\n\n\n重写与重载的区别重载（Overload）实现的是编译时的多态性，重写（Overrid）实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。\n2 六种关系2.1 泛化关系用来描述继承关系，在Java中使用extends关键字，uml写法如下：\n\n\n2.2 实现关系用来实现一个接口，在Java中使用implements关键字。\n\n\n2.3 聚合关系聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has - a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，比如计算机与CPU、公司与员工的关系等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。\n\n\n2.4 组合关系组合也是关联关系的一种特例，他体现的是一种contains - a的关系，这种关系比聚合更强，也称为强聚合。他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如你和你的大脑，表现在代码层面，和关联关系是一致的，只能从语义级别来区分。\n以公司和部门为例子，如果公司没了，则部门就不存在了。\n\n\n2.5 关联关系关联关系体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友。这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，关系一般是平等的、关联可以是单向、双向的。表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。\n这是一种静态的关系，与运行过程的状态无关。可以用1对1、1对多，多对多这种关系来表示。举例来说，学校和学生就是一种关联关系，一个学校可以有很多学生，一个学生只能属于一个学校。这种关系在运行之前就可以确定。\n\n\n2.6 依赖关系可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。\n与关联关系不同的是，依赖关系是在运行过程中起作用的。A类和B类是依赖关系主要有三种形式：\n\nA类是B类方法的局部变量\n\nA类是B类方法的参数\n\nA类向B类发送消息，从而影响B类发生变化\n\n\n\n\n\n关系的耦合程度耦合程度排序：泛化 ≈ 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖。\n好的代码应该实现：高内聚，低耦合。\n3 五种设计原则\n\n\n简写\n全拼\n中文翻译\n\n\n\nSRP\nThe Single Responsibility Principle\n单一职责原则\n\n\nOCP\nThe Open Closed Principle\n开放封闭原则\n\n\nLSP\nThe Liskov Substitution Principle\n里氏替换原则\n\n\nISP\nThe Interface Segregation Principle\n接口分离原则\n\n\nDIP\nThe Dependency Inversion Principle\n依赖倒置原则\n\n\n3.1 单一职责原则\n修改一个类的原因应该只有一个。\n\n一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。\n如果一个类承担的职责过多，那么某个职责的变化可能会削弱这个类完成其他职责的能力。\n多职责会导致脆弱和不易理解的设计。\n3.2 开放封闭原则\n类应该对拓展开放，对修改关闭。\n\n该原则要求在添加新功能时可以新增，但是不能修改原代码。\n符合开闭原则最典型的例子就是装饰者模式，它可以动态地将责任附加在对象上，而不用去修改类的代码。\n实现OCP的主要机制是抽象和多态，LSP和DIP是OCP的基础。\n3.3 里氏替换原则\n子类对象必须能够替换掉所有父类对象。\n\n所有出现父类对象的地方将其换成子类都不会出问题。子类应该在实现父类的一切功能的基础上比父类更加特殊。\nLSP是多态顺利实现的保证，从而使OCP称为可能，因为正是子类型的可替换性才使得使用基类的模块在无需修改的情况下就可以拓展：\n\n增加或修改任何一个子类型，基类不用修改（封闭）\n\n基类的使用者（客户程序）可以通过多态得到拓展或修改过的行为（开放）\n\n\n3.4 接口分离原则\n不应该强迫客户依赖于他们不用的方法。\n\n使用多个专门的接口比使用单一的总接口要好。\n3.5 依赖倒置原则\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\n\n按照自上而下的依赖关系，高层的策略设置模块往往是无法重用的，如果设法让高层模块独立于低层模块，则实现重用就变成可能。\n面向接口编程：依赖倒置原则的启发式建议是“依赖于抽象”，具体做法是将高层需要的服务声明为抽象接口，高层使用这些接口，低层实现这些接口，使得高层不再依赖于底层，而是依赖于抽象接口，同样底层也依赖于抽象接口。\n依赖于抽象意味着：\n\n任何变量都不应该持有一个指向具体类的指针或者引用\n\n任何类都不应该从具体类派生\n\n任何方法都不应该重写它的任何基类中已经实现的方法\n\n\n细节抽象类和接口的区别\n抽象类中可以有0～n个抽象方法，也可以有普通方法，接口中只能有抽象方法（JDK1.8之后允许有普通方法）。\n\n抽象类定义之前必须有abstract修饰符，而接口不用class，用interface，其实这也说明了接口并不是类。\n\n抽象类可以继承自抽象类，接口可以继承自接口，抽象类可以实现接口，但是接口不能实现接口。\n\n抽象类中的成员变量和方法可以是各种类型的（public，protected，default，private），但抽象方法必须是protected or public（因为要给子类访问）。接口不能有变量，只能拥有常量（public static final），抽象方法必须为public（通用接口）。\n\n\n","categories":["面向对象"],"tags":["设计原则","类的关系","三大特性"]},{"title":"UNITY练习笔记","url":"/2021/06/14/UNITY%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"实用的工具ZealZeal的官网\nZeal是一个离线API查看工具，支持205种文档（截止至2021/6/2），最大的好处是不需要联网，能随时查看（拯救断网大学生），查询速度也很快，对比很多服务器在国外的文档真的能节省很多时间。\n以我用它来查unity3d的api文档的体验来说，比官网好太多了。\n此外绝大部分语言的API都可以查询，你就不需要在网页上开那么窗口了，浏览器可以解放出来查询一些比较有价值的问题（当一个程序员解决了一个bug时.gif）。\n缺点也是有的，最大的缺点就是只有英文，需要一定的英语阅读能力，可能代码写着写着就一转背单词了，建议搭配查词软件一起使用，不要翻译一整句话，遇到不会的单词再翻译而后自己理解，既学到了单词又保证了效率。\n还有一个缺点就是丑，不过可以通过自己写css代码导入来美化。\n生命周期学习了unity中的代码周期，所有unity产生的c#脚本都会引用UnityEngine，所有的类都会继承自Monobehavior。c#中代码执行顺序并非像js一样自上而下，而有固定顺序，以下执行顺序为自顶向下：\n官方文档地址\n\nawake()\n\nOnEnable()\n\nStart()\n\nFixedUpdate()\n\nOnTrigger() 系列\n\nOnTriggerEnter()：触碰到trigger执行一次\nOnTriggerExit()：离开trigger执行一次\nOnTriggerStay()：触碰到trigger时每一帧执行一次\n\n\nOnCollision() 系列\n\nOnCollisionEnter()：触碰到Collision执行一次\nOnCollisionExit()：离开Collision执行一次\nOnCollisionStay()：触碰到Collision时每一帧执行一次\n\n\nOnMouseUp()\n\nOnMouseDown()\n\nUpdate()\n\nLateUpdate()（在这一帧刷新出来后执行）\n\nOnGUI()\n\nOnDestroy()\n\n\n序列化实现存储和加载游戏游戏存档和读档的原理就是将游戏进行的数据保存在一个文件中。当重新载入游戏时，会首先读取这个文件，然后根据文件的数据动态创建游戏内容，让玩家得以从上次结束的地方重新开始。这给人的感觉就像是机器记住了游戏内容，其实并不，机器只是记住了一个游戏内容清单而已。\n什么是序列化和反序列化游戏存档和读档的原理就是将游戏进行的数据保存在一个文件中。当重新载入游戏时，会首先读取这个文件，然后根据文件的数据动态创建游戏内容，让玩家得以从上次结束的地方重新开始。这给人的感觉就像是机器记住了游戏内容，其实并不，机器只是记住了一个游戏内容清单而已。\n使用序列化需要添加头文件：\nusing System.IO;using System.Runtime.Serialization.Formatters.Binary;   //储存2进制文件\n\n\n序列化：将对象转化成为字节流，如下图所示，对象可以是Unity中任意脚本或文件，事实上，当创建一个 MonoBehaviour 脚本时，Unity 会通过序列化/反序列化将文件转换成 C++ 代码，然后变成你在检查器窗口中看见的 c# 代码。 \n\n\n反序列化：序列化的反面，将一个字节流转换成对象。\n\nJSON：一种和语言无关的数据交换格式。 当进行 对象 to JSON 和 JSON to 对象 转换时，可以分别将这两种称作称作 JSON 序列化 和 JSON 反序列化。 \n\n\n1 游戏存档新建一个游戏存档类GameData，取消MonoBehaviour继承。这个类用于存放游戏载入时应该加载的东西，即为前言所述游戏内容清单。\n有一句非常重要的代码[System.Serializable]需要添加在类声明之上。这是一个属性，它标明了代码的一个元数据。它告诉 Unity 这个类可以被序列化，这意味着你可以将它转换成字节流并保存到磁盘文件中。 \n[System.Serializable]public class GameData&#123;    public Vector3 playerTransform;    //玩家位置    //public List&lt;Transform&gt; enemyTransfrom = new List&lt;Transform&gt;();   //敌人位置    public int lifePoint;   //玩家生命值    public string gameTime; //玩家游戏时间，形如 00h00m00s    public int gameSec;&#125;\n\n\n\n2 游戏保存新建一个GameSave类，这个类提供一个静态方法SaveGame()，静态保证可以在其他类中调用。\npublic class GameSave : MonoBehaviour&#123;    static public void SaveGame() &#123;        GameData gameData = new GameData();        string path = Application.persistentDataPath + &quot;/game_saveData&quot;;        //判断目录是否存在，不存在则创建        if (!Directory.Exists(path)) &#123;            Directory.CreateDirectory(path);        &#125;        BinaryFormatter bf = new BinaryFormatter();  //二进制化        FileStream file = File.Create(path + &quot;/gameData.txt&quot;);        //获取数据        PlayerController data = GameObject.Find(&quot;Knight&quot;).GetComponent&lt;PlayerController&gt;();        gameData.lifePoint = data.lifePoint;        float x = data.transform.position.x;        float y = data.transform.position.y;        float z = data.transform.position.z;        gameData.playerTransform = new Vector3(x, y, z);        gameData.gameTime = data.gameTime;        gameData.gameSec = data.gameSec;        //将二进制文件保存为JSON，使用二进制查看软件打开可看到具体数据        var json = JsonUtility.ToJson(gameData);        bf.Serialize(file, json);    //将二进制数据写入文件        file.Close();    &#125;&#125;\n\n\n\n3 游戏读取新建一个游戏读取类GameLoad，提供一个静态方法LoadGame()，返回值是GameData类型，如果无数据则返回null。\npublic class GameLoad : MonoBehaviour&#123;    static public GameData LoadGame() &#123;        GameData gameData = new GameData();        BinaryFormatter bf = new BinaryFormatter();        string path = Application.persistentDataPath + &quot;/game_saveData/gameData.txt&quot;;        if (File.Exists(path)) &#123;            FileStream file = File.Open(path, FileMode.Open);            JsonUtility.FromJsonOverwrite((string)bf.Deserialize(file), gameData);            file.Close();            return gameData;        &#125;        return null;    &#125;&#125;\n\n\n\n游戏时长最开始只在GameData中储存了一个string变量gameTIme，里面存放的是格式化后的游戏时间，形如 00h00m00s。\n出现的问题是，重新保存存档时，势必要知道上一次存档时的游戏时间，虽然可以用gameTime再转换回去，但是显然多存储一个总时间秒数更方便，于是又添加了一个int型变量gameSec。\n[System.Serializable]public class GameData&#123;    public Vector3 playerTransform;    //玩家位置    //public List&lt;Transform&gt; enemyTransfrom = new List&lt;Transform&gt;();   //敌人位置    public int lifePoint;   //玩家生命值    public string gameTime; //玩家游戏时间，形如 00h00m00s    public int gameSec;&#125;\n\n\n\n但是还没完。我用的是Time.time获取游戏时间，如果采用这种方法的话，加载存档之后，第一次保存是正确的，第二次及以后保存的时间累加了重复值，并不是真实游戏时间。\n解决方法是在PlayerController中维护一个变量preSaveTime（注意不是GameData）用于记录上一次保存时的Time.time，写入时的代码改成：\nvoid Save() &#123;    GameData gameData = GameLoad.LoadGame();    gameSec = (int)Time.time - preSaveTime + gameData.gameSec;    preSaveTime = (int)Time.time;    int hour = gameSec / 3600;    int min = (gameSec % 3600) / 60;    int sec = (gameSec % 3600) % 60;    gameTime = hour + &quot; h &quot; + min + &quot; m &quot; + sec + &quot; s &quot;;    GameSave.SaveGame();&#125;\n\n同时在Start中添加：\npublic void LoadGameData() &#123;    GameData gameData = GameLoad.LoadGame();    if (gameData != null) &#123;        transform.position = gameData.playerTransform;        lifePoint = gameData.lifePoint;        gameSec = gameData.gameSec;    &#125;&#125;\n\n\n\n对象池实现Dash残影效果简单介绍一下对象池（Object Pool）对象池是一种十分常见的游戏开发设计模式。\n该技术就是通过建立一个包含许多（待使用）对象的容器，提供对象的创建和销毁方法，按需取用，大大提升开发效率和资源占用。\n以一个形象的例子来比喻的话，打网球的人常常在口袋里揣两三个网球，这样就可以多打几轮而不用每次丢球都要去捡球。你可以把对象池想象成一个巨大的口袋，里面存放了很多网球，直到你口袋中所有球用完之前，你可以快乐很久。想象在宽阔的网球场捡球的疲惫样子，你大概就可以理解对象池给开发带来的便利。\n对象池的具体好处当游戏中需要创建和销毁大量相同的物品时，如果使用Instantiate和Destory的方式来完成该需求时，会占用大量的系统资源，有可能导致内存溢出，进程崩溃。这个时候需要使用对象池。\n对象池的实现该对象池的实现需要新建两个脚本：对象和池。\n\nShadowSprite（对象）：这个脚本用于控制Shadow对象的参数，例如不透明度，消失时间等等：\n[Header(&quot;时间控制参数&quot;)]public float activeTime;//显示时间public float activeStart; //开始显示的时间点[Header(&quot;不透明度控制&quot;)]public float alpha;public float alphaSet; //初始值public float alphaMultiplier;   //递减参数\n\n\n起始时要获取Player的Sprite，位置，大小和旋转角度（最后这个好像也无所谓，毕竟固定z轴）。\n\nprivate void OnEnable() &#123;    player = GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform;    thisSprite = GetComponent&lt;SpriteRenderer&gt;();    playerSprite = player.GetComponent&lt;SpriteRenderer&gt;();    alpha = alphaSet;    thisSprite.sprite = playerSprite.sprite;    //拿到player的sprite    transform.position = player.position;   //位置，省略this    transform.localScale = player.localScale;   //大小    transform.rotation = player.rotation;   //角度    activeStart = Time.time;&#125;\n\n\n在Update中检测时间，如果到达activeTime，则返回对象池\n\nif (Time.time &gt; activeStart + activeTime) &#123;    //返回对象池    ShadowPool.instance.ReturnPool(this.gameObject);&#125;\nShadowPool（对象池）：\n\n采用队列储存对象，因为残影的特点是先出现的先到达activeTime，所以它会先回到对象池中，下面是c#定义队列的代码：\n\nCount获取队列长度\nEnqueue()进入队列\nDequeue()弹出队列\n\nprivate Queue&lt;GameObject&gt; availableObjects = new Queue&lt;GameObject&gt;();\n对象池的核心是提供对象的调用和返回，区别于普通的对象创建和删除，这里的调用和返回是通过SetActive实现：\npublic void ReturnPool(GameObject obj) &#123;    obj.SetActive(false);    availableObjects.Enqueue(obj);&#125;public GameObject GetFromPool() &#123;    if (availableObjects.Count == 0) FillPool();    var outShadow = availableObjects.Dequeue();    outShadow.SetActive(true);    return outShadow;&#125;\n\nif (availableObjects.Count == 0) FillPool();\n如果对象池空了，那么就扩容。\n\n\n\n\n​    \nUnity游戏开发的合作模式准备工作准备阶段要做的工作很重要。\n需要一个主程将功能点清晰独立的分开，定义好global变量。如果正规，画好类图、流程图、计划好各功能模块之间的接口。\n搭建好场景，规定并且在Unity中配置好Layer和Tags，安装好要使用的Package。整理好项目文件，规定命名规则和使用规则。脚本，AudioMixer，动画机等等必须按照功能分文件存储。\n主程配置好项目后应该将项目文件分发给组员，组员在Unity Hub中导入该项目文件，在新电脑上Unity会自动完成上述配置。这种方式能确保没有遗漏。\n规定当完成一个GameObject的配置时，将其放入Prefabs文件夹中供其他人使用。\n如何导入 不同的程序员不要同时操作Unity的同一个Scene。项目合并可以通过Import Package和Export Package来完成。Import和Export会自动识别并合并项目中不同的文件，如果同名则新文件会覆盖旧文件。所以最好成员都在自己的Scene中工作。\n代码冲突需要借助其他冲突解决工具进行逐行Merge，不能使用上述功能。\n键盘按键轻重控制跳跃高低思路是取一个指标衡量按键轻重，通过这个值的变化来控制跳跃高低。\n这个指标可以是按键时间长短。这样需要注意的一个问题是：时长的统计不应该在按键松开时完成，而必须时刻判断当前距离按下跳跃键那个时刻过去了多久，如果Player的跳跃只有在松开时才进行那么会十分影响手感。\nif (Input.GetKeyDown(KeyCode.Space)) &#123;    jumpStartTime = Time.time;&#125;if (Input.GetKey(KeyCode.Space)) &#123;    jumpTimer = Time.time - jumpStartTime;    if (rb.gravityScale &gt; 1.5) &#123;        rb.gravityScale -= jumpTimer * 2;        if (rb.gravityScale &lt; 1.5) &#123;            rb.gravityScale = 1.5f;        &#125;    &#125;&#125;\n\n目前采取的是控制重力的方式来控制跳跃力度，确实能实现功能，但是效果并不理想，高低的区分度不大，同时也会延长下落的时间，距离空洞骑士那种平滑的跳跃和下落还差的远。\n控制加速度可能是个更好的选择。\n修改如下：\n//用于记录按下跳跃键长短，控制跳跃高度void MidAirJump() &#123;    if (Input.GetKeyDown(KeyCode.Space)) &#123;        jumpStartTime = Time.time;    &#125;    if (Input.GetKey(KeyCode.Space)) &#123;        jumpTimer = Time.time - jumpStartTime;        if (jumpTimer &lt; 0.1f &amp;&amp; jumpTimer &gt; 0.05f) &#123;            rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);        &#125;    &#125;&#125;\n\n将控制重力修改成了添加加速度，AddForce中填入一个二维的向量，分别表示在水平和竖直方向添加的加速度。ForceMode2D.Impulse是一种添加力的模式，这种模式的力就像是突然出现的一样。\njumpTimer &gt; 0.5f的原因是防止玩家不断地小按跳跃键，这样会导致Player可以不断获得一个向上的力，超越了二段跳。\n如何实现技能冷却的UI设置在Image中选择Filled的Image Type，其中有一个选项叫做Fill Amout，这个选项可以实现让一张Image按选定的方式加载。Fill Method中选定加载方式，以Radial 360为例子（扇形加载）实现Dash技能的CD图标。\n\n在UI中新建一张image，Source image中选择一张图片\n\n该image下新建一个子image，相同大小，相同位置，相同图标，颜色全黑，透明度调低\n\n对于该子image，image type选Filled，Method选Horizontal，Fill Origin选择Left， 初始的Fill Amout改为0，表示技能可用\n\n在脚本中新建一个Image对象，将父image拖拽，在Update中写上一句核心代码（记住就好）：\ncdImage.fillAmount -= 1.0f / dashCoolDown * Time.deltaTime;\ndashCoolDown表示冷却时间，该冷却条会在dashCoolDown时间内加载完成\n\n\n其他Sprite 和 UI Image 的区别​    详细戳我\n\n 在Hierarchy窗口,你可以把sprites随便放在哪。然而，UI Images不得不放在canvas下面。你可以通过transform移动其他obejcts那样移动sprites,但是images使用RectTransform来在界面系统中移动。 \n 性能上有十分大的差别，如下两张图所示，Sprite会生成更复杂的网格，所以Sprite开销更大。  \n\n            \n\n \n\n注意使用 Image 和 Text 需要添加 Using UnityEngine.UI。\nTrigger和Collider的区别Collider有碰撞的效果， 可以调用 OnCollisionEnter/ Stay / Exit 函数，分别是碰撞进入 / 逗留 / 离开。\nTrigger 只是触发器，没有碰撞效果， 可以调用 OnTriggerEnter/ Stay / Exit 函数。分别是触发进入/ 逗留 /离开。 \n不可以同时发生碰撞和触发。\n发生碰撞的必要条件\n两个物体都必须带有碰撞盒。\n至少有一个物体带有Rigidbody组件。\n两个物体要发生相对位移。\n\n动画系统中Trigger和Bool参数的区别Bool表示状态，当设置为true or false之后，不会自动回复原来的状态。\n而Trigger是一个触发器，当SetTrigger之后，会自动回复原来的状态。\nInput修改通过Edit - Project Setting 可以修改Input绑定的值\nSprite很糊\n 人物的 Sprite为什么看起来很模糊？\n\n可能并不是因为分辨率过低造成的，反而是过高而导致的显示问题，不用管。\n\n如何在同一帧内设置两张图片。例如人物挥刀时的挥刀动画和刀光的动画不能耦合在一起，如何让两种动画按指定方式显示？\n\n可以在角色下建立不同的Game Object，在指定动画中选择Add Property-Is Active。该Object默认为关闭，当进行到关键帧时设置Active为true。\nHas Exit Time\nInspector窗口中的Has Exit Time是指切换动画时是否要将当前动画播放完再切换，Exit Time的参数是指当前动画播放长度，0为不播放，1为完整播放\n\n下方Transition Duration是指过渡动画所需要的时间，在该时间内，动画A和动画B同时开始计时（如果设置了Exit Time，则过了Exit Time之后B才开始计时），在该时间内，会先播放动画A，大概过了一半左右的时间，切换到动画B\n\nany state是一个始终存在特殊状态，如其字面意思，可以通过它让任意一个状态切换到某个状态。其中有一个Can Transition To Self的选项，意思为是否允许重置自身状态\n\n\nCan Transition to Self当使用Any state切换到Jump动画时出现了Jump动画只播放第一帧的情况，当将any state的Can Transition To Self选项取消后解决，推测原因是每一帧都进行了Jump to Jump的切换。Can Transition To Self 的意思是允许自己切换到自己。\nUpdate和FixUpdate问题描述：发现有时二段跳手感有问题：\n\n当快速按下两次跳跃键时有很大概率无法触发二段跳\n下落时有时无法触发二段跳\n\n修改方法：\n\n将Movement()和CheckOnGround()函数放在FixUpdate中而不是Update中\n\n原因分析：\n\n一个老生常谈的问题，Update函数每一帧执行一次，FixUpdate函数每一秒执行50次。FixUpdate的诞生是为了解决Update在不同电脑上运行次数不同的缺陷。这种缺陷会导致GameObject的物理效果展现不自然，所以所有有关Rigidbody的代码都应该放在FixUpdate中\n\n控制子动画播放将要被叠加的动画所在的gameobject称作A，想要叠加上的动画所在的gameobject称为B，先将B设置为A的子gameobject。\n在A的Animation窗口中对于待叠加的动画选择Add Property，该选项可以控制子物体。\n确定具体的帧，控制B的is active，就可以控制其在某一帧的播放与否。\n\n修复了主角在空中攻击时二段跳无法切换二段跳动画的bug\n修复了在空中可能出现WalkStart的动画的bug\n\n","categories":["Unity"],"tags":["Zeal","序列化与反序列化","对象池"]},{"title":"设计模式模板","url":"/2021/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/","content":"致谢本文章大量参考了B站up主子烁爱学习的五分钟设计模式系列视频与GitHub用户CyC2018的开源博客。已获得转载许可。附上链接：子烁爱学习的空间CyC2018的设计模式目录\n什么是设计模式？设计模式是软件工程的基石，是现在合作开发工程化的理论基础。不同的设计模式是现实生活中不断重复发生的时间的核心解决方案。\n通俗来讲，就是前人总结出来的类和对象的写法，通过这种写法，能够让你的代码可以复用，不至于相同的功能写N遍；拓展性也好，能够很方便地应对变化的需求。\n所以实际上市面上教设计模式的书也可以改名成《代码这样写，产品经理再刁钻也不怕》。\n1 创建型1.1 单例模式（Singleton）确保类中只有一个实例，并提供该实例的全局访问点。\n1.1.1 懒汉式-线程不安全public class Singleton &#123;    //私有单例对象，保证只有这一个实例    private static Singleton uniqueInstance;        //私有构造方法，覆盖默认构造，保证无法new对象    private Singleton() &#123;    &#125;        //公有get方法，可以享受延迟实例化带来的内存优势，但是当多线程时可能出错    public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            uniqueInstance = new Singleton();        &#125;        return uniqueInstance;    &#125;&#125;\n\n1.1.2 饿汉式-线程安全//多线程安全，但是不能延迟实例化private static Singleton uniqueInstance = new Singleton();\n\n1.1.3 懒汉式-线程安全//使用synchronized关键字加锁，可以应对多线程情况，但是可能造成线程拥塞时间过长，有性能问题public static synchronized Singleton getUniqueInstance() &#123;    if (uniqueInstance == null) &#123;        uniqueInstance = new Singleton();    &#125;    return uniqueInstance;&#125;\n\n1.1.4 双重校验锁-线程安全public class Singleton &#123;        //valatile关键字可以禁止JVM指令重排，保证多线程环境下也能正常运行    private volatile static Singleton uniqueInstance;    private Singleton() &#123;    &#125;        //内部的if语句是为了应对多线程同时进入外层if的情况，如果没有内部if，当多个线程同时进入外层if时，那么必然会new出多个对象    public static Singleton getUniqueInstance() &#123;        if (uniqueInstance == null) &#123;            synchronized (Singleton.class) &#123;                if (uniqueInstance == null) &#123;                    uniqueInstance = new Singleton();                &#125;            &#125;        &#125;        return uniqueInstance;    &#125;&#125;\n\n1.1.5 静态内部类（推荐）//既有延迟初始化的好处，又有JVM对线程安全负责public class Singleton &#123;        private Singleton() &#123;    &#125;        //静态内部类    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;        public static Singleton getUniqueInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;\n\n\n\n1.2 简单工厂（SimpleFactory）创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口，也就是工厂。\n怎么理解工厂？将建造方法集成在一个类中，当要用到时就建立工厂（new SimpleFactory），然后通过工厂方法生产。\nProductpublic interface Product &#123;&#125;public class ConcreteProduct1 implements Product &#123;&#125;public class ConcreteProduct2 implements Product &#123;&#125;public class ConcreteProduct3 implements Product &#123;&#125;\n\nSimpleFactorypublic class SimpleFactory &#123;    public Product createProduct(int type) &#123;        if (type == 1) &#123;            return new ConcreteProduct1();        &#125; else if (type == 2) &#123;            return new ConcreteProduct2();        &#125; else if (type == 3) &#123;                return new ConcreteProduct3();        &#125;    &#125;&#125;\n\nClientpublic class Client &#123;    public static void main(String[] args) &#123;        SimpleFactory simpleFactory = new SimpleFactory();        Product product = simpleFactory.createProduct(1);        // do something with the product    &#125;&#125;\n\n1.3 工厂模式（Factory）定义一个创建对象的接口，此接口并不实例化类，由其子类来实例化，工厂方法将实例化操作推迟到了子类。\n实现public abstract class Factory &#123;    abstract public Product factoryMethod();    public void doSomething() &#123;        Product product = factoryMethod();        // do something with product    &#125;&#125;public class ConcreteFactory1 extends Factory &#123;    public Product factoryMethod() &#123;        return new ConcreteProduct1();    &#125;&#125;public class ConcreteFactory2 extends Factory &#123;    public Product factoryMethod() &#123;        return new ConcreteProduct2();    &#125;&#125;\n\n\n1.4 抽象工厂（AbstractFactory）提供一个接口，用于创建相关的对象家族。\n实现说明：可以将AbstractProduct理解为某一类产品，例如衣服类中的商务套装，商务套装包括上衣和裤子，需要一起使用。所以会让ProductA1和A2基础ProductA（B同理）。而用另一种分类法，上衣可以划分一类，裤子可以划分一类，对于工厂来说，这种划分方法更加科学。所以某一具体的工厂会按照这样的方式生产。\npublic class AbstractProductA &#123;&#125;public class AbstractProductB &#123;&#125;public class ProductA1 extends AbstractProductA &#123;&#125;public class ProductA2 extends AbstractProductA &#123;&#125;public class ProductB1 extends AbstractProductB &#123;&#125;public class ProductB2 extends AbstractProductB &#123;&#125;public abstract class AbstractFactory &#123;    abstract AbstractProductA createProductA();    abstract AbstractProductB createProductB();&#125;public class ConcreteFactory1 extends AbstractFactory &#123;    AbstractProductA createProductA() &#123;        return new ProductA1();    &#125;    AbstractProductB createProductB() &#123;        return new ProductB1();    &#125;&#125;public class ConcreteFactory2 extends AbstractFactory &#123;    AbstractProductA createProductA() &#123;        return new ProductA2();    &#125;    AbstractProductB createProductB() &#123;        return new ProductB2();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractFactory abstractFactory = new ConcreteFactory1();        AbstractProductA productA = abstractFactory.createProductA();        AbstractProductB productB = abstractFactory.createProductB();        // do something with productA and productB    &#125;&#125;\n\n\n1.5 生成器（Builder）封装一个复杂对象的构造过程，允许一步一步构造这个复杂对象而不是通过构造函数一次性建成。例如对于一个房屋对象，可以先构造其窗户对象，再构造门，墙，地板等等。\n实现public class BuildPattern &#123;    public static void main(String[] arts) &#123;        House house = new House.Builder();        house.setWindow(new Window());        house.setDoor(new Door());        house.setWall(new Wall());        house.build();    &#125;&#125;class House &#123;    private Window window;    private Door door;    private Wall wall;        public House(Builder builder) &#123;        this.window = builder.window;        this.door = builder.door;        this.wall = builder.wall;    &#125;        static final class Builder &#123;        private Window window;        private Door door;        private Wall wall;                  public Builder setWindow(Window window) &#123;            this.window = window;            return this;    //返回自己，很关键        &#125;                public Builder setDoor(Door door) &#123;            this.door = door;            return this;    //返回自己，很关键        &#125;                public Builder setWindow(Wall wall) &#123;            this.wall = wall;            return this;    //返回自己，很关键        &#125;                public House build() &#123;  //build方法用于返回house对象            return new House(builder.this);        &#125;    &#125;&#125;\n\n1.6 原型模式（Prototype）通过在类的内部实现一个克隆的方法，使得这个类可以很方便地被外部类克隆拿到属性值。\n实现interface Prototype &#123;    Object clone();&#125;class Plane() implements Prototype &#123;    private String name;    private String type;        public Plane() &#123;        //自己设定的name和type值    &#125;       public String getName() &#123;        return name;    &#125;        public String getType() &#123;        return type;    &#125;        public Object clone() &#123;        return new Plane(this);    &#125;&#125;\n\n2 行为型2.1 责任链模式（ResponsibilityChain）是一种处理请求的模式，它让多个处理器有机会处理该请求，知道某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。\n优点是将请求和处理分离开，请求者和处理者都不需要知道处理的全貌。也可以提高系统的灵活性，新增一个处理器代价小，不需要修改源代码。缺点是当链条比较长时性能会大幅下降，例如某个请求应该交给顶级BOSS处理，但是这个请求必须走个一整个完整的链条。\n实现abstract class Handler &#123;    protected Handler nextHandler;    public void setNextHandler(Handler nextHandler) &#123;        this.nextHandler = nextHandler;    &#125;        public abstract void process(int info);&#125;\n\nclass Leader extends Handler &#123;        @override    public void process(int info) &#123;        if (info &gt; 0 &amp;&amp; info &lt; 20)             System.out.println(“Leader处理！”);        else            nextHandler.process(info);    &#125;&#125;class Boss extends Handler &#123;        @override    public void process(int info) &#123;        System.out.println(“Boss处理！”);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Handler level1 = new Handler();        Handler level2 = new Handler();        level1.setNextHandler(level2);        level1.process(10);        level1.process(20);    &#125;&#125;\n\nLeader处理Boss处理\n\n2.2 命令模式（Command）命令模式可以将请求转化成为一个包含与请求相关的所有信息的独立对象。该转换能让你根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。\n实现//[图像渲染层]保存按钮class SaveButton &#123;    private Command command;        // 此处省略图像渲染过程        public void bindCommand(Command command) &#123;        this.command = command;    &#125;        public void doPrint() &#123;        if (command == null)             throw new RuntimeException(“设备初始化失败！”);        command.execute();    &#125;&#125;\n\n//[业务逻辑层]打印服务class PrintService &#123;    public void print(String text) &#123;        System.out.println(text);    &#125;&#125;\n\ninterface Command &#123;    public void execute();&#125;\n\nclass PrintCommand implements Command &#123;    private PrintService serviceProvider = new PrintService();    private TextBox text;        public PrintCommand(TextBox text) &#123;        this.text = text;    &#125;        @Override    public void execute() &#123;        serviceProvider.print(box.getContext());    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        SaveButton.saveButton = new SaveButton();        TextBox box = new TextBox();                PrintCommand printCommand = new PrintCommand(box);        saveButton.bindCommand(printCommand);                box.setContext(“ABCDEFG”);        saveButton.doPrint();                box.setContext(“ABCDEFGHIJK”);        saveButton.doPrint();    &#125;&#125;\n\n2.3 观察者模式（Observer）定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。\n\n\n实现天气数据布告板会在天气信息改变时更新其内容，布告板有多个，并且在将来会继续增加。\npublic interface Subject &#123;    void registerObserver(Observer o);    void removeObserver(Observer o);    void notifyObserver();&#125;\n\npublic class WeatherData implements Subject &#123;    private List&lt;Observer&gt; observers;    private float temperature;    private float humidity;    private float pressure;    public WeatherData() &#123;        observers = new ArrayList&lt;&gt;();    &#125;    public void setMeasurements(float temperature, float humidity, float pressure) &#123;        this.temperature = temperature;        this.humidity = humidity;        this.pressure = pressure;        notifyObserver();    &#125;    @Override    public void registerObserver(Observer o) &#123;        observers.add(o);    &#125;    @Override    public void removeObserver(Observer o) &#123;        int i = observers.indexOf(o);        if (i &gt;= 0) &#123;            observers.remove(i);        &#125;    &#125;    @Override    public void notifyObserver() &#123;        for (Observer o : observers) &#123;            o.update(temperature, humidity, pressure);        &#125;    &#125;&#125;\n\npublic interface Observer &#123;    void update(float temp, float humidity, float pressure);&#125;\n\npublic class StatisticsDisplay implements Observer &#123;    public StatisticsDisplay(Subject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;\n\npublic class CurrentConditionsDisplay implements Observer &#123;    public CurrentConditionsDisplay(Subject weatherData) &#123;        weatherData.registerObserver(this);    &#125;    @Override    public void update(float temp, float humidity, float pressure) &#123;        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);    &#125;&#125;\n\npublic class WeatherStation &#123;    public static void main(String[] args) &#123;        WeatherData weatherData = new WeatherData();        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);        weatherData.setMeasurements(0, 0, 0);        weatherData.setMeasurements(1, 1, 1);    &#125;&#125;\n\nCurrentConditionsDisplay.update: 0.0 0.0 0.0StatisticsDisplay.update: 0.0 0.0 0.0CurrentConditionsDisplay.update: 1.0 1.0 1.0StatisticsDisplay.update: 1.0 1.0 1.0\n\n2.4 中介者模式（Mediator）中介者模式通过设置一个中介者，能够减少对象之间混乱无序的依赖关系，该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作（就像计算机网络中的星型拓扑结构）。\n\n\n每个参与者Component都会维护一个Mediator中介者对象，通过该中介者来执行相关操作，而不是直接与其他参与者交互。\n实现以婚姻中介为例子，一个婚姻中介场所吸纳了很多会员，会员不需要与其他会员产生联系，婚姻中介会自动给其匹配。该例中婚姻中介即为中介者，而会员是参与者。\ninterface MarriageAgency &#123;    void register(Person person);   //注册会员    void pair(Person person);   //为person配对&#125;\n\nclass Person &#123;    int age;    Sex sex;    int requestAge; //要求对象年龄，此处找对象只有这一个要求，十分理想    MarriageAgency agency;  //婚姻中介    public Person(String name, int age, Sex sex, int requestAge,                  MarriageAgency agency) &#123;        this.name = name;        this.age = age;        this.sex = sex;        this.requestAge = requestAge;        this.agency = agency;        agency.register(person:this);   //注册会员    &#125;        public void findPartner() &#123;        agency.pair(person:this);   //与中介者交互    &#125;&#125;enum Sex &#123;    MALE, FEMALE;&#125;\n\nclass MarriageAgencyImpl implements MarriageAgency &#123;    List&lt;Person&gt; people = new ArrayList&lt;&gt;();    //女会员        public void register(Person person) &#123;        people.add(person);    &#125;        public void pair(Person person) &#123;        for (Person p : people) &#123;            if (p.age == person.requestAge &amp;&amp; p.sex != person.sex) &#123;                System.out.println(“配对成功“);            &#125;        &#125;    &#125;&#125;\n\n2.5 迭代器（Iterator）提供一种顺序访问聚合对象元素的方法，并且不暴露对象的内部表示。\n\n实现public interface Aggregate &#123;    Iterator createIterator();&#125;public class ConcreteAggregate implements Aggregate &#123;    private Integer[] items;    public ConcreteAggregate() &#123;        items = new Integer[10];        for (int i = 0; i &lt; items.length; i++) &#123;            items[i] = i;        &#125;    &#125;    @Override    public Iterator createIterator() &#123;        return new ConcreteIterator&lt;Integer&gt;(items);    &#125;&#125;\n\npublic interface Iterator&lt;Item&gt; &#123;    Item next();    boolean hasNext();&#125;public class ConcreteIterator&lt;Item&gt; implements Iterator &#123;    private Item[] items;    private int position = 0;    public ConcreteIterator(Item[] items) &#123;        this.items = items;    &#125;    @Override    public Object next() &#123;        return items[position++];    &#125;    @Override    public boolean hasNext() &#123;        return position &lt; items.length;    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Aggregate aggregate = new ConcreteAggregate();        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;\n\n2.6 备忘录模式（Memento）备忘录模式允许在不暴露对象内部细节的情况下保存和恢复对象之前的状态。\n\n\n实现class Document &#123;    private String content; //需要备份的数据        public Backup save() &#123;        return Backup(content);    &#125;        public void resume(Backup backup) &#123;        content = backup.content;    &#125;        public void change(String content) &#123;        this.content = content;    &#125;        public void print() &#123;        System.out.println(content);    &#125;&#125;\n\ninterface Memento &#123;    &#125;class Backup implements Memento &#123;    String content;        public Backup(String content) &#123;        this.content = content;    &#125;&#125;\n\nclass History &#123;    stack&lt;Backup&gt; backupStack = new Stack&lt;&gt;();        public void add(Backup backup) &#123;        backupStack.add(backup);    &#125;        public Backup getLastVersion() &#123;        return backupStack.pop();    &#125;&#125;\n\n2.7 状态模式（State）允许一个对象在其内部状态改变时改变他的行为，对象看起来似乎修改了他的类。状态模式是一种对象行为型模式。\n\n\n\n实现以张三为例，他在电子厂上班。他有多种状态，当状态不同时，他的行为不同。\nabstract class State &#123;    abstract void doWork();&#125;class Happy extends State &#123;    void doWork() &#123;        System.out.println(“积极主动”);    &#125;&#125;class Angry extends State &#123;    void doWork() &#123;        System.out.println(“暴躁易怒”);    &#125;&#125;class Sad extends State &#123;    void doWork() &#123;        System.out.println(“啥也不干”);    &#125;&#125;\n\nclass Context &#123;    private State state;        public void changeState(State state) &#123;        this.state = state;    &#125;        public void doSomething() &#123;        state.doWork();    &#125;&#125;\n\npublic class Client &#123;    public void static main(string[] args) &#123;        Context zhangsan = new Context();        zhangsan.changeState(new Happy());        zhangsan.doSomething();        zhangsan.changeState(new Sad());        zhangsan.doSomething();    &#125;&#125;\n\n2.8 策略模式（Strategy）定义一组算法，将每个算法都封装起来，并且使它们只见可以互换，策略模式让算法独立于使用它的客户变化而变化。\n\n与状态模式的比较如类图所示，状态模式和策略模式十分相似。不同点在于状态模式是通过状态转移来改变Context所组合的State对象，从而改变Context行为。而策略模式侧重点在于行为具体采用何种策略，并且可以灵活地更换不同的策略。\n实现public interface QuackBehavior &#123;    void quack();&#125;public class Quack implements QuackBehavior &#123;    public void quack() &#123;        System.out.println(“quack!”);    &#125;&#125;public class Squeak implements QuackBehavior&#123;    @Override    public void quack() &#123;        System.out.println(&quot;squeak!&quot;);    &#125;&#125;\n\npublic class Duck &#123;    private QuackBehavior quackBehavior;    public void performQuack() &#123;        if (quackBehavior != null) &#123;            quackBehavior.quack();        &#125;    &#125;    public void setQuackBehavior(QuackBehavior quackBehavior) &#123;        this.quackBehavior = quackBehavior;    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Duck duck = new Duck();        duck.setQuackBehavior(new Squeak());        duck.performQuack();        duck.setQuackBehavior(new Quack());        duck.performQuack();    &#125;&#125;\n\nsqueak!quack!\n\n2.9 模版方法模式（TemplateMethod）定义一个算法中操作的框架，而将一些步骤延迟到子类中。使得子类可以不改变这个算法的结构即可重定义该算法的某些特定步骤。\n\n实现以炒菜做饭为例子，Cooking中的Cook方法是算法的具体实现步骤，其中的某些步骤在父类中不做定义，而在具体子类再具体实现。\nabstract class Cooking &#123;    public abstract void step1();    public abstract void step2();    public void cook() &#123;        System.out.println(“做饭开始”);        step1();        step2();        System.out.println(“做饭结束”);    &#125;&#125;class CookingFood extends Cooking &#123;    public void step1() &#123;        System.out.println(“放鸡蛋和西红柿！”);    &#125;        public void step2() &#123;        System.out.println(“多放盐少放味精”);    &#125;&#125;\n\npublic class TemplateMethod &#123;    public static void main(String[] args) &#123;        Cooking cooking = new CookingFood();        cooking.cook();    &#125;&#125;\n\n2.10 访问者模式（Visitor）用于封装一些作用于某种数据结构中各元素的操作，它可以在不改变该数据结构的条件下定义作用于这些数据结构的新操作。\n实现interface Visitor &#123;    void visitCPU(CPU cpu);&#125;class UpdateVisitor implements Visitor &#123;    public void visitCPU(CPU cpu) &#123;        cpu.command += “:1+1=2”;    &#125;&#125;\n\nclass EggRobot &#123;    private CPU cpu;        public EggRobot() &#123;        this.cpu = new CPU(command:”记住1+1=1”);    &#125;        public void calc() &#123;        cpu.run();    &#125;        public void accept(Visitor vis) &#123;        cpu.accept(vis);    &#125;&#125;abstract class Hardware &#123;    String command;    public Hardware(String command) &#123;        this.command = command;    &#125;        public void run() &#123;        System.out.println(command);    &#125;        public abstract void accept(Visitor);&#125;class CPU extends Hardware &#123;    public CPU(String command) &#123;        super(command);    &#125;        public void accept(Visitor visitor) &#123;        visitor.visitCPU(this);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        EggRobot erDan = new EggRobot();        erDan.calc();        Visitor updatePack = new UpdateVisitor();        erDan.accept(updatePack);        erDan.calc();    &#125;&#125;\n\n\n\n3 结构型结构型模式是指将对象和类组装成一个更大的结构，同时保持结构的灵活和高效。\n3.1 适配器模式（Adapter）通过适配器将一个类的接口转换成另一个用户需要的接口。\n实现鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack 方法，而 Turkey 调用 gobble方法。\n要求将 Turkey 的 gobble 方法适配成 Duck 的 quack 方法，从而让火鸡冒充鸭子！\npublic interface Duck() &#123;    void quack();&#125;public interface Turkey() &#123;    void gobble();&#125;public class WildTurkey implements Turkey &#123;    @Override    public void gobble() &#123;        System.out.println(“gobble”);    &#125;&#125;//火鸡适配器，继承自Duck，但是用类内部火鸡对象覆写quack方法，让鸭子发出火鸡的声音public class TurkeyAdapter implements Duck &#123;    Turkey turkey;        public TurkeyAdapter(Turkey turkey) &#123;        this.turkey = turkey;    &#125;        @Override    public void quack() &#123;        System.out.println(“gobble”);    &#125;&#125;public class Client &#123;    public static void main(String[] arts) &#123;        Turkey turkey = new WildTurkey();        //来自火鸡适配器的鸭子，从发声的角度来说时假鸭子，真火鸡        Duck duck = new TurkeyAdapter(turkey);        duck.quack();    &#125;&#125;\n\n3.2 装饰器模式（Decorator）为对象（不是类）动态（非静态）的添加功能。\n说明所谓装饰，就是将带有新功能的装饰物套在某个对象身上，这样就不用修改其原来的类也能让其拥有新功能。与继承的区别在于：适配器是对对象的功能拓展，并且适配器是动态的二继承是静态的。\n实现以饮料和配料为例。\n设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。\n下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost 方法，外层类的 cost 方法调用了内层类的 cost 方法。\n//饮料接口，之后要用具体的配料来实现这个接口，可返回实现这个接口的饮料的对象public interface Beverage &#123;    double cost();&#125;public class DarkRoast implements Beverage &#123;    @Override    public double cost() &#123;        return 1;    &#125;&#125;public class HouseBlend implements Beverage &#123;    @Override    public double cost() &#123;        return 1;    &#125;&#125;public abstract class CondimentDecorator implements Beverage &#123;    protected Beverage beverage;&#125;public class Milk extends CondimentDecorator &#123;    public Milk(Beverage beverage) &#123;        this.beverage = beverage;    &#125;    @Override    public double cost() &#123;        return 1 + beverage.cost();    &#125;&#125;public class Mocha extends CondimentDecorator &#123;    public Mocha(Beverage beverage) &#123;        this.beverage = beverage;    &#125;    @Override    public double cost() &#123;        return 1 + beverage.cost();    &#125;&#125;\n\npublic class Client &#123;        public static void main(String[] arts) &#123;        Beverage beverage = new HouseBlend();        //添加抹茶配料，抹茶配料会返回        beverage = new Mocha(beverage);        beverage = new Milk(beverage);        System.out.println(beverage.cost()); // 3    &#125;&#125;\n\n3.3 桥接模式（Bridge）将抽象和实现分离开，使它们可以独立变化。\n成果是将继承关系转变为关联关系，可以将一个复杂类的不同类型的功能解耦出来，便于独立添加新功能。\n缺点是对于抽象思维能力要求比较高，需要熟知类的特点。\n实现RemoteControl 表示遥控器，指代 Abstraction。\nTV 表示电视，指代 Implementor。\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\npublic abstract class TV &#123;    public abstract void on();    public abstract void off();    public abstract void tuneChannel();&#125;public class Sony extends TV &#123;    @Override    public void on() &#123;        System.out.println(&quot;Sony.on()&quot;);    &#125;    @Override    public void off() &#123;        System.out.println(&quot;Sony.off()&quot;);    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;Sony.tuneChannel()&quot;);    &#125;&#125;public class RCA extends TV &#123;    @Override    public void on() &#123;        System.out.println(&quot;RCA.on()&quot;);    &#125;    @Override    public void off() &#123;        System.out.println(&quot;RCA.off()&quot;);    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;RCA.tuneChannel()&quot;);    &#125;&#125;public abstract class RemoteControl &#123;    protected TV tv;    public RemoteControl(TV tv) &#123;        this.tv = tv;    &#125;    public abstract void on();    public abstract void off();    public abstract void tuneChannel();&#125;public class ConcreteRemoteControl1 extends RemoteControl &#123;    public ConcreteRemoteControl1(TV tv) &#123;        super(tv);    &#125;    @Override    public void on() &#123;        System.out.println(&quot;ConcreteRemoteControl1.on()&quot;);        tv.on();    &#125;    @Override    public void off() &#123;        System.out.println(&quot;ConcreteRemoteControl1.off()&quot;);        tv.off();    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;ConcreteRemoteControl1.tuneChannel()&quot;);        tv.tuneChannel();    &#125;&#125;public class ConcreteRemoteControl2 extends RemoteControl &#123;    public ConcreteRemoteControl2(TV tv) &#123;        super(tv);    &#125;    @Override    public void on() &#123;        System.out.println(&quot;ConcreteRemoteControl2.on()&quot;);        tv.on();    &#125;    @Override    public void off() &#123;        System.out.println(&quot;ConcreteRemoteControl2.off()&quot;);        tv.off();    &#125;    @Override    public void tuneChannel() &#123;        System.out.println(&quot;ConcreteRemoteControl2.tuneChannel()&quot;);        tv.tuneChannel();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());        remoteControl1.on();        remoteControl1.off();        remoteControl1.tuneChannel();        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());        remoteControl2.on();        remoteControl2.off();        remoteControl2.tuneChannel();    &#125;&#125;\n\n3.4 组合模式（Composite）将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合关系。\n组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。\n组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。\n\n实现public abstract class Component &#123;    protected String name;    public Component(String name) &#123;        this.name = name;    &#125;    public void print() &#123;        print(0);    &#125;    abstract void print(int level);    abstract public void add(Component component);    abstract public void remove(Component component);&#125;\n\npublic class Composite extends Component &#123;    private List&lt;Component&gt; child;    public Composite(String name) &#123;        super(name);        child = new ArrayList&lt;&gt;();    &#125;    @Override    void print(int level) &#123;        for (int i = 0; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(&quot;Composite:&quot; + name);        for (Component component : child) &#123;            component.print(level + 1);        &#125;    &#125;    @Override    public void add(Component component) &#123;        child.add(component);    &#125;    @Override    public void remove(Component component) &#123;        child.remove(component);    &#125;&#125;\n\npublic class Leaf extends Component &#123;    public Leaf(String name) &#123;        super(name);    &#125;    @Override    void print(int level) &#123;        for (int i = 0; i &lt; level; i++) &#123;            System.out.print(&quot;--&quot;);        &#125;        System.out.println(&quot;left:&quot; + name);    &#125;    @Override    public void add(Component component) &#123;        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点    &#125;    @Override    public void remove(Component component) &#123;        throw new UnsupportedOperationException();    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Composite root = new Composite(&quot;root&quot;);        Component node1 = new Leaf(&quot;1&quot;);        Component node2 = new Composite(&quot;2&quot;);        Component node3 = new Leaf(&quot;3&quot;);        root.add(node1);        root.add(node2);        root.add(node3);        Component node21 = new Leaf(&quot;21&quot;);        Component node22 = new Composite(&quot;22&quot;);        node2.add(node21);        node2.add(node22);        Component node221 = new Leaf(&quot;221&quot;);        node22.add(node221);        root.print();    &#125;&#125;\n\nComposite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3\n\n3.5 外观模式（Facade）提供一个统一的接口，用于访问子系统中的一群接口，提供便利。\n缺点是违反了开闭原则，如果添加了新的子系统，需要修改Facade类的代码。\n\n\n实现以看电影为例子，看电影需要启动很多电器，在外观模式中提供一个方法统一启动这些电器。\npublic class SubSystem &#123;    public void turnOnTV() &#123;        System.out.println(“turnOnTV()”);    &#125;        public void setCD(String cd) &#123;        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);    &#125;        public void startWatching()&#123;        System.out.println(&quot;startWatching()&quot;);    &#125;&#125;\n\npublic class Facade &#123;    private SubSystem subSys = new SubSystem();        public void watchMovie() &#123;        subSys.turnOnTV();        subSys.setCD(“巡礼之年”);        subSys.startWatching();    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        Facade facade = new Facade();        facade.watchMovie();    &#125;&#125;\n\n3.6 享元模式（Flyweight）利用共享的方式来支持大量的细粒度对象，这些对象一部分内部状态是相同的。\n\n实现public interface Flyweight &#123;    void doOperation(String exState);&#125;\n\npublic class ConcreteFlyweight implements Flyweight &#123;    private String intrinsicState;    public ConcreteFlyweight(String intrinsicState) &#123;        this.intrinsicState = intrinsicState;    &#125;    @Override    public void doOperation(String extrinsicState) &#123;        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);    &#125;&#125;\n\npublic class FlyweightFactory &#123;        private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();        Flyweight getFlyweight(String inState) &#123;        if (!flyweights.containsKey(inState) &#123;            Flyweight fw = new ConcreteFlyweight(inState);            flyweights.put(inState, fw);        &#125;        return flyweights.get(inState);    &#125;&#125;\n\npublic class Client &#123;    public static void main(String[] args) &#123;        FlyweightFactory factory = new FlyweightFactory();        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);        flyweight1.doOperation(&quot;x&quot;);        flyweight2.doOperation(&quot;y&quot;);    &#125;&#125;\n\nObject address: 1163157884IntrinsicState: aaExtrinsicState: xObject address: 1163157884IntrinsicState: aaExtrinsicState: y\n\n3.7 代理模式（Proxy）代理模式为其他对象提供一种代理来控制对这个对象的访问。\n共有4种代理模式：远程代理，虚拟代理，保护代理和智能代理。\n虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。\n实现以下是一个虚拟代理的实现，模拟了图片延迟家在的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。\npublic interface Image &#123;    void showImage();&#125;\n\npublic class HighResolutionImage implements Image &#123;    private URL imageURL;    private long startTime;    private int height;    private int width;    public int getHeight() &#123;        return height;    &#125;    public int getWidth() &#123;        return width;    &#125;    public HighResolutionImage(URL imageURL) &#123;        this.imageURL = imageURL;        this.startTime = System.currentTimeMillis();        this.width = 600;        this.height = 600;    &#125;    public boolean isLoad() &#123;        // 模拟图片加载，延迟 3s 加载完成        long endTime = System.currentTimeMillis();        return endTime - startTime &gt; 3000;    &#125;    @Override    public void showImage() &#123;        System.out.println(&quot;Real Image: &quot; + imageURL);    &#125;&#125;\n\npublic class ImageProxy implements Image &#123;    private HighResolutionImage highResolutionImage;    public ImageProxy(HighResolutionImage highResolutionImage) &#123;        this.highResolutionImage = highResolutionImage;    &#125;    @Override    public void showImage() &#123;        while (!highResolutionImage.isLoad()) &#123;            try &#123;                System.out.println(&quot;Temp Image: &quot; + highResolutionImage.getWidth() + &quot; &quot; + highResolutionImage.getHeight());                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        highResolutionImage.showImage();    &#125;&#125;\n\npublic class ImageViewer &#123;    public static void main(String[] args) throws Exception &#123;        String image = &quot;http://image.jpg&quot;;        URL url = new URL(image);        HighResolutionImage highResolutionImage = new HighResolutionImage(url);        ImageProxy imageProxy = new ImageProxy(highResolutionImage);        imageProxy.showImage();    &#125;&#125;","categories":["设计模式"],"tags":["设计模式"]},{"title":"数据结构与算法","url":"/2021/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"数据范围反推复杂度及算法内容一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在∼为最佳。\n下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：\n\n，指数级别。dfs+剪枝，状态压缩dp。\n，。floyd，dp，高斯消元。\n，，。dp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford。\n，。块状链表，分块，莫队。\n，。各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，spfa，求凸包，求半平面交，二分，CDQ分治，整体二分。\n，和常数较小的 。单调队列、 hash、双指针扫描、并查集，kmp、AC自动机。常数比较小的 的做法：sort、树状数组、heap、dijkstra、spfa。\n，。双指针扫描、kmp、AC自动机、线性筛素数。\n，。判断质数。\n，。最大公约数，快速幂。\n，。高精度加减乘除。\n，。k表示位数，高精度加减，FFT/NTT。\n\n作者：yxc链接：https://www.acwing.com/blog/content/32/来源：AcWing\n1 基础算法1.1 快速排序在一次排序中找到一个位置，通过左右交换的方式使得该位置之前全部小于这个位置上的数（以升序为例），之后的数全部大于该位置上的数。由此确定序列中第一个数。然后以该位置为分界点分为左右两个序列，分别递归即可确定整个序列的排序。\n因为二分且递归，平均时间复杂度为。\n\n\n关于为什么i和j要取l-1和r+1：使用的是do while循环，每次先移动，再交换。do while和l-1，r+1的写法其实都有关边界，关于边界问题，建议直接背下来。\n为什么x要选取中间点，选取左边界和右边界也是可以的，只是中间点更加不容易出现最坏情况，所以推荐采用这种写法。\n\n\nvoid quickSort(int a[], int l, int r) {    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = a[l+r&gt;&gt;1];    while (i &lt; j) {        do i++; while (a[i] &lt; x);        do j--; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    }    quickSort(a, l, j);    quickSort(a, j+1, r);}\n\n1.2 归并排序归并排序的思想是：将序列中排好序的归并，得到一个新的更长的排好序的序列。最开始的序列长度为1（长度为1的序列一定排好序），逐渐扩大为2，再4，以此类推。\n因为序列长度由大到小，所以应该先递归，再进行其他操作。代码中的i表示的归并序列A的下标，j表示的是归并序列B的下标，k表示temp数组下标。temp数组的存在是必要的，用于存放归并好的A+B序列，并在结束归并后必须返还给原a数组，因为接下来的归并需要用到归并好的序列。\n归并排序稳定，时间复杂度为。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], n, temp[N];void mergeSort(int l, int r) {    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    mergeSort(l, mid);    mergeSort(mid + 1, r);        int i = l, j = mid + 1, k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= r) {        if (a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[j++];    }    while (i &lt;= mid) temp[k++] = a[i++];    while (j &lt;= r) temp[k++] = a[j++];        for (i = l, k = 0; i &lt;= r; i++, k++) a[i] = temp[k];}int main() {    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    mergeSort(0, n - 1);    for (int i = 0; i &lt; n; i++) printf(\"%d \", a[i]);        return 0;}\n\n1.3 二分二分有以下两种情况，两种情况的选择是先写check条件，根据条件判断r = mid或者r = mid + 1，再确定mid是否需要加1。\n版本1\n当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1，计算mid时不需要加1。\nint bsearch_1(int l, int r) {    while (l &lt; r) {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    return l;}\n\n版本2\n当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid，此时为了防止死循环，计算mid时需要加1。\nint bsearch_2(int l, int r) {    while (l &lt; r) {        int mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}\n\n对本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置，找不到就输出-1 -1。\n这里很明显需要求解两次二分，一次是某元素出现的起始位置，一次是终止位置，以下解法刚好演示了上述整数二分的两种可能。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, q, a[N];int main() {    scanf(\"%d%d\", &amp;n, &amp;q);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    while (q--) {        int x;        scanf(\"%d\", &amp;x);                int l = 0, r = n - 1;        while (l &lt; r) {            int mid = l + r &gt;&gt; 1;            if (a[mid] &gt;= x) r = mid;            else l = mid + 1;        }        if (a[l] != x) printf(\"-1 -1\\n\");        else {            printf(\"%d \", l);            int r = n - 1;            while (l &lt; r) {                int mid = l + r + 1 &gt;&gt; 1;                if (a[mid] &lt;= x) l = mid;                else r = mid - 1;            }            printf(\"%d\\n\", l);        }            }        return 0;}\n\n1.4 高精度\n高精度数据一般使用数组存储。\n\n1.4.1 高精度加法给定两个正整数（不含前导 0），计算它们的和。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) {    if (a.size() &lt; b.size()) return add(b, a);    int t = 0;    vector&lt;int&gt; res;    for (int i = 0; i &lt; a.size() || t; i++) {        t += a[i];        if (i &lt; b.size()) t += b[i];        res.push_back(t % 10);        t /= 10;    }    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    vector&lt;int&gt; a, b, res;    string s1, s2;    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.length() - 1; i &gt;=0; i--)        a.push_back(s1[i] - '0');    for (int i = s2.length() - 1; i &gt;=0; i--)        b.push_back(s2[i] - '0');    res = add(a, b);    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    return 0;}\n\n1.4.2 高精度减法给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) {    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i++) {        t = a[i] - t;        if (i &lt; b.size()) t -= b[i];        c.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    }    while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back();    return c;}int main() {    bool flag = true;   //是否a&gt;b    vector&lt;int&gt; a, b;    string s1 = \"\", s2 = \"\";    cin &gt;&gt; s1 &gt;&gt; s2;    for (int i = s1.length() - 1; i &gt;= 0; i--)         a.push_back(s1[i] - '0');    for (int i = s2.length() - 1; i &gt;= 0; i--)         b.push_back(s2[i] - '0');    if (a.size() &lt; b.size()) {        flag = false;    } else if (a.size() == b.size()) {        for (int i = a.size() - 1; i &gt;= 0; i--) {            if (a[i] &lt; b[i]) {                flag = false;                break;            } else if (a[i] &gt; b[i]) break;        }    }    vector&lt;int&gt; res;    if (flag) {        res = sub(a, b);    } else {        res = sub(b, a);        cout &lt;&lt; \"-\";    }    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    return 0;}\n\n1.4.3 高精度乘法给定两个非负整数（不含前导 0）A和B，请你计算A×B的值。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int b) {    vector&lt;int&gt; res;    int t = 0;    for (int i = 0; i &lt; A.size() || t; i++) {        if (i &lt; A.size()) t += b * A[i];        res.push_back(t % 10);        t /= 10;    }    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    string s;    int b;    vector&lt;int&gt; A, res;    cin &gt;&gt; s &gt;&gt; b;    for (int i = s.length() - 1; i &gt;= 0; i--)         A.push_back(s[i] - '0');    res = mul(A, b);    for (int i = res.size() - 1; i &gt;= 0; i--)         cout &lt;&lt; res[i];    return 0;}\n\n1.4.4 高精度除法给定两个非负整数（不含前导0）A和B，请你计算A/B的商和余数。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) {    r = 0;    vector&lt;int&gt; res;    for (int i = A.size() - 1; i &gt;= 0; i--) {        r = r * 10 + A[i];        res.push_back(r / b);        r %= b;    }    reverse(res.begin(), res.end());    while (res.size() &gt; 1 &amp;&amp; res.back() == 0)        res.pop_back();    return res;}int main() {    string s;    int b, r;    vector&lt;int&gt; A, res;    cin &gt;&gt; s &gt;&gt; b;    for (int i = s.length() - 1; i &gt;= 0; i--)        A.push_back(s[i] - '0');    res = div(A, b, r);    for (int i = res.size() - 1; i &gt;= 0; i--)        cout &lt;&lt; res[i];    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;    return 0;}\n\n1.5 前缀和1.5.1 一维前缀和\n输入一个长度为 n 的整数序列。接下来再输入 m 个询问，每个询问输入一对 l, r。对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。n，m可能比较大。\n\n适用于需要大量计算序列中某一部分和的情况。\n维护一个 s数组，其中s[i]表示的含义是前 i 个数据的和。求第 l 到第 r 个数的和时，只需要S[r] - s[l - 1]即可。\n#include &lt;iostream&gt;using namespace std;const int maxn = 1e5 + 10;int a[maxn], s[maxn];int main() {    int n, m, l, r;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;a[i]);        s[i] = s[i-1] + a[i];    }    for (int i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;l, &amp;r);        int res = s[r] - s[l-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.5.2 二维前缀和\n输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1, y1, x2, y2 表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。\n\ns[i][j]表示的是从 0, 0 到 i, j 的矩形中所有数的和。\n输入时s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];。\n输出时int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];。\n#include &lt;iostream&gt;using namespace std;int a[1010][1010], s[1010][1010];int main() {    int n, m, q;    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            scanf(\"%d\", &amp;a[i][j]);            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];        }    }    for (int i = 0; i &lt; q; i++) {        int x1, y1, x2, y2;        scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2);        int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.6 差分1.6.1 一维差分\n输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l, r, c, 表示将序列中 [l, r] 之间的每个数加上 c。请你输出进行完所有操作后的序列。n, m可能会很大。\n\n定义一个b数组，。理所应当b[1] = a[1]。\n由差分数组的定义可知，当批量修改某些连续的a[i]值时，只需对 b 数组两个数做修改，假设修改区间为[l, r]，那么只需要修改b[l]和b[r+1]即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int a[N], b[N];int main() {    int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;a[i]);        b[i] = a[i] - a[i-1];    }    while (m--) {        int l, r, c;        scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c);        b[l] += c;        b[r+1] -= c;    }    for (int i = 1; i &lt;= n; i++) {        a[i] = a[i-1] + b[i];        printf(\"%d \", a[i]);    }        return 0;}\n\n1.6.2 差分矩阵\n输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1, y1, x2, y2, c，其中 (x1, y1) 和 (x2, y2)  表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 c。请你将进行完所有操作后的矩阵输出。\n\n可以看成二维前缀和的逆运算，a[i][j] 等于b数组中从(0, 0)到(i, j)的和。b 数组的影响范围是其右下角。\n\n\n#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c) {    b[x1][y1] += c;    b[x2+1][y1] -= c;    b[x1][y2+1] -= c;    b[x2+1][y2+1] += c;}int main() {    int n, m, q;    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            scanf(\"%d\", &amp;a[i][j]);            insert(i, j, i, j, a[i][j]);        }    }    while (q--) {        int x1, y1, x2, y2, c;        scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);        insert(x1, y1, x2, y2, c);    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + b[i][j];            printf(\"%d \", a[i][j]);        }        printf(\"\\n\");    }    return 0;}\n\n1.7 位运算求n二进制的第k位数字：n &gt;&gt; k &amp; 1 返回n的最后一位二进制1(十进制)：n &amp; -n 或者直接用 lowbit(n)\n\n1.8 离散化离散化问题解决区间庞大但是实际使用的数不多的情况。思路是将使用到的区间点进行映射储存起来，使用时再查找。\n该代码涉及到的知识点包括二分，前缀和，离散化，比较综合，可以多看。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;  using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10;int n, m;int a[N], s[N]; //分别存储离散化后的下标对应数和前缀和vector&lt;int&gt; alls;   //离散之前的所有下标vector&lt;PII&gt; add, query; //表示添加和查询int find(int x) {    int l = 0, r = alls.size() - 1;    while (l &lt; r) {        int mid = l + r &gt;&gt; 1;        if (alls[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r + 1;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        int x, c;        scanf(\"%d%d\", &amp;x, &amp;c);        alls.push_back(x);        add.push_back({x, c});    }    for (int i = 0; i &lt; m; i++) {        int l, r;        scanf(\"%d%d\", &amp;l, &amp;r);        alls.push_back(l);        alls.push_back(r);        query.push_back({l, r});    }        sort(alls.begin(), alls.end());    alls.erase(unique(alls.begin(), alls.end()), alls.end());        for (auto item : add) {        int x = find(item.first);        a[x] += item.second;    }    for (int i = 1; i &lt;= alls.size(); i++) {        s[i] = s[i-1] + a[i];    }    for (auto item : query) {        int l = find(item.first);        int r = find(item.second);        int res = s[r] - s[l-1];        printf(\"%d\\n\", res);    }    return 0;}\n\n1.9 区间合并v[i].second = max(v[i].second, v[i-1].second);要用整个区间的最靠右的数值进行比较，以[1,9]，[2,3]，[4,5]来举例子，实际上这是一个区间，但是两两比较答案为2。\npair的默认sort排序规则是按从小到大顺序先排first，相等时再排second，这里正符合我们的预期。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;int main() {    int n;    scanf(\"%d\", &amp;n);    vector&lt;pii&gt; v;    for (int i = 0; i &lt; n ; i++) {        int l, r;        scanf(\"%d%d\", &amp;l, &amp;r);        v.push_back({l, r});    }        sort(v.begin(), v.end());        int res = n;        for (int i = 1; i &lt; n; i++) {        if (v[i].first &lt;= v[i-1].second) {            res--;            v[i].second = max(v[i].second, v[i-1].second);        }    }        cout &lt;&lt; res;        return 0;}\n\n2 数据结构2.1 单链表2.1.1 指针 + 结构体此处为含头指针的单向链表，实现了插入，删除，查找操作。\n做算法题目时不推荐用这种方法，因为要用到new字符，十分花时间，有很大可能会TLE，推荐用下面的数组方法。\nstruct node {    int data;    node* next;};node *head = new node;void insert(int pos, int x) {    node *p = head;    for (int i = 0; i &lt; pos; i++) {        p = p-&gt;next;       }    node *q = new node;    q-&gt;data = x;    q-&gt;next = p-&gt;next;    p-&gt;next = q;}void del(int pos) {    node *p = head;    for (int i = 0; i &lt; pos; i++) {        p = p-&gt;next;    }    p-&gt;next = p-&gt;next-&gt;next;}\n\n2.1.2 数组数组维护单链表的关键在于要存储每个节点的下标的值，ne[N]的作用就在此。此外head是一个头节点，本身并不存储任何数值，但是指向第一个存储数值的节点，head值为-1，第一个值节点下标为0。\n关于idx的必要性：idx表示现在插入了多少个数值，即使删除了部分节点，其idx依然可以表示它插入的顺序，这在某些题目中很有用。\n// head表示头节点下标，idx表示当前节点下标，e是当前的值，ne是下一个的下标const int N = 1e5 + 10;int e[N], ne[N], idx, head;// 初始化，无节点所以head指向-1，如果当前要插入节点，其下标应该为0// 所以idx为0void init() {    head = -1;    idx = 0;}// head储存第一个节点下标void insertHead(int x) {    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;}void insert(int k, int x) {    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;}void del(int k) {    ne[k] = ne[ne[k]];}\n\n2.2 双链表对于任何链表题目来说，都建议首先划出图形辅助理解。双链表的难点在于插入操作，插入操作需要操作四条线，别忘记了操作完成之后idx++。\n谨记访问上下节点是l[k]和r[k]，不是k-1或者k+1。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int e[N], l[N], r[N], idx;// 不定义头节点和尾节点，0表示左节点，1表示右节点void init() {    l[1] = 0, r[0] = 1;    idx = 2;}// 在下标是k的节点的右边，插入xvoid insert(int k, int x) {    e[idx] = x;    r[idx] = r[k];    l[idx] = k;    l[r[k]] = idx; // 这两行不可以调换位置    r[k] = idx;    idx++;}// 删除下标为k的节点void del(int k) {    l[r[k]] = l[k];    r[l[k]] = r[k];}int main() {    init();        int m, k, x;    cin &gt;&gt; m;    for (int i = 0; i &lt; m; i++) {        string op;        cin &gt;&gt; op;        // 记住下标是从2开始的，所以要加1        if (op == \"L\") {            cin &gt;&gt; x;            insert(0, x);        } else if (op == \"R\") {            cin &gt;&gt; x;            insert(l[1], x);        } else if (op == \"D\") {            cin &gt;&gt; k;            del(k + 1);        } else if (op == \"IL\") {            cin &gt;&gt; k &gt;&gt; x;            insert(l[k + 1], x);        } else {            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1, x);        }    }        for (int i = r[0]; i != 1; i = r[i])        cout &lt;&lt; e[i] &lt;&lt; \" \";        return 0;}\n\n2.3 栈模拟计算器#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;stack&gt;using namespace std;//存储运算数 运算符stack&lt;int&gt; num;stack&lt;char&gt; op;//建立映射来判断运算优先级unordered_map&lt;char, int&gt; pr = {    {'+', 1}, {'-', 1} , {'*', 2}, {'/', 2}};//模拟一次算术操作void eval(){    int b = num.top(); num.pop();    int a = num.top(); num.pop();    char opt = op.top(); op.pop();        int x;    if (opt == '+') x = a + b;    else if (opt == '-') x = a - b;    else if (opt == '*') x = a * b;    else if (opt == '/') x = a / b;        num.push(x);}int main(){    string str;    cin &gt;&gt; str;    for(int i = 0; i &lt; str.size(); i++){        char c = str[i];        //读入运算数        if(isdigit(c)){            int j = i, x = 0;            while(j &lt; str.size() &amp;&amp; isdigit(str[j])){                //j++ 迭代不能忘                 x = x * 10 + str[j++] - '0';            }            num.push(x);            //由于每轮循环有i++,我们需要倒指向最后一个数字            i = j - 1;        } else if( c == '(' ){            //标记一下，括号内数据            op.push(c);        } else if( c == ')' ){            //括号的优先级，先算括号            while( op.size() &amp;&amp; op.top() != '(' ) eval();            //左括号可以弹出            op.pop();        } else{            //得先把乘除法算了再算加减            //这里必须得带等于号 我们这题都是正整数计算            // 0 - 5 + 3             //如果不算，上式会被错误计算成 -8            while( op.size() &amp;&amp; pr[op.top()] &gt;= pr[c]) eval();            //压入新运算符            op.push(c);        }    }    //清理低优先级操作    while(op.size()) eval();    cout &lt;&lt; num.top() &lt;&lt; endl;        return 0;}\n\n2.4 单调栈最常见的情况就是求解序列中每个数左边最靠近它且最小的数。\n答案要求是尽可能靠近并且小于它，对于任意其左边某个值x，x左边所有大于等于x的值都没有意义，所以维护的栈必定时刻单调递增。\n只需不断将栈顶元素与当前值比较即可，st.top() &gt;= temp就弹出。\n#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        int temp;        cin &gt;&gt; temp;        while (!st.empty() &amp;&amp; st.top() &gt;= temp) st.pop();        if (st.empty()) cout &lt;&lt; -1 &lt;&lt; \" \";        else cout &lt;&lt; st.top() &lt;&lt; \" \";        st.push(temp);    }        return 0;}\n\n2.5 单调队列最常见问题就是求滑动窗口的最大最小值，以下即为滑动窗口问题。\n推荐使用数组写法，因为数组写法既可以操控队列头，还可以操纵队列尾，这道题目中二者都要用。所以stl中的queue是无法胜任的。不会数组写法的话也可以用deque。\n假设要访问一个滑动窗口的最小值，那么对于某个值来说，假设它更小一些，那么在它之前的所有比它大的值都没有意义，因为它们更加早出窗口，而且更大。所以可以时刻维持一个单调递增的队列，最大值镜像即可。\nif (!minq.empty() &amp;&amp; minq.front() &lt; i - k + 1) minq.pop_front();这句代码不可省略，作用是维系滑动窗口的大小。\nwhile循环处即是在维护队列的单调性，注意到此处用上了pop_bcak()，queue容器是没有该操作的。\n还有至关重要的一点是，队列中存储的是最小值or最大值的下标。\n#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;const int N = 1e6 + 10;int a[N];deque&lt;int&gt; minq, maxq;int main() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    for (int i = 0; i &lt; n; i++) {        if (!minq.empty() &amp;&amp; minq.front() &lt; i - k + 1)             minq.pop_front();        while (!minq.empty() &amp;&amp; a[i] &lt;= a[minq.back()])             minq.pop_back();        minq.push_back(i);        if (i &gt;= k - 1) printf(\"%d \", a[minq.front()]);    }    cout &lt;&lt; endl;    for (int i = 0; i &lt; n; i++) {        if (!maxq.empty() &amp;&amp; maxq.front() &lt; i - k + 1)             maxq.pop_front();        while (!maxq.empty() &amp;&amp; a[i] &gt;= a[maxq.back()])             maxq.pop_back();        maxq.push_back(i);        if (i &gt;= k - 1) printf(\"%d \", a[maxq.front()]);    }        return 0;}\n\n2.6 KMPKMP很难，最好天天练习，达到任何时候3分钟之内能将以下模版默写出来就算过关。\nne[i]表示p[i]之前的字符串的最长公共前后缀。\n为什么要求这个ne数组呢？因为KMP算法优化的原理就是当匹配到不相等的那一位时，通过已经得到的长串的后缀和短串的前缀匹配成功的最长长度，来确定短串的移动位置，而不是傻傻地让长串向下移动一个字符并让短串从头开始匹配。\nKMP的重点在于求ne数组，ne数组可以通过递推的方式求：如果p[ne[i-1]] = p[i - 1]，则说明ne[i] = ne[i - 1] + 1，别忘记了ne表示的是最长公共前后缀。如果不相等，则不断使j = ne[j]，直到相等为止。如果直到j = 0为止还是不相等，则判断p[0]和p[i - 1]的是否相等来决定ne[i]是0或1。\n为什么可以用上述求法，原理很复杂，来看这个解析。\n得到的ne虽然表示的是p字符串的最长前后缀匹配长度，但是因为这一段长度实际也是p和s匹配上的子字符串，所以具有传递性，也就是说，ne[i]实际可以表示最长的p字符串前缀和s字符串后缀相等的长度。\nne[0] = ne[1] = 0;这句代码是固定的，任何情况下都对，别忘记写。\nwhile循环中为什么要判断j是否为0？因为当j = 0时，ne[j] = 0，如果不判断的话会进入死循环。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;string s, p;    // s是长串，p是短串int n, m;int ne[N];  // ne[i]表示p字符串的最长公共前后缀int main() {    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;    ne[0] = 0;    ne[1] = 0; // 前后缀长度要小于字符串长度    for (int i = 2; i &lt; n + 1; i++) {        int j = ne[i - 1];        while (j &amp;&amp; p[j] != p[i - 1]) j = ne[j];        if (j != 0) ne[i] = j + 1;        else {            if (p[j] == p[i - 1]) ne[i] = 1;            else ne[i] = 0;        }    }    for (int i = 0, j = 0; i &lt; m; i++) {        while (j &amp;&amp; s[i] != p[j]) j = ne[j];        if (s[i] == p[j]) j++;        if (j == n) {            cout &lt;&lt; i - j + 1 &lt;&lt; \" \";        }    }        return 0;}\n\n2.7 并查集2.7.1 并查集现在有n个数，要进行m个操作，操作有两种，分别是M a b，将编号a和b的两个数合并入一个集合。Q a b，查询编号a和b的两个数是否在一个集合内。对于每一个Q查询，返回一个查询结果，YES或者NO。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, father[N];int find(int a) {   // 路径压缩    int x = a;    while (a != father[a]) a = father[a];    while (x != father[x]) {        int z = x;        x = father[x];        father[x] = a;    }    return a;}void merge(int a, int b) {    int fa = find(a), fb = find(b);    if (fa != fb) father[fa] = fb;}int main() {    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        father[i] = i;    }    while (m--) {        char c;        int a, b;        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;        if (c == 'M') merge(a, b);        else {            if (find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }        return 0;}\n\n2.7.2 带权并查集#include &lt;iostream&gt;using namespace std;const int N = 5e4 + 10;int p[N], d[N];  int find(int x) {    if (p[x] != x) {        int u = find(p[x]); // u是祖宗，在d[x]更新前，p[x]还不能变成祖宗        d[x] += d[p[x]];        p[x] = u;    }    return p[x];}int main() {    int n, k, cnt = 0;    scanf(\"%d%d\", &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++) {        p[i] = i;        d[i] = 0;    }    while (k--) {        int t, x, y;        scanf(\"%d%d%d\", &amp;t, &amp;x, &amp;y);        if (x &gt; n || y &gt; n) cnt++;        else {            int px = find(x), py = find(y);            if (t == 1) {                if (px == py &amp;&amp; (d[x] - d[y]) % 3) cnt++;                else if (px != py) {                    p[px] = py;                    d[px] = d[y] - d[x];                }            } else {                if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) cnt++;                else if (px != py) {                    p[px] = py;                    d[px] = d[y] + 1 - d[x];                }            }        }    }    cout &lt;&lt; cnt &lt;&lt; endl;        return 0;}\n\n2.8 堆2.8.1 模拟堆堆是完全二叉树，完全二叉树有个很棒的性质：假设某个根节点下标为x，那么其左子树下标为2x，右子树为2x + 1。这样用数组来储存读取起来很方便。\n模拟堆主要实现五个操作（以小根堆为例）：\n\n插入一个数\n求集合当中的最小值\n删除最小值\n删除任意一个元素\n修改任意一个元素\n\n这五个操作都可以用up和down两个方法来实现。down函数的作用是将某个不符合堆定义的节点不断下沉，直到其到达合适的位置，up同理。时间复杂度为。\n\nvoid down(int u) {    int t = u;    if (u * 2 &lt;= cur_size &amp;&amp; h[t] &gt; h[u * 2])        t = u * 2;    if (u * 2 + 1 &lt;= cur_size &amp;&amp; h[t] &gt; h[u * 2 + 1])        t = u * 2 + 1;    if (u != t) {        swap(h[u], h[t]);        down(t);    }}void up(int u) {    if (u / 2 &gt; 0 &amp;&amp; h[u] &lt; h[u / 2]) {        swap(h[u], h[u / 2]);        up(u / 2);    }}\n\n\n2.9 哈希表2.9.1 模拟散列表核心思路是将庞大的区间离散然后解决冲突问题，之前的离散化过程可以看作哈希的一种特殊情况——保序的离散化。\n根据解决冲突方式的不同分为开放寻址法和拉链法，下面代码为拉链法。拉链法原理是采用邻接表，每一个vector储存所有产生的值，例如说1e5 + 4和2e5 + 7离散值相同，都为1，则共同存放在v[1]中。\n为什么N取1e5 + 3而不是从前的1e5 + 10。1e5 + 3是大于1e5的最小质数，选择质数能使冲突的次数尽可能少，降低时间复杂度。\nint k = (x % N + N) % N这句代码是为了解决cpp中负数取模的问题。在数学上任何数取模都为正数，但是cpp中是负数。这句代码具有通用性，建议记下来。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 3;vector&lt;int&gt; v[N];void insert(int x) {    int k = (x % N + N) % N;    v[k].push_back(x);}bool find(int x) {    int k = (x % N + N) % N;    for (int i = 0; i &lt; v[k].size(); i++) {        if (x == v[k][i]) return true;    }    return false;}int main() {    int n, x;    cin &gt;&gt; n;    while (n--) {        char c;        cin &gt;&gt; c &gt;&gt; x;        if (c == 'I') {            insert(x);        } else {            if (find(x)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }        return 0;}\n\n2.9.2 字符串哈希字符串哈希功能十分强大，甚至有时候比KMP更强。\n主要思路是将字符转化成P进制的数字，经验表明当P取131或13331时冲突的概率十分十分小，所以可以将转换前后看作一一对应。\n转换后的数字可能非常大，要用unsigned long long存储，使用ull依然可能溢出，但是不用担心，溢出后会自动取余。\np[N]用来存储P的次方，因为cpp中写次方稍微麻烦一点，这种写法可以学习一下。\nh[r] - h[l - 1] * p[r - l + 1]这句话像前缀和的写法，其中r - l + 1是长度差。\n#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;const int N = 1e5 + 10; const int P = 131;  // 131为经验值，记住// 溢出就可取余ull h[N], p[N]; // h[N]存储转换后的数，p[N]存储P的n次方ull get(int l, int r) {    return h[r] - h[l - 1] * p[r - l + 1];}int main() {    int n, m;    string str;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str;        p[0] = 1;    for (int i = 1; i &lt;= n; i++) {        p[i] = p[i - 1] * P;        h[i] = h[i - 1] * P + str[i-1];   // 自动获取字符的ascii值    }        while (m--) {        int l1, r1, l2, r2;        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;        if (get(l1, r1) == get(l2, r2)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;        else cout &lt;&lt; \"No\" &lt;&lt; endl;    }        return 0;}\n\n2.10 Trie\nTrie树是用来高效地存储和查找字符串集合的数据结构。\n\n\n\n\n\n题目描述：维护一个字符串集合，支持两种操作：I x向集合中插入一个字符串x；Q x询问一个字符串在集合中出现了多少次。\nTrie树中有个二维数组son[N][26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1][0] = 2表示1结点的一个值为a的子结点为结点2。如果son[1][0] = 0，则意味着没有值为a子结点。这里的son[N][26]相当于链表中的ne[N]。\n从y总给出的代码可以看出，idx的操作总是idx++，这就保证了不同的idx值对应不同的结点。因此可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int son[N][26], cnt[N], idx; // son[1][0] = 2表示第一条子树的a下一个节点为2void insert(string s) {    int p = 0;    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u]) son[p][u] = ++idx;        p = son[p][u];    }    cnt[p]++;}int query(string s) {    int p = 0;    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    }    return cnt[p];}int main() {    int n;    cin &gt;&gt; n;    while (n--) {        string c, s;        cin &gt;&gt; c &gt;&gt; s;        if (c == \"I\") insert(s);        else cout &lt;&lt; query(s) &lt;&lt; endl;    }        return 0;}\n\n3 贪心3.1 区间贪心3.1.1 区间不相交记住是按右端点从小到大排序（也可以按左端点从大到小排序）。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;bool cmp(pii a, pii b) {    return a.second &lt; b.second;}int main() {    int n, res = 1;    cin &gt;&gt; n;    vector&lt;pii&gt; vp;    for (int i = 0; i &lt; n; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    int end = vp[0].second;    for (int i = 1; i &lt; n; i++) {        if (end &lt; vp[i].first) {            res++;            end = vp[i].second;        }    }    cout &lt;&lt; res;    return 0;}\n\n3.1.2 区间选点同上，如果都是闭区间问题的话代码完全相同。\n3.1.3 区间分组heap用来维护所有组的最大右端点，top()值表示的是所有最大右端点中最小的值，如果某个区间的左端点甚至小于等于这个最小值，那么说明它一定不能放进该组内，必须开一个新组heap.push(el.second);。\n如果一个区间的左端点比最小组的右端点要大，则放在该组中。heap.pop(), heap.push(el.second);。\n每组去除右端点最小的区间，只保留一个右端点较大的区间，这样heap有多少区间，就有多少组。\n时间复杂度是。\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; vp;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;bool cmp(pii a, pii b) {    return a.first &lt; b.first;}int main() {    int n, x, y;    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    for (int i = 0; i &lt; n; i++) {        pii el = vp[i];        if (heap.empty() || heap.top() &gt;= el.first)            heap.push(el.second);        else {            heap.pop();            heap.push(el.second);        }    }    cout &lt;&lt; heap.size();        return 0;}\n\n3.1.4 区间覆盖区间覆盖问题是指给定一个若干个闭区间区间，问其中至少选择多少个才能将某个给定的闭区间覆盖。\n核心思路是：\n\n按左端点从小到大排序（我们期望找到的区间应该是重叠长度尽可能少的，按这种排序方式符合我们的要求，甚至找到正好重叠的，极度满足强迫症）\n从前往后枚举找到左端点小于start并且end最大的区间\n用end更新start\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; vp;bool cmp(pii a, pii b) {    return a.first &lt; b.first;}int main() {    int st, ed, n, res = 0;    scanf(\"%d%d%d\", &amp;st, &amp;ed, &amp;n);    for (int i = 0; i &lt; n; i++) {        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        vp.push_back({x, y});    }    sort(vp.begin(), vp.end(), cmp);    bool flag = false;    for (int i = 0; i &lt; n; i++) {        int j = i, r = -2e9;        while (j &lt; n &amp;&amp; vp[j].first &lt;= st) {            r = max(r, vp[j].second);            j++;        }        if (r &lt; st) {   // 出现断层或者所有区间小于st            flag = false;            break;        }        res++;        if (r &gt;= ed) {            flag = true;            break;        }        i = j - 1;  // 那些end没有vp[j]大的都无用        st = r;    }    if (!flag) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n这里再来谈一个容易错的地方，一开始r &lt; st的判断我是这样写的：\nif (r &lt; st) {    cout &lt;&lt; -1 &lt;&lt; endl;    return 0;}\n\n这样写是会报错的，无法通过以下用例\n1 52-1 32 4\n\n后来改成以下代码就成功通过了，原因是成功的判断条件只有一个，那就是r &gt;= ed，哪怕是正常结束循环也可能无法覆盖，所以需要添加一个flag来判断成功与否。\nif (r &lt; st) {    flag = false;    break;}\n\n3.2 推公式\nN只奶牛决定叠罗汉。表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。\n\n这道题的贪心衡量指标是w + s，w + s小的要放在更上面。\n证明方法是将中间任意两头牛进行交换，得到交换前后的最大风险值，可以发现当w + s更小值在上时，得到的最大风险值更小。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; v;int main() {    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++) {        int w, s;        cin &gt;&gt; w &gt;&gt; s;        v.push_back({w + s, s});    }    sort(v.begin(), v.end());    int res = -2e9, sum = 0;    for (int i = 0; i &lt; n; i++) {        int s = v[i].second, w = v[i].first - s;        res = max(res, sum - s);        sum += w;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n4 图4.1 拓扑排序首先说明一下，拓扑排序和快排，归并排序，堆排序这样对一个序列的排序是不同的。拓扑排序是对图的排序，简而言之一句话就是如果我是你的父节点，我就一定出现在你前面。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, d[N];vector&lt;int&gt; v[N], res;queue&lt;int&gt; q;bool topoSort() {    for (int i = 1; i &lt;= n; i++) {        if (d[i] == 0) {            q.push(i);        }    }    while (!q.empty()) {        int u = q.front(); q.pop();        res.push_back(u);        for (int i = 0; i &lt; v[u].size(); i++) {            int j = v[u][i];            d[j]--;            if (d[j] == 0) {                q.push(j);            }        }    }    if (res.size() == n) return true;    else return false;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        v[a].push_back(b);        d[b]++;    }    if (topoSort()) {        for (int i = 0; i &lt; n; i++) {            cout &lt;&lt; res[i] &lt;&lt; \" \";        }       } else cout &lt;&lt; -1;    return 0;}\n\n4.2 朴素Dijkstra结构体写法可以换成pair，可以加快一些运行速度。\n其中最不好理解的一部分大概就是求解未到达点中距离最小的一个点。事实上，这也是时间复杂度的原因。朴素Dijkstra只能处理稀疏图（稀疏稠密都是指边）。\n时间复杂度为。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3fffffff;int n, m, d[N];vector&lt;pii&gt; g[N];bool vis[N];void Dijkstra(int s) {    fill(d, d + N, INF);    d[s] = 0;    for (int i = 0; i &lt; n; i++) {        int u = -1, minn = INF;        for (int j = 0; j &lt; n; j++) {            if (!vis[j] &amp;&amp; minn &gt; d[j]) {                minn = d[j];                u = j;            }        }        if (u == -1) return;        vis[u] = true;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (!vis[v] &amp;&amp; d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;            }        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    while (m--) {        int a, v ,dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    Dijkstra(1);    int res = d[n] == INF ? -1 : d[n];    printf(\"%d\", res);    return 0;}\n\n4.3 堆优化Dijkstra堆优化Dijkstra优化了求解最小距离的部分，时间复杂度降低到了。既可以处理稀疏图，也可以处理稠密图。\n堆优化当然更好，考试时优先写堆优化的Dijkstra。\n用邻接表来存储图的话，不用care自环，反正根据算法必定会求得一个最短路径。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3fffffff;int n, m, d[N];vector&lt;pii&gt; g[N];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;bool vis[N];void Dijkstra_Heap(int s) {    fill(d, d + N, INF);    d[s] = 0;    heap.push({0, s});    while (!heap.empty()) {        pii p = heap.top(); heap.pop();        int u = p.second;        if (vis[u]) continue;        vis[u] = true;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (!vis[v] &amp;&amp; d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;                heap.push({d[v], v});            }        }    }}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    while (m--) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    Dijkstra_Heap(1);    int res = d[n] == INF ? -1 : d[n];    printf(\"%d\", res);        return 0;}\n\n4.4 Bellman-FordBellman-Ford算法可以求负环，请注意，当有负环而且最短路径可以经过负环时，最短路径是不存在的，因为当不限定次数的时候，可以无限经过该负环使最短路径降低为负无穷。\nBellman算法的原理是首先遍历所有点，每一次遍历都可以确定最短路径树某一层的最短路径。到第n-1次时即可确定整个n层的树的最短。（可以证明，最短路径树一定不超过n层）。这个时候再判断，如果还能修改最短路径，那一定存在负环。\nBellman算法的时间复杂度是。时间复杂度很高，一般不用。\n时间复杂度高是因为内层不知道哪一条边可以松弛，所以傻傻地遍历所有边，实际上可以判断出一定是某一条刚刚更新过的，确定了最短路径的边才会更新新的边。这种改进就是SPFA。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 510, M = 1e4 + 10, INF = 0x3fffffff;int n, m, k;int d[N], backup[N];vector&lt;pii&gt; g[M];int Bellman(int s) {    memset(d, 0x3f3f3f3f, sizeof d);    d[s] = 0;    for (int i = 0; i &lt; k; i++) {        memcpy(backup, d, sizeof d);        for (int u = 1; u &lt;= n; u++) {            for (int j = 0; j &lt; g[u].size(); j++) {                int v = g[u][j].first;                int dis = g[u][j].second;                d[v] = min(d[v], backup[u] + dis);            }        }    }    if (d[n] &gt; 0x3f3f3f3f / 2) return -1;    else return d[n];}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    int t = Bellman(1);    if (t == -1) cout &lt;&lt; \"impossible\";    else cout &lt;&lt; t;    return 0;}\n\n4.5 SPFA4.5.1 SPFA求最短路径st数组的作用是判断哪些点在队列中，一个点不需要重复加入队列，更新新值即可。虽然不用判断也可以，但是加上st数组可以加快速度。\n平均时间复杂度是，最坏时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3f3f3f3f;int n, m, d[N];vector&lt;pii&gt; g[N];bool st[N];queue&lt;int&gt; q;int spfa(int s) {    fill(d, d + N, INF);    d[s] = 0;    q.push(s);    st[s] = true;    while (!q.empty()) {        int u = q.front(); q.pop();        st[u] = false;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (d[v] &gt; d[u] + dis) {                d[v] = d[u] + dis;                if (!st[v]) {                    q.push(v);                    st[v] = true;                }            }        }    }    if (d[n] == INF) return -1;    else return d[n];}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    int t = spfa(1);    if (t == -1) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; t &lt;&lt; endl;    return 0;}\n\n4.5.2 SPFA判断负环几乎没有变化，但是注意初始时不再是将1加入队列，而是要将所有点加入队列，因为有时候负环存在但是从1开始到达n不会经过负环。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 10, INF = 0x3f3f3f3f;int n, m, d[N], cnt[N];vector&lt;pii&gt; g[N];bool st[N];queue&lt;int&gt; q;bool spfa() {    fill(d, d + N, INF);    for (int i = 1; i &lt;= n; i++) {        q.push(i);        st[i] = true;    }    while (!q.empty()) {        int u = q.front(); q.pop();        st[u] = false;        for (int i = 0; i &lt; g[u].size(); i++) {            int v = g[u][i].first;            int dis = g[u][i].second;            if (d[v] &gt; d[u] + dis) {                cnt[v] = cnt[u] + 1;                if (cnt[v] &gt;= n) return true;                d[v] = d[u] + dis;                if (!st[v]) {                    q.push(v);                    st[v] = true;                }            }        }    }    return false;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, v, dis;        scanf(\"%d%d%d\", &amp;a, &amp;v, &amp;dis);        g[a].push_back({v, dis});    }    if (spfa()) cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else cout &lt;&lt; \"No\" &lt;&lt; endl;    return 0;}\n\n4.6 Floyd求解全源最短路径，原理是简单动态规划，最外层k循环逐层确定最短路径，下一层就可以用上一层的结论，当以k节点作为中介点可以更小时更新。\n初始化邻接矩阵要考虑自环。\n时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 210, INF = 0x3fffffff;int d[N][N];int n, m, q;void floyd() {    for (int k = 1; k &lt;= n; k++)        for (int i = 1; i &lt;= n; i++)             for (int j = 1; j &lt;= n; j++)                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= n; j++) {            if (i == j) d[i][j] = 0;            else d[i][j] = INF;        }    }    while (m--) {        int a, b, dis;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;dis);        d[a][b] = min(d[a][b], dis);    }    floyd();    while (q--) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        if (d[a][b] &gt; INF / 2) cout &lt;&lt; \"impossible\" &lt;&lt; endl;        else cout &lt;&lt; d[a][b] &lt;&lt; endl;    }        return 0;}\n\n4.7 PrimPrim算法步骤和Dijkstra十分相似。\nprim算法步骤如下：\n\n遍历n次，每次遍历首先找到集合外距离最近的点t。\n用t更新其他点到集合的距离。（这是和Dijkstra不同的地方，到集合的距离是指到集合中的点的最小距离）\n\n这一段代码和Dijkstra算法唯一不同的地方就在于d[]表示的含义不同，这里是表示到集合的距离。\n和Dijkstra一样，时间复杂度是，如果使用heap优化的话可以降低到。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 510, INF = 0x3f3f3f3f;int n, m, d[N];vector&lt;PII&gt; g[N];bool vis[N];int prim() {    int res = 0;    fill(d, d + N, INF);    d[1] = 0;    for (int i = 0; i &lt; n; i++) {        int u = -1, minn = INF;        for (int j = 1; j &lt;= n; j++) {            if (!vis[j] &amp;&amp; d[j] &lt; minn) {                minn = d[j];                u = j;            }        }        vis[u] = true;        if (u == -1) return INF;        res += d[u];        for (int j = 0; j &lt; g[u].size(); j++) {            int v = g[u][j].first;            int dis = g[u][j].second;            if (!vis[v] &amp;&amp; d[v] &gt; dis) {    //唯一不同的地方                d[v] = dis;            }        }    }    return res;}int main() {    cin &gt;&gt; n &gt;&gt; m;    while (m--) {        int a, b, dis;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dis;        g[a].push_back({b, dis});        g[b].push_back({a, dis});    }    int t = prim();    if (t == INF) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; t &lt;&lt; endl;        return 0;}\n\n4.8 Kruskalkruskal算法采用边贪心的策略，初始时隐去图中所有边，这样图中每个顶点都自成一个联通块。之后执行下面的步骤：\n\n对所有边按边权从小到大进行排序。\n按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个联通块中，则把这条测试边加入当前最小生成树中，否则舍弃。\n重复执行2，直到最小生成树中的边数等于总顶点数减1或是所有边测试完。结束时如果最小生成树边数小于总顶点数减1，说明该图不连通。\n\n排序保证最小，两个顶点非同一连通块才合并保证不会成图。合并过程需要用到并查集。\n时间复杂度是。可见kruskal算法适用于稀疏图。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10, M = 2 * N, INF = 0x3f3f3f3f;int n, m;int father[N];struct edge {    int a, b, dis;  } e[M];bool cmp(edge a, edge b) {    return a.dis &lt; b.dis;}int find(int a) {    int x = a;    while (a != father[a]) {        a = father[a];    }    while (x != father[x]) {        x = father[x];        father[x] = a;    }    return a;}int kruskal() {    sort(e, e + m, cmp);    for (int i = 1; i &lt;= n; i++) {        father[i] = i;    }    int res = 0, num = 0;    for (int i = 0; i &lt; m; i++) {        int fa = find(e[i].a), fb = find(e[i].b);        if (fa != fb) {            father[fa] = fb;            res += e[i].dis;            num++;            if (num == n - 1) break;        }    }    if (num &lt; n - 1) return INF;    else return res;}int main() {    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++) {        int a, b, dis;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dis;        e[i] = {a, b, dis};    }    int res = kruskal();    if (res == INF) cout &lt;&lt; \"impossible\" &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n5 数学5.1 素数5.1.1 试除法判断素数for循环中条件写i &lt;= n / i而不是i * i &lt;= n主要是为了防止溢出。对了，记住一定是&lt;=而不是&lt;，可以举一个反例比如说49。\nbool isPrime(int n) {    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i++) {        if (n % i == 0) return false;    }    return true;}\n\n5.1.2 试除法分解质因数\n给出一个数x，求得该数的所有质因数的底数和指数。\n\n方法是从头枚举每一个可能的因数，因为从头枚举，所以当某一个数i被枚举时，它的所有倍数一定不会被枚举，这就使得if (x % i == 0)条件成立时的每一个数一定是质数。\n一个数x的所有因数中，最多只存在一个大于sqrt(x)的数，所以单独判断就好，这样可以大幅降低时间复杂度。\nvoid divide(int x) {    for (int i = 2; i &lt;= x / i; i++) {        if (x % i == 0) {            int s = 0;            while (x % i == 0) {                x /= i;                s++;            }            printf(\"%d %d\\n\", i, s);        }    }    if (x &gt; 1) printf(\"%d %d\\n\", x, 1);    printf(\"\\n\");}\n\n5.1.3 埃氏筛法求素数个数\n给出一个数n，求1—n之间素数个数。\n\n只筛选素数的倍数即可。st[N]表示是否非素数。\nconst int N = 1e6 + 10;int prime[N], cnt;bool st[N] = {false};void getPrime(int n) {    for (int i = 2; i &lt;= n; i++) {        if (!st[i]) {            prime[cnt++] = i;            for (int j = i + i; j &lt;= n; j += i) {                st[j] = true;            }        }     }}\n\n5.2 约数\n如果 N = p1^c1 * p2^c2 * … *pk^ck约数个数： (c1 + 1) * (c2 + 1) * … * (ck + 1)约数之和： (p1^0 + p1^1 + … + p1^c1) * … * (pk^0 + pk^1 + … + pk^ck)\n\n5.2.1 约数的个数\n给定n个正整数ai，请你输出这些数的乘积的约数的个数，答案对1e9+7取模。\n\n用哈希表存储质因数的个数，res * (prime.second + 1)过程可能爆int所以要用long long。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;typedef long long LL;unordered_map&lt;int, int&gt; primes;int main() {    int n;    cin &gt;&gt; n;    while (n--) {        int x;        cin &gt;&gt; x;        for (int i = 2; i &lt;= x / i; i++) {            if (x % i == 0) {                while (x % i == 0) {                    x /= i;                    primes[i]++;                }            }        }        if (x &gt; 1) primes[x]++;    }    LL res = 1;    for (auto prime : primes) {        res = res * (prime.second + 1) % mod;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n5.2.2 约数之和\n给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对1e9+7取模。\n\n#include &lt;bits/stdc++.h&gt;using namespace std;unordered_map&lt;int, int&gt; primes;typedef long long LL;const int mod = 1e9 + 7;int main() {    int n;    cin &gt;&gt; n;    while (n--) {   //求质因数        int c;        cin &gt;&gt; c;        for (int i = 2; i &lt;= c / i; i++) {            if (c % i == 0) {                while (c % i == 0) {                    c /= i;                    primes[i]++;                }            }        }        if (c &gt; 1) primes[c]++;    }    LL res = 1;    for (auto prime : primes) { //套公式        int p = prime.first, mi = prime.second;        LL t = 1;        while (mi--) {            t = (t * p + 1) % mod;        }        res = res * t % mod;    }    cout &lt;&lt; res &lt;&lt; endl;        return 0;}\n\n5.2.3 最大公约数 &amp; 最小公倍数最大公约数通常采用辗转相除法解决。\nint gcd(int a, int b) {    if (b == 0) return a;    else return gcd(b, a % b);}\n\n得到最大公约数d后，最小公倍数即为。\n5.2.4 筛法求欧拉函数\n1 ∼ N中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。若在算数基本定理中，，则：。\n\n\n此题给定一个数n，求1 ～ n之间所有整数的欧拉函数之和。\n\n采用线性筛法，当i % primes[j] == 0时phi[i * primes[j]] = phi[i] * primes[j];因为欧拉函数与次数无关。否则phi[i * primes[j]] = phi[i] * (primes[j] - 1);可以将N拆成i * primes[j]来理解。\nLL getEulur(int n) {    phi[1] = 1;    for (int i = 2; i &lt;= n; i++) {        if (!st[i]) {            primes[cnt++] = i;            phi[i] = i - 1;        }        for (int j = 0; primes[j] &lt;= n / i; j++) {            st[primes[j] * i] = true;            if (i % primes[j] == 0) {                phi[i * primes[j]] = phi[i] * primes[j];                break;            }            phi[i * primes[j]] = phi[i] * (primes[j] - 1);        }    }    LL res = 0;    for (int i = 1; i &lt;= n; i++) {        res += phi[i];    }    return res;}\n\n5.3 快速幂LL quickMi(int a, int b, int p) {    LL res = 1;    while (b) {        if (b &amp; 1) res = res * a % p;        b &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}\n\n5.4 拓展欧几里得拓展欧几里得算法用于：给定两个非零整数a和b，求一组整数解（x，y），使得ax + by = gcd（a，b）成立。其中y和x翻转是为了使得递推公式变得更简洁。\nint exGcd(int a, int b, int &amp;x, int &amp;y) {    if (b == 0) {        x = 1, y = 0;        return a;    }    int d = exGcd(b, a % b, y, x);    y -= a / b * x;    return d;}\n\n5.5 组合数5.5.1 递推，另外当m为0时答案为1。此代码适用于n与m较小的情况。时间复杂度是。\nvoid init() {    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt;= i; j++) {            if (!j) c[i][j] = 1;            else {                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;            }        }    }}\n\n5.5.2 预处理此处b &lt;= a &lt;= 1e5，所以递推法会超时，要用定义法：因为所以需要求阶乘的乘法逆元（用快速幂）。逆元的一大意义就在于将除法取模转化成乘法取模。时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9 + 7;const int N = 1e5 + 10;int fact[N], infact[N]; //表示阶乘和阶乘的逆元LL quickMi(int a, int k, int p) {    LL res = 1;    while (k) {        if (k &amp; 1) res = res * a % p;        k &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}void getFact() {    fact[0] = infact[0] = 1;    for (int i = 1; i &lt; N; i++) {        fact[i] = (LL)fact[i-1] * i % mod;        infact[i] = (LL)infact[i-1] * quickMi(i, mod - 2, mod) % mod;    }}int main() {    int n;    scanf(\"%d\", &amp;n);    getFact();    while (n--) {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        int res = (LL)fact[a] * infact[a-b] % mod * infact[b] % mod;        printf(\"%d\\n\", res);    }        return 0;}\n\n5.5.3 Lucas + 定义 + 逆元用于处理b &lt;= a &lt;= 1e18的极端情况。\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int p;int quickMi(int a, int b) {    int res = 1;    while (b) {        if (b &amp; 1) res = (LL)res * a % p;        b &gt;&gt;= 1;        a = (LL)a * a % p;    }    return res;}int C(int a, int b) {    int res = 1;    for (int i = 1, j = a; i &lt;= b; i++, j--) {        res = (LL)res * j % p;        res = (LL)res * quickMi(i, p - 2) % p;    }    return res;}int Lucas(LL a, LL b) {    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b);    else return (LL)C(a % p, b % p) * Lucas(a / p, b / p) % p;}int main() {    int n;    cin &gt;&gt; n;    while (n--) {        LL a, b;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; Lucas(a, b) &lt;&lt; endl;;    }        return 0;}\n\n6 动态规划什么是动态规划动态规划（Dynamic Programming）是一种用来解决一类最优化问题的算法思想。简单来说，动态规划将一个复杂的问题分解成若干个问题，通过综合子问题的最优解来得到原问题最优解的过程。十分灵活，无固定写法。有以下几个特性：\n\n一个问题必须要有重叠子问题和最优子结构才能用动态规划求解\n与分治的区别：分治不拥有重叠子问题\n与贪心的区别：贪心“自顶向下”，只考虑子问题中最优的一个解。动态规划会考虑所有子问题，并选择继承能得到最优结果的那一个\n设计状态转移方程是动态规划的核心，也是动态规划最难的地方。动态转移方程必须满足状态的无后效性\n\n6.1 背包问题6.1.1 0-1背包问题\n有 n 件物品和一个容量是 m 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi ，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n\n以下是二维数组的解法，dp[i][j]表示选取 1 ～ i 件物品且背包容量最大为 j 时的最优解。在循环中会逐渐增加能选取的物品数量和背包容量。最终答案就是dp[n][m]。\n为什么扩大背包容量一定能增加总价值？因为当 i 固定时，j 逐渐变大过程中只做加法而不做减法。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int dp[N][N], v[N], w[N];int main() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= m; j++) {            dp[i][j] = dp[i-1][j];            if (j &gt;= v[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n考虑到dp[i]只使用了dp[i-1]的结论，所以可以将二维数组优化成一维，最大的改动如下。需要将背包容量从后向前枚举，否则就不是使用dp[i-1]而是dp[i]的结论了。\nfor (int i = 1; i &lt;= n; i++) {    for (int j = m; j &gt;= v[i]; j--) {        dp[j] = max(dp[j], dp[j-v[i]] + w[i]);    }}\n\n6.1.2 完全背包问题\n问题在0-1背包问题的基础上修改为每件物品可以无限次使用。\n\n只需将\ndp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);\n\n修改为\ndp[i][j] = max(dp[i-1][j], dp[i][j-v[i]] + w[i]);\n\n为什么是dp[i]而不是dp[i-1]？因为dp[i][j] &gt;= dp[i-1][j]一定成立，如今第 i 件物品可以无限选择，那么就一定选择更大的那个。也因为这个道理，所以一维优化不需要再从后向前枚举。\nfor (int i = 1; i &lt;= n; i++) {    for (int j = w[i]; j &lt;= m; j++) {        dp[j] = max(dp[j], dp[j - w[i]] + c[i]);    }}\n\n6.1.3 多重背包问题\n问题在完全背包问题基础上修改，每件物品可以使用s[i]次而不是无限次。\n\n既然可以使用的次数有限，那就逐个枚举，让 DP 算法自己判断选取多少个更合适。时间复杂度是。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int dp[N][N], w[N], v[N], s[N];int main() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 0; j &lt;= m; j++) {            for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) {                dp[i][j] = max(dp[i][j], dp[i-1][j - v[i] * k] +  w[i] * k);            }        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;        return 0;}\n\n\n\n6.1.4 多重背包问题（二进制优化）可以将时间复杂度优化为。适用于N，V或者S比较大的情况。\n思路是将每个每个物品的个数拆成其二进制数和某个数的和（如果这个数存在的话），例如将200拆分成 200 = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 73。于是这个物品就可以转化成多个物品，然后整个问题变成了 0-1 背包问题。\n体积变成 k 倍，价值也变成了 k 倍。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 13000;int v[N], w[N];int dp[N];int main() {    int n, m, cnt = 0;  // cnt表示转化后的总物品数    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++) {        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        int k = 1;  // k为二进制倍数        while (k &lt;= s) {            cnt++;            v[cnt] = k * a;            w[cnt] = k * b;            s -= k;            k *= 2;        }        if (s &gt; 0) {            cnt++;            v[cnt] = s * a;            w[cnt] = s * b;        }    }    n = cnt;    for (int i = 1; i &lt;= n; i++) {        for (int j = m; j &gt;= v[i]; j--) {            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);        }    }    cout &lt;&lt; dp[m] &lt;&lt; endl;        return 0;}","categories":["数据结构与算法"],"tags":["基础算法","数据结构","贪心","数学","图论","动态规划"]}]